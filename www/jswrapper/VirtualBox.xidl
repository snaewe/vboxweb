<?xml version="1.0" ?>

<!--

    Copyright (C) 2006-2010 Oracle Corporation

    This file is part of VirtualBox Open Source Edition (OSE), as
    available from http://www.virtualbox.org. This file is free software;
    you can redistribute it and/or modify it under the terms of the GNU
    General Public License (GPL) as published by the Free Software
    Foundation, in version 2 as it comes in the "COPYING" file of the
    VirtualBox OSE distribution. VirtualBox OSE is distributed in the
    hope that it will be useful, but WITHOUT ANY WARRANTY of any kind.
-->

<!--
   This is the master declaration for VirtualBox's Main API,
   represented by COM/XPCOM and web service interfaces.

   From this document, the build system generates several files
   via XSLT that are then used during the build process.

   Below is the list of XSL templates that operate on this file and
   output files they generate. These XSL templates must be updated
   whenever the schema of this file changes:

   1. src/VBox/Main/idl/midl.xsl =>
      out/<platform>/bin/sdk/idl/VirtualBox.idl
      (MS COM interface definition file for Main API)

   2. src/VBox/Main/idl/xpidl.xsl =>
      out/<platform>/bin/sdk/idl/VirtualBox_XPCOM.idl
      (XPCOM interface definition file for Main API)

   3. src/VBox/Main/idl/doxygen.xsl =>
      out/<platform>/obj/src/VBox/Main/VirtualBox.idl
      (pseudo-IDL for Doxygen to generate the official Main API
       documentation)

   4. src/VBox/Main/webservice/*.xsl =>
      a bunch of WSDL and C++ files
      (VirtualBox web service sources and SOAP mappers;
       see src/VBox/Main/webservice/Makefile.kmk for details)

   5. src/VBox/Frontends/VirtualBox/include/COMWrappers.xsl =>
      out/<platform>/obj/src/VBox/Frontends/VirtualBox/VirtualBox/include/COMWrappers.h
      (smart Qt-based C++ wrapper classes for COM interfaces
       of the Main API)

   6. src/VBox/Installer/win32/VirtualBox_TypeLib.xsl =>
      out/<platform>/obj/src/VBox/Installer/win32/VirtualBox_TypeLib.wxi
      (Main API TypeLib block for the WiX installer)

   7. src/VBox/Runtime/common/err/errmsgvboxcom.xsl =>
      out/<platform>/obj/Runtime/errmsgvboxcomdata.h
      (<result> extraction for the %Rhrc format specifier)
-->

<idl>

<desc>
  Welcome to the <b>VirtualBox Main API documentation</b>. This documentation
  describes the so-called <i>VirtualBox Main API</i> which comprises all public
  COM interfaces and components provided by the VirtualBox server and by the
  VirtualBox client library.

  VirtualBox employs a client-server design, meaning that whenever any part of
  VirtualBox is running -- be it the Qt GUI, the VBoxManage command-line
  interface or any virtual machine --, a dedicated server process named
  VBoxSVC runs in the background. This allows multiple processes working with
  VirtualBox to cooperate without conflicts. These processes communicate to each
  other using inter-process communication facilities provided by the COM
  implementation of the host computer.

  On Windows platforms, the VirtualBox Main API uses Microsoft COM, a native COM
  implementation. On all other platforms, Mozilla XPCOM, an open-source COM
  implementation, is used.

  All the parts that a typical VirtualBox user interacts with (the Qt GUI,
  the VBoxManage command-line interface and the VBoxVRDP server) are technically
  front-ends to the Main API and only use the interfaces that are documented
  in this Main API documentation. This ensures that, with any given release
  version of VirtualBox, all capabilities of the product that could be useful
  to an external client program are always exposed by way of this API.

  The VirtualBox Main API (also called the <i>VirtualBox COM library</i>)
  contains two public component classes:
  <tt>%VirtualBox.VirtualBox</tt> and <tt>%VirtualBox.Session</tt>, which
  implement IVirtualBox and ISession interfaces respectively. These two classes
  are of supreme importance and will be needed in order for any front-end
  program to do anything useful. It is recommended to read the documentation of
  the mentioned interfaces first.

  The <tt>%VirtualBox.VirtualBox</tt> class is a singleton. This means that
  there can be only one object of this class on the local machine at any given
  time. This object is a parent of many other objects in the VirtualBox COM
  library and lives in the VBoxSVC process. In fact, when you create an instance
  of the <tt>VirtualBox.VirtualBox</tt>, the COM subsystem checks if the VBoxSVC
  process is already running, starts it if not, and returns you a reference to
  the <tt>VirtualBox</tt> object created in this process. When the last reference
  to this object is released, the VBoxSVC process ends (with a 5 second delay to
  protect from too frequent restarts).

  The <tt>%VirtualBox.Session</tt> class is a regular component. You can create
  as many <tt>Session</tt> objects as you need but all of them will live in a
  process which issues the object instantiation call. <tt>Session</tt> objects
  represent virtual machine sessions which are used to configure virtual
  machines and control their execution.
</desc>

<if target="midl">
  <cpp line="enum {"/>
  <cpp line="    kTypeLibraryMajorVersion = 1,"/>
  <cpp line="    kTypeLibraryMinorVersion = 0"/>
  <cpp line="};"/>
</if>

<if target="xpidl">
  <!-- NS_IMPL_THREADSAFE_ISUPPORTSxx_CI macros are placed here, for convenience -->
  <cpp>
/* currently, nsISupportsImpl.h lacks the below-like macros */

#define NS_IMPL_THREADSAFE_QUERY_INTERFACE1_CI  NS_IMPL_QUERY_INTERFACE1_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE2_CI  NS_IMPL_QUERY_INTERFACE2_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE3_CI  NS_IMPL_QUERY_INTERFACE3_CI

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS1_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS1_CI(_class, _interface)                 \
   NS_IMPL_THREADSAFE_ADDREF(_class)                                          \
   NS_IMPL_THREADSAFE_RELEASE(_class)                                         \
   NS_IMPL_THREADSAFE_QUERY_INTERFACE1_CI(_class, _interface)                 \
   NS_IMPL_CI_INTERFACE_GETTER1(_class, _interface)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS2_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS2_CI(_class, _i1, _i2)                   \
   NS_IMPL_THREADSAFE_ADDREF(_class)                                          \
   NS_IMPL_THREADSAFE_RELEASE(_class)                                         \
   NS_IMPL_THREADSAFE_QUERY_INTERFACE2_CI(_class, _i1, _i2)                   \
   NS_IMPL_CI_INTERFACE_GETTER2(_class, _i1, _i2)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS3_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS3_CI(_class, _i1, _i2, _i3)              \
   NS_IMPL_THREADSAFE_ADDREF(_class)                                          \
   NS_IMPL_THREADSAFE_RELEASE(_class)                                         \
   NS_IMPL_THREADSAFE_QUERY_INTERFACE3_CI(_class, _i1, _i2, _i3)              \
   NS_IMPL_CI_INTERFACE_GETTER3(_class, _i1, _i2, _i3)
#endif

#ifndef NS_IMPL_QUERY_INTERFACE1_AMBIGUOUS_CI
# define NS_IMPL_QUERY_INTERFACE1_AMBIGUOUS_CI(_class, _i1, _ic1)             \
   NS_INTERFACE_MAP_BEGIN(_class)                                             \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i1, _ic1)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, _ic1)                       \
    NS_IMPL_QUERY_CLASSINFO(_class)                                           \
   NS_INTERFACE_MAP_END
#endif

#ifndef NS_IMPL_QUERY_INTERFACE2_AMBIGUOUS_CI
# define NS_IMPL_QUERY_INTERFACE2_AMBIGUOUS_CI(_class, _i1, _ic1,             \
                                               _i2, _ic2)                     \
   NS_INTERFACE_MAP_BEGIN(_class)                                             \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i1, _ic1)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i2, _ic2)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, _ic1)                       \
    NS_IMPL_QUERY_CLASSINFO(_class)                                           \
   NS_INTERFACE_MAP_END
#endif

#ifndef NS_IMPL_QUERY_INTERFACE3_AMBIGUOUS_CI
# define NS_IMPL_QUERY_INTERFACE3_AMBIGUOUS_CI(_class, _i1, _ic1,             \
                                               _i2, _ic2, _i3, _ic3)          \
   NS_INTERFACE_MAP_BEGIN(_class)                                             \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i1, _ic1)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i2, _ic2)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(_i3, _ic3)                               \
    NS_INTERFACE_MAP_ENTRY_AMBIGUOUS(nsISupports, _ic1)                       \
    NS_IMPL_QUERY_CLASSINFO(_class)                                           \
   NS_INTERFACE_MAP_END
#endif

#define NS_IMPL_THREADSAFE_QUERY_INTERFACE1_AMBIGUOUS_CI NS_IMPL_QUERY_INTERFACE1_AMBIGUOUS_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE2_AMBIGUOUS_CI NS_IMPL_QUERY_INTERFACE2_AMBIGUOUS_CI
#define NS_IMPL_THREADSAFE_QUERY_INTERFACE3_AMBIGUOUS_CI NS_IMPL_QUERY_INTERFACE3_AMBIGUOUS_CI

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS1_AMBIGUOUS_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS1_AMBIGUOUS_CI(_class, _i1, _ic1)        \
   NS_IMPL_THREADSAFE_ADDREF(_class)                                          \
   NS_IMPL_THREADSAFE_RELEASE(_class)                                         \
   NS_IMPL_THREADSAFE_QUERY_INTERFACE1_AMBIGUOUS_CI(_class, _i1, _ic1)        \
   NS_IMPL_CI_INTERFACE_GETTER1(_class, _i1)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS2_AMBIGUOUS_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS2_AMBIGUOUS_CI(_class, _i1, _ic1,        \
                                                     _i2, _ic2)               \
   NS_IMPL_THREADSAFE_ADDREF(_class)                                          \
   NS_IMPL_THREADSAFE_RELEASE(_class)                                         \
   NS_IMPL_THREADSAFE_QUERY_INTERFACE2_AMBIGUOUS_CI(_class, _i1, _ic1,        \
                                                    _i2, _ic2)                \
   NS_IMPL_CI_INTERFACE_GETTER2(_class, _i1, _i2)
#endif

#ifndef NS_IMPL_THREADSAFE_ISUPPORTS3_AMBIGUOUS_CI
# define NS_IMPL_THREADSAFE_ISUPPORTS3_AMBIGUOUS_CI(_class, _i1, _ic1,        \
                                                     _i2, _ic2, _i3, _ic3)    \
   NS_IMPL_THREADSAFE_ADDREF(_class)                                          \
   NS_IMPL_THREADSAFE_RELEASE(_class)                                         \
   NS_IMPL_THREADSAFE_QUERY_INTERFACE3_AMBIGUOUS_CI(_class, _i1, _ic1,        \
                                                    _i2, _ic2, _i3, _ic3)     \
   NS_IMPL_CI_INTERFACE_GETTER3(_class, _i1, _i2, _i3)
#endif

  </cpp>
</if>

<library
   name="VirtualBox"
   uuid="46137EEC-703B-4fe5-AFD4-7C9BBBBA0259"
   version="1.3"
   desc="VirtualBox Type Library"
   appUuid="819B4D85-9CEE-493C-B6FC-64FFE759B3C9"
   supportsErrorInfo="yes"
>


  <!--
  // COM result codes for VirtualBox
  /////////////////////////////////////////////////////////////////////////
  -->

  <descGroup id="VirtualBox_COM_result_codes" title="VirtualBox COM result codes">
    <desc>
      This section describes all VirtualBox-specific COM result codes that may
      be returned by methods of VirtualBox COM interfaces in addition to
      standard COM result codes.

      Note that along with the result code, every VirtualBox method returns
      extended error information through the IVirtualBoxErrorInfo interface on
      failure. This interface is a preferred way to present the error to the end
      user because it contains a human readable description of the error. Raw
      result codes, both standard and described in this section, are intended to
      be used by programs to analyze the reason of a failure and select an
      appropriate course of action without involving the end user (for example,
      retry the operation later or make a different call).

      The standard COM result codes that may originate from our methods include:

      <table>
      <tr><td>E_INVALIDARG</td>
      <td>
        Returned when the value of the method's argument is not within the range
        of valid values. This should not be confused with situations when the
        value is within the range but simply doesn't suit the current object
        state and there is a possibility that it will be accepted later (in such
        cases VirtualBox-specific codes are returned, for example,
        <link to="VBOX_E_OBJECT_NOT_FOUND"/>).
      </td>
      </tr>
      <tr><td>E_POINTER</td>
      <td>
        Returned if a memory pointer for the output argument is invalid (for
        example, @c null). Note that when pointers representing input
        arguments (such as strings) are invalid, E_INVALIDARG is returned.
      </td>
      </tr>
      <tr><td>E_ACCESSDENIED</td>
      <td>
        Returned when the called object is not ready. Since the lifetime of a
        public COM object cannot be fully controlled by the implementation,
        VirtualBox maintains the readiness state for all objects it creates and
        returns this code in response to any method call on the object that was
        deactivated by VirtualBox and is not functioning any more.
      </td>
      </tr>
      <tr><td>E_OUTOFMEMORY</td>
      <td>
        Returned when a memory allocation operation fails.
      </td>
      </tr>
      </table>
    </desc>
  </descGroup>

  <!--
    Note that src/VBox/Runtime/common/err/errmsgvboxcom.xsl will ignore
    everything in <result>/<desc> after (and including) the first dot, so express
    the matter of the error code in the first sentence and keep it short.
  -->

  <result name="VBOX_E_OBJECT_NOT_FOUND" value="0x80BB0001">
    <desc>
      Object corresponding to the supplied arguments does not exist.
    </desc>
  </result>

  <result name="VBOX_E_INVALID_VM_STATE" value="0x80BB0002">
    <desc>
      Current virtual machine state prevents the operation.
    </desc>
  </result>

  <result name="VBOX_E_VM_ERROR" value="0x80BB0003">
    <desc>
      Virtual machine error occurred attempting the operation.
    </desc>
  </result>

  <result name="VBOX_E_FILE_ERROR" value="0x80BB0004">
    <desc>
      File not accessible or erroneous file contents.
    </desc>
  </result>

  <result name="VBOX_E_IPRT_ERROR" value="0x80BB0005">
    <desc>
      Runtime subsystem error.
    </desc>
  </result>

  <result name="VBOX_E_PDM_ERROR" value="0x80BB0006">
    <desc>
      Pluggable Device Manager error.
    </desc>
  </result>

  <result name="VBOX_E_INVALID_OBJECT_STATE" value="0x80BB0007">
    <desc>
      Current object state prohibits operation.
    </desc>
  </result>

  <result name="VBOX_E_HOST_ERROR" value="0x80BB0008">
    <desc>
      Host operating system related error.
    </desc>
  </result>

  <result name="VBOX_E_NOT_SUPPORTED" value="0x80BB0009">
    <desc>
      Requested operation is not supported.
    </desc>
  </result>

  <result name="VBOX_E_XML_ERROR" value="0x80BB000A">
    <desc>
      Invalid XML found.
    </desc>
  </result>

  <result name="VBOX_E_INVALID_SESSION_STATE" value="0x80BB000B">
    <desc>
      Current session state prohibits operation.
    </desc>
  </result>

  <result name="VBOX_E_OBJECT_IN_USE" value="0x80BB000C">
    <desc>
      Object being in use prohibits operation.
    </desc>
  </result>

  <result name="VBOX_E_DONT_CALL_AGAIN" value="0x80BB000D">
    <desc>
      Returned by callback methods which does not need to be called again
      because the client does not actually make use of them.
    </desc>
  </result>

  <!--
    Note that src/VBox/Runtime/common/err/errmsgvboxcom.xsl will ignore
    everything in <result>/<desc> after (and including) the first dot, so express
    the matter of the error code in the first sentence and keep it short.
  -->

  <descGroup/>

  <!--
  // all common enums
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum name="SettingsVersion"
        uuid="52bd6f5f-1adb-4493-975d-581a9c4b803f"
    >
    <desc>Settings version of VirtualBox settings files. This is written to
          the "version" attribute of the root "VirtualBox" element in the settings
          file XML and indicates which VirtualBox version wrote the file.
    </desc>

    <const name="Null"    value="0">
      <desc>Null value, indicates invalid version.</desc>
    </const>
    <const name="v1_0"     value="1">
      <desc>Legacy settings version, not currently supported.</desc>
    </const>
    <const name="v1_1"     value="2">
      <desc>Legacy settings version, not currently supported.</desc>
    </const>
    <const name="v1_2"     value="3">
      <desc>Legacy settings version, not currently supported.</desc>
    </const>
    <const name="v1_3pre"  value="4">
      <desc>Legacy settings version, not currently supported.</desc>
    </const>
    <const name="v1_3"     value="5">
      <desc>Settings version "1.3", written by VirtualBox 2.0.12.</desc>
      <!--
            Machine XML: Capitalization of Uart, Lpt elements and many attributes changed.
      -->
    </const>
    <const name="v1_4"     value="6">
      <desc>Intermediate settings version, understood by VirtualBox 2.1.x.</desc>
      <!--
          VirtualBox.xml: big DiskRegistry -> MediaRegistry revamp, various HardDisk types merged
          (was VirtualDiskImage, VMDKImage, VHDImage, ISCSIHardDisk, CustomHardDisk, DiffHardDisk)
      -->
    </const>
    <const name="v1_5"     value="7">
      <desc>Intermediate settings version, understood by VirtualBox 2.1.x.</desc>
      <!-- 2008-09-04: 2.0.0 released
           2008-11-20: settings version 1.5 introduced
           2008-12-17: 2.1.0 released
           Machine changes:
              guest OS identifiers changed;
              Machine/Hardware/Display/MonitorCount renamed to monitorCount;
              Machine/Hardware/Display/Accelerate3D renamed to accelerate3D;
              Machine/Hardware/CPU/CPUCount/@count changed to CPU/@count
      -->
    </const>
    <const name="v1_6"     value="8">
      <desc>Settings version "1.6", written by VirtualBox 2.1.4 (at least).</desc>
      <!-- 2008-12-17: 2.1.0 released
           2008-12-19: settings version 1.6 introduced (is in 2.1 branch)
           2009-04-08: 2.2.0 released
           Machine changes: remove all Machine/Hardware/Network/Adapter/HostInterface[@TAPSetup or @TAPTerminate]/ attributes (done)
      -->
    </const>
    <const name="v1_7"     value="9">
      <desc>Settings version "1.7", written by VirtualBox 2.2.x and 3.0.x.</desc>
      <!-- 2008-12-17: 2.1.0 released
           2009-03-11: settings version 1.7 introduced (is in 2.2 branch)
           2009-04-08: 2.2.0 released
           VirtualBox.xml additions: NetserviceRegistry with DHCPServers (done)
           Machine changes: HardDiskAttachments is now StorageControllers (done)
      -->
    </const>
    <const name="v1_8"     value="10">
      <desc>Intermediate settings version "1.8", understood by VirtualBox 3.1.x.</desc>
      <!-- Machine additions: Display/@accelerate2DVideo (done)
      -->
    </const>
    <const name="v1_9"     value="11">
      <desc>Settings version "1.9", written by VirtualBox 3.1.x.</desc>
      <!-- The big storage controller / DVD / Floppy rework (done)
           -->
    </const>
    <const name="v1_10"     value="12">
      <desc>Settings version "1.10", written by VirtualBox 3.2.x.</desc>
      <!-- Machine changes: RTC localOrUTC (done)
           CPU hot-plug support
           -->
    </const>
    <const name="Future"     value="13">
      <desc>Settings version greater than "1.10", written by a future VirtualBox version.</desc>
    </const>
  </enum>

  <enum
       name="AccessMode"
       uuid="1da0007c-ddf7-4be8-bcac-d84a1558785f"
       >
      <desc>
          Access mode for opening files.
      </desc>

      <const name="ReadOnly"   value="1"/>
      <const name="ReadWrite"  value="2"/>
  </enum>

  <enum
    name="MachineState"
    uuid="e998d075-543a-41fc-8aa9-5ca3e92393fd"
  >
    <desc>
      Virtual machine execution state.

      This enumeration represents possible values of the <link
      to="IMachine::state"/> attribute.

      Below is the basic virtual machine state diagram. It shows how the state
      changes during virtual machine execution. The text in square braces shows
      a method of the IConsole interface that performs the given state
      transition.

      <pre>
            +---------[powerDown()] &lt;- Stuck &lt;--[failure]-+
            V                                             |
    +-&gt; PoweredOff --+--&gt;[powerUp()]--&gt; Starting --+      | +-----[resume()]-----+
    |                |                             |      | V                    |
    |   Aborted -----+                             +--&gt; Running --[pause()]--&gt; Paused
    |                                              |      ^ |                   ^ |
    |   Saved -----------[powerUp()]--&gt; Restoring -+      | |                   | |
    |     ^                                               | |                   | |
    |     |     +-----------------------------------------+-|-------------------+ +
    |     |     |                                           |                     |
    |     |     +-- Saving &lt;--------[takeSnapshot()]&lt;-------+---------------------+
    |     |                                                 |                     |
    |     +-------- Saving &lt;--------[saveState()]&lt;----------+---------------------+
    |                                                       |                     |
    +-------------- Stopping -------[powerDown()]&lt;----------+---------------------+
      </pre>

      Note that states to the right from PoweredOff, Aborted and Saved in the
      above diagram are called <i>online VM states</i>. These states
      represent the virtual machine which is being executed in a dedicated
      process (usually with a GUI window attached to it where you can see the
      activity of the virtual machine and interact with it). There are two
      special pseudo-states, FirstOnline and LastOnline, that can be used in
      relational expressions to detect if the given machine state is online or
      not:

      <pre>
        if (machine.GetState() &gt;= MachineState_FirstOnline &amp;&amp;
            machine.GetState() &lt;= MachineState_LastOnline)
        {
            ...the machine is being executed...
        }
      </pre>

      When the virtual machine is in one of the online VM states (that is, being
      executed), only a few machine settings can be modified. Methods working
      with such settings contain an explicit note about that. An attempt to
      change any oter setting or perform a modifying operation during this time
      will result in the <link to="VBOX_E_INVALID_VM_STATE"/> error.

      All online states except Running, Paused and Stuck are transitional: they
      represent temporary conditions of the virtual machine that will last as
      long as the operation that initiated such a condition.

      The Stuck state is a special case. It means that execution of the machine
      has reached the "Guru Meditation" condition. This condition indicates an
      internal VMM (virtual machine manager) failure which may happen as a
      result of either an unhandled low-level virtual hardware exception or one
      of the recompiler exceptions (such as the <i>too-many-traps</i>
      condition).

      Note also that any online VM state may transit to the Aborted state. This
      happens if the process that is executing the virtual machine terminates
      unexpectedly (for example, crashes). Other than that, the Aborted state is
      equivalent to PoweredOff.

      There are also a few additional state diagrams that do not deal with
      virtual machine execution and therefore are shown separately. The states
      shown on these diagrams are called <i>offline VM states</i> (this includes
      PoweredOff, Aborted and Saved too).

      The first diagram shows what happens when a lengthy setup operation is
      being executed (such as <link to="IMachine::attachDevice"/>).

      <pre>
    +----------------------------------(same state as before the call)------+
    |                                                                       |
    +-&gt; PoweredOff --+                                                      |
    |                |                                                      |
    |-&gt; Aborted -----+--&gt;[lengthy VM configuration call] --&gt; SettingUp -----+
    |                |
    +-&gt; Saved -------+
      </pre>

      The next two diagrams demonstrate the process of taking a snapshot of a
      powered off virtual machine, restoring the state to that as of a snapshot
      or deleting a snapshot, respectively.

      <pre>
    +----------------------------------(same state as before the call)------+
    |                                                                       |
    +-&gt; PoweredOff --+                                                      |
    |                +--&gt;[takeSnapshot()] -------------------&gt; Saving ------+
    +-&gt; Aborted -----+

    +-&gt; PoweredOff --+
    |                |
    |   Aborted -----+--&gt;[restoreSnapshot()    ]-------&gt; RestoringSnapshot -+
    |                |   [deleteSnapshot()     ]-------&gt; DeletingSnapshot --+
    +-&gt; Saved -------+                                                      |
    |                                                                       |
    +---(Saved if restored from an online snapshot, PoweredOff otherwise)---+
      </pre>

      Note that the Saving state is present in both the offline state group and
      online state group. Currently, the only way to determine what group is
      assumed in a particular case is to remember the previous machine state: if
      it was Running or Paused, then Saving is an online state, otherwise it is
      an offline state. This inconsistency may be removed in one of the future
      versions of VirtualBox by adding a new state.

      <note internal="yes">
        For whoever decides to touch this enum: In order to keep the
        comparisons involving FirstOnline and LastOnline pseudo-states valid,
        the numeric values of these states must be correspondingly updated if
        needed: for any online VM state, the condition
        <tt>FirstOnline &lt;= state &lt;= LastOnline</tt> must be
        @c true. The same relates to transient states for which
        the condition <tt>FirstOnline &lt;= state &lt;= LastOnline</tt> must be
        @c true.
      </note>
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="PoweredOff"            value="1">
      <desc>
        The machine is not running and has no saved execution state; it has
        either never been started or been shut down successfully.
      </desc>
    </const>
    <const name="Saved"                 value="2">
      <desc>
        The machine is not currently running, but the execution state of the machine
        has been saved to an external file when it was running, from where
        it can be resumed.
      </desc>
    </const>
    <const name="Teleported"            value="3">
      <desc>
        The machine was teleported to a different host (or process) and then
        powered off.  Take care when powering it on again may corrupt resources
        it shares with the teleportation target (e.g. disk and network).
      </desc>
    </const>
    <const name="Aborted"               value="4">
      <desc>
        The process running the machine has terminated abnormally. This may
        indicate a crash of the VM process in host execution context, or
        the VM process has been terminated externally.
      </desc>
    </const>
    <const name="Running"               value="5">
      <desc>
        The machine is currently being executed.
        <note internal="yes">
          For whoever decides to touch this enum: In order to keep the
          comparisons in the old source code valid, this state must immediately
          precede the Paused state.
          TODO: Lift this spectacularly wonderful restriction.
        </note>
      </desc>
    </const>
    <const name="Paused"                value="6">
      <desc>
        Execution of the machine has been paused.
        <note internal="yes">
          For whoever decides to touch this enum: In order to keep the
          comparisons in the old source code valid, this state must immediately
          follow the Running state.
          TODO: Lift this spectacularly wonderful restriction.
        </note>
      </desc>
    </const>
    <const name="Stuck"                 value="7">
      <desc>
        Execution of the machine has reached the "Guru Meditation"
        condition. This indicates a severe error in the hypervisor itself.
        <note internal="yes">
          bird: Why this uncool name? Could we rename it to "GuruMeditation" or
                "Guru", perhaps? Or are there some other VMM states that are
                intended to be lumped in here as well?
        </note>
      </desc>
    </const>
    <const name="Teleporting"           value="8">
      <desc>
        The machine is about to be teleported to a different host or process.
        It is possible to pause a machine in this state, but it will go to the
        <link to="MachineState::PausedTeleporting"/> state and it will not be
        possible to resume it again unless the teleportation fails.
      </desc>
    </const>
    <const name="LiveSnapshotting"      value="9">
      <desc>
        A live snapshot is being taken.  The machine is running normally, but
        some of the runtime configuration options are inaccessible.  Also, if
        paused while in this state it will transition to
        <link to="MachineState::Saving"/> and it will not be resume the
        execution until the snapshot operation has completed.
      </desc>
    </const>
    <const name="Starting"              value="10">
      <desc>
        Machine is being started after powering it on from a
        zero execution state.
      </desc>
    </const>
    <const name="Stopping"              value="11">
      <desc>
        Machine is being normally stopped powering it off, or after the guest OS
        has initiated a shutdown sequence.
      </desc>
    </const>
    <const name="Saving"                value="12">
      <desc>
        Machine is saving its execution state to a file, or an online
        snapshot of the machine is being taken.
      </desc>
    </const>
    <const name="Restoring"             value="13">
      <desc>
        Execution state of the machine is being restored from a file
        after powering it on from the saved execution state.
      </desc>
    </const>
    <const name="TeleportingPausedVM"   value="14">
      <desc>
        The machine is being teleported to another host or process, but it is
        not running.  This is the paused variant of the
        <link to="MachineState::Teleporting"/> state.
      </desc>
    </const>
    <const name="TeleportingIn"         value="15">
      <desc>
        Teleporting the machine state in from another host or process.
      </desc>
    </const>
    <const name="DeletingSnapshotOnline" value="16">
      <desc>
        Teleporting the machine state in from another host or process.
      </desc>
    </const>
    <const name="DeletingSnapshotPaused" value="17">
      <desc>
        Teleporting the machine state in from another host or process.
      </desc>
    </const>
    <const name="RestoringSnapshot"     value="18">
      <desc>
        A machine snapshot is being restored; this typically does not take long.
      </desc>
    </const>
    <const name="DeletingSnapshot"      value="19">
      <desc>
        A machine snapshot is being deleted; this can take a long time since this
        may require merging differencing media.
      </desc>
    </const>
    <const name="SettingUp"             value="20">
      <desc>
        Lengthy setup operation is in progress.
      </desc>
    </const>

    <const name="FirstOnline" value="5" wsmap="suppress"> <!-- Running -->
      <desc>
        Pseudo-state: first online state (for use in relational expressions).
      </desc>
    </const>
    <const name="LastOnline"  value="17" wsmap="suppress"> <!-- DeletingSnapshotPaused -->
      <desc>
        Pseudo-state: last online state (for use in relational expressions).
      </desc>
    </const>

    <const name="FirstTransient" value="8" wsmap="suppress"> <!-- Teleporting -->
      <desc>
        Pseudo-state: first transient state (for use in relational expressions).
      </desc>
    </const>
    <const name="LastTransient"  value="20" wsmap="suppress"> <!-- SettingUp -->
      <desc>
        Pseudo-state: last transient state (for use in relational expressions).
      </desc>
    </const>

  </enum>

  <enum
    name="SessionState"
    uuid="cf2700c0-ea4b-47ae-9725-7810114b94d8"
  >
    <desc>
      Session state. This enumeration represents possible values of
      <link to="IMachine::sessionState"/> and <link to="ISession::state"/>
      attributes. See individual enumerator descriptions for the meaning for
      every value.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Closed"                value="1">
      <desc>
        The machine has no open sessions (<link to="IMachine::sessionState"/>);
        the session is closed (<link to="ISession::state"/>)
      </desc>
    </const>
    <const name="Open"                  value="2">
      <desc>
        The machine has an open direct session (<link to="IMachine::sessionState"/>);
        the session is open (<link to="ISession::state"/>)
      </desc>
    </const>
    <const name="Spawning"              value="3">
      <desc>
        A new (direct) session is being opened for the machine as a result of
        <link to="IVirtualBox::openRemoteSession"/> call
        (<link to="IMachine::sessionState"/> or <link to="ISession::state"/>).
        This state also occurs as a short transient state when a new direct
        session is opened by calling <link to="IVirtualBox::openSession"/>.
      </desc>
    </const>
    <const name="Closing"               value="4">
      <desc>
        The direct session is being closed (<link to="IMachine::sessionState"/>);
        the session is being closed (<link to="ISession::state"/>)
      </desc>
    </const>
  </enum>

  <enum
    name="CPUPropertyType"
    uuid="24d356a6-2f45-4abd-b977-1cbe9c4701f5"
  >
    <desc>
      Virtual CPU property type. This enumeration represents possible values of the
      IMachine get- and setCPUProperty methods.
    </desc>
    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="PAE"                   value="1">
      <desc>
        This setting determines whether VirtualBox will expose the Physical Address
        Extension (PAE) feature of the host CPU to the guest. Note that in case PAE
        is not available, it will not be reported.
      </desc>
    </const>
    <const name="Synthetic"             value="2">
      <desc>
        This setting determines whether VirtualBox will expose a synthetic CPU to the guest to allow
        teleporting between host systems that differ significantly.
      </desc>
    </const>
  </enum>


  <enum
    name="HWVirtExPropertyType"
    uuid="ce81dfdd-d2b8-4a90-bbea-40ee8b7ffcee"
  >
    <desc>
      Hardware virtualization property type. This enumeration represents possible values
      for the <link to="IMachine::getHWVirtExProperty"/> and
      <link to="IMachine::setHWVirtExProperty"/> methods.
    </desc>
    <const name="Null"                value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Enabled"             value="1">
      <desc>
        Whether hardware virtualization (VT-x/AMD-V) is enabled at all. If
        such extensions are not available, they will not be used.
      </desc>
    </const>
    <const name="Exclusive"           value="2">
      <desc>
        Whether hardware virtualization is used exclusively by VirtualBox. When enabled,
        VirtualBox assumes it can acquire full and exclusive access to the VT-x or AMD-V
        feature of the host. To share these with other hypervisors, you must disable this property.
      </desc>
    </const>
    <const name="VPID"                value="3">
      <desc>
        Whether VT-x VPID is enabled. If this extension is not available, it will not be used.
      </desc>
    </const>
    <const name="NestedPaging"        value="4">
      <desc>
        Whether Nested Paging is enabled. If this extension is not available, it will not be used.
      </desc>
    </const>
    <const name="LargePages"          value="5">
      <desc>
        Whether large page allocation is enabled; requires nested paging and a 64 bits host.
      </desc>
    </const>
  </enum>

  <enum
    name="SessionType"
    uuid="A13C02CB-0C2C-421E-8317-AC0E8AAA153A"
  >
    <desc>
      Session type. This enumeration represents possible values of the
      <link to="ISession::type"/> attribute.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Direct"                value="1">
      <desc>
        Direct session
        (opened by <link to="IVirtualBox::openSession"/>)
      </desc>
    </const>
    <const name="Remote"                value="2">
      <desc>
        Remote session
        (opened by <link to="IVirtualBox::openRemoteSession"/>)
      </desc>
    </const>
    <const name="Existing"              value="3">
      <desc>
        Existing session
        (opened by <link to="IVirtualBox::openExistingSession"/>)
      </desc>
    </const>
  </enum>

  <enum
    name="DeviceType"
    uuid="6d9420f7-0b56-4636-99f9-7346f1b01e57"
  >
    <desc>
      Device type.
    </desc>
    <const name="Null"              value="0">
      <desc>
        Null value, may also mean "no device" (not allowed for
        <link to="IConsole::getDeviceActivity"/>).
      </desc>
    </const>
    <const name="Floppy"            value="1">
      <desc>Floppy device.</desc>
    </const>
    <const name="DVD"               value="2">
      <desc>CD/DVD-ROM device.</desc>
    </const>
    <const name="HardDisk"          value="3">
      <desc>Hard disk device.</desc>
    </const>
    <const name="Network"           value="4">
      <desc>Network device.</desc>
    </const>
    <const name="USB"               value="5">
      <desc>USB device.</desc>
    </const>
    <const name="SharedFolder"      value="6">
      <desc>Shared folder device.</desc>
    </const>
  </enum>

  <enum
    name="DeviceActivity"
    uuid="6FC8AEAA-130A-4eb5-8954-3F921422D707"
  >
    <desc>
      Device activity for <link to="IConsole::getDeviceActivity"/>.
    </desc>

    <const name="Null"              value="0"/>
    <const name="Idle"              value="1"/>
    <const name="Reading"           value="2"/>
    <const name="Writing"           value="3"/>
  </enum>

  <enum
    name="ClipboardMode"
    uuid="33364716-4008-4701-8f14-be0fa3d62950"
  >
    <desc>
     Host-Guest clipboard interchange mode.
    </desc>

    <const name="Disabled"          value="0"/>
    <const name="HostToGuest"       value="1"/>
    <const name="GuestToHost"       value="2"/>
    <const name="Bidirectional"     value="3"/>
  </enum>

  <enum
    name="Scope"
    uuid="7c91096e-499e-4eca-9f9b-9001438d7855"
  >
    <desc>
      Scope of the operation.

      A generic enumeration used in various methods to define the action or
      argument scope.
    </desc>

    <const name="Global"          value="0"/>
    <const name="Machine"         value="1"/>
    <const name="Session"         value="2"/>
  </enum>

  <enum
    name="BIOSBootMenuMode"
    uuid="ae4fb9f7-29d2-45b4-b2c7-d579603135d5"
  >
    <desc>
      BIOS boot menu mode.
    </desc>

    <const name="Disabled"        value="0"/>
    <const name="MenuOnly"        value="1"/>
    <const name="MessageAndMenu"  value="2"/>
  </enum>

  <enum
    name="ProcessorFeature"
    uuid="64c38e6b-8bcf-45ad-ac03-9b406287c5bf"
  >
    <desc>
      CPU features.
    </desc>

    <const name="HWVirtEx"        value="0"/>
    <const name="PAE"             value="1"/>
    <const name="LongMode"        value="2"/>
    <const name="NestedPaging"    value="3"/>
  </enum>

   <enum
    name="FirmwareType"
    uuid="b903f264-c230-483e-ac74-2b37ce60d371"
   >
    <desc>
      Firmware type.
    </desc>
    <const name="BIOS"           value="1">
      <desc>BIOS Firmware.</desc>
    </const>
    <const name="EFI"            value="2">
      <desc>EFI Firmware, bitness detetced basing on OS type.</desc>
    </const>
    <const name="EFI32"          value="3">
      <desc>Efi firmware, 32-bit.</desc>
    </const>
    <const name="EFI64"          value="4">
      <desc>Efi firmware, 64-bit.</desc>
    </const>
    <const name="EFIDUAL"        value="5">
      <desc>Efi firmware, combined 32 and 64-bit.</desc>
    </const>
  </enum>

   <enum
    name="PointingHidType"
    uuid="0d3c17a2-821a-4b2e-ae41-890c6c60aa97"
   >
    <desc>
      Type of pointing device used in a virtual machine.
    </desc>
    <const name="None"           value="1">
      <desc>No mouse.</desc>
    </const>
    <const name="PS2Mouse"       value="2">
      <desc>PS/2 auxillary device, a.k.a. mouse.</desc>
    </const>
    <const name="USBMouse"       value="3">
      <desc>USB mouse (relative pointer).</desc>
    </const>
    <const name="USBTablet"      value="4">
      <desc>USB tablet (absolute pointer).</desc>
    </const>
    <const name="ComboMouse"     value="5">
      <desc>Combined device, working as PS/2 or USB mouse, depending on guest behavior.
      Using of such device can have negative performance implications. </desc>
    </const>
  </enum>

   <enum
    name="KeyboardHidType"
    uuid="5a5b0996-3a3e-44bb-9019-56979812cbcc"
   >
    <desc>
      Type of keyboard device used in a virtual machine.
    </desc>
    <const name="None"              value="1">
      <desc>No keyboard.</desc>
    </const>
    <const name="PS2Keyboard"       value="2">
      <desc>PS/2 keyboard.</desc>
    </const>
    <const name="USBKeyboard"       value="3">
      <desc>USB keyboard.</desc>
    </const>
    <const name="ComboKeyboard"     value="4">
      <desc>Combined device, working as PS/2 or USB keyboard, depending on guest behavior.
      Using of such device can have negative performance implications. </desc>
    </const>
  </enum>

  <!--
  // IVirtualBoxErrorInfo
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IVirtualBoxErrorInfo" extends="$errorinfo"
     uuid="4b86d186-407e-4f9e-8be8-e50061be8725"
     supportsErrorInfo="no"
     wsmap="managed"
     >
    <desc>
      The IVirtualBoxErrorInfo interface represents extended error information.

      Extended error information can be set by VirtualBox components after
      unsuccessful or partially successful method invocation. This information
      can be retrieved by the calling party as an IVirtualBoxErrorInfo object
      and then shown to the client in addition to the plain 32-bit result code.

      In MS COM, this interface extends the IErrorInfo interface,
      in XPCOM, it extends the nsIException interface. In both cases,
      it provides a set of common attributes to retrieve error
      information.

      Sometimes invocation of some component's method may involve methods of
      other components that may also fail (independently of this method's
      failure), or a series of non-fatal errors may precede a fatal error that
      causes method failure. In cases like that, it may be desirable to preserve
      information about all errors happened during method invocation and deliver
      it to the caller. The <link to="#next"/> attribute is intended
      specifically for this purpose and allows to represent a chain of errors
      through a single IVirtualBoxErrorInfo object set after method invocation.

      Note that errors are stored to a chain in the reverse order, i.e. the
      initial error object you query right after method invocation is the last
      error set by the callee, the object it points to in the @a next attribute
      is the previous error and so on, up to the first error (which is the last
      in the chain).
    </desc>

    <attribute name="resultCode" type="long" readonly="yes">
      <desc>
        Result code of the error.
        Usually, it will be the same as the result code returned
        by the method that provided this error information, but not
        always. For example, on Win32, CoCreateInstance() will most
        likely return E_NOINTERFACE upon unsuccessful component
        instantiation attempt, but not the value the component factory
        returned. Value is typed 'long', not 'result',
        to make interface usable from scripting languages.
        <note>
          In MS COM, there is no equivalent.
          In XPCOM, it is the same as nsIException::result.
        </note>
      </desc>
    </attribute>

    <attribute name="interfaceID" type="uuid" mod="string" readonly="yes">
      <desc>
        UUID of the interface that defined the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetGUID, except for the
          data type.
          In XPCOM, there is no equivalent.
        </note>
      </desc>
    </attribute>

    <attribute name="component" type="wstring" readonly="yes">
      <desc>
        Name of the component that generated the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetSource.
          In XPCOM, there is no equivalent.
        </note>
      </desc>
    </attribute>

    <attribute name="text" type="wstring" readonly="yes">
      <desc>
        Text description of the error.
        <note>
          In MS COM, it is the same as IErrorInfo::GetDescription.
          In XPCOM, it is the same as nsIException::message.
        </note>
      </desc>
    </attribute>

    <attribute name="next" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Next error object if there is any, or @c null otherwise.
        <note>
          In MS COM, there is no equivalent.
          In XPCOM, it is the same as nsIException::inner.
        </note>
      </desc>
    </attribute>

  </interface>

  <interface
     name="ILocalOwner" extends="$unknown"
     uuid="308FF42A-DC45-49D4-A950-B1EEE5E00BB5" wsmap="suppress"
     >
    <desc>
      The ILocalOwner interface allows to register local objects
      (created without COM calls, but with new()).
      Once registered, calls to methods of such objects can be made
      from remote COM processes.
      The main usecase is the event callback implementation where
      API clients provide callback objects.
    </desc>
    <method name="setLocalObject">
      <desc>
        Set local object.
      </desc>
      <param name="object" type="$unknown" dir="in">
        <desc>Local object to forward requests to.
          If null, clears currently set local object.</desc>
      </param>
    </method>
  </interface>

  <!--
  // IVirtualBox
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IVirtualBoxCallback" extends="$unknown"
     uuid="7f6a65b6-ad5d-4a67-8872-0b11cb7ea95c"
     wsmap="suppress"
     >

    <method name="onMachineStateChange">
      <desc>
        The execution state of the given machine has changed.
        <see>IMachine::state</see>
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="state" type="MachineState" dir="in">
        <desc>New execution state.</desc>
      </param>
    </method>

    <method name="onMachineDataChange">
      <desc>
        Any of the settings of the given machine has changed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
    </method>

    <method name="onExtraDataCanChange">
      <desc>
        Notification when someone tries to change extra data for
        either the given machine or (if @c null) global extra data.
        This gives the chance to veto against changes.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP. Change is allowed.
        </result>
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>
          ID of the machine this event relates to
          (@c null ID for global extra data change requests).
        </desc>
      </param>
      <param name="key" type="wstring" dir="in">
        <desc>
          Extra data key for the attempted write.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          Extra data value for the given key.
        </desc>
      </param>
      <param name="error" type="wstring" dir="out">
        <desc>
          Optional error message describing the reason of the
          veto (ignored if this notification returns @c true).
        </desc>
      </param>
      <param name="allowChange" type="boolean" dir="return">
        <desc>
          Flag to indicate whether the callee agrees (@c true)
          or vetoes against the change (@c false).
        </desc>
      </param>
    </method>

    <method name="onExtraDataChange">
      <desc>
        Notification when machine specific or global extra data
        has changed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>
          ID of the machine this event relates to.
          Null for global extra data changes.
        </desc>
      </param>
      <param name="key" type="wstring" dir="in">
        <desc>
          Extra data key that has changed.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          Extra data value for the given key.
        </desc>
      </param>
    </method>

    <method name="onMediumRegistered">
      <desc>
        The given medium was registered or unregistered
        within this VirtualBox installation.

        The @a mediumType parameter describes what type of
        medium the specified @a mediumId refers to. Possible
        values are:

        <ul>
        <li><link to="DeviceType_HardDisk"/>: the medium is a hard disk
        that, if registered, can be obtained using the
        <link to="IVirtualBox::getHardDisk"/> call.</li>
        <li><link to="DeviceType_DVD"/>: the medium is a CD/DVD image
        that, if registered, can be obtained using the
        <link to="IVirtualBox::getDVDImage"/> call.</li>
        <li><link to="DeviceType_Floppy"/>: the medium is a Floppy image
        that, if registered, can be obtained using the
        <link to="IVirtualBox::getFloppyImage"/> call.</li>
        </ul>

        Note that if this is a deregistration notification,
        there is no way to access the object representing the
        unregistered medium. It is supposed that the
        application will do required cleanup based on the
        @a mediumId value.

        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="mediumId" type="uuid" mod="string" dir="in">
        <desc>ID of the medium this event relates to.</desc>
      </param>
      <param name="mediumType" type="DeviceType" dir="in">
        <desc>Type of the medium this event relates to.</desc>
      </param>
      <param name="registered" type="boolean" dir="in">
        <desc>
          If @c true, the medium was registered, otherwise it was
          unregistered.
        </desc>
      </param>
    </method>

    <method name="onMachineRegistered">
      <desc>
        The given machine was registered or unregistered
        within this VirtualBox installation.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="registered" type="boolean" dir="in">
        <desc>
          If @c true, the machine was registered, otherwise it was
          unregistered.
        </desc>
      </param>
    </method>

    <method name="onSessionStateChange">
      <desc>
        The state of the session for the given machine was changed.
        <see>IMachine::sessionState</see>
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="state" type="SessionState" dir="in">
        <desc>New session state.</desc>
      </param>
    </method>

    <method name="onSnapshotTaken">
      <desc>
        A new snapshot of the machine has been taken.
        <see>ISnapshot</see>
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="snapshotId" type="uuid" mod="string" dir="in">
        <desc>ID of the new snapshot.</desc>
      </param>
    </method>

    <method name="onSnapshotDeleted">
      <desc>
        Snapshot of the given machine has been deleted.

        <note>
          This notification is delivered <b>after</b> the snapshot
          object has been uninitialized on the server (so that any
          attempt to call its methods will return an error).
        </note>

        <see>ISnapshot</see>

        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="snapshotId" type="uuid" mod="string" dir="in">
        <desc>
          ID of the deleted snapshot. @c null means the current machine
          state has been deleted (restored from the current snapshot).
        </desc>
      </param>
    </method>

    <method name="onSnapshotChange">
      <desc>
        Snapshot properties (name and/or description) have been changed.
        <see>ISnapshot</see>
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>ID of the machine this event relates to.</desc>
      </param>
      <param name="snapshotId" type="uuid" mod="string" dir="in">
        <desc>ID of the changed snapshot.</desc>
      </param>
    </method>

    <method name="onGuestPropertyChange">
      <desc>
        Notification when a guest property has changed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>
          ID of the machine this event relates to.
        </desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>
          The name of the property that has changed.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The new property value.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="in">
        <desc>
          The new property flags.
        </desc>
      </param>
    </method>

  </interface>

  <interface
    name="IDHCPServer" extends="$unknown"
    uuid="6cfe387c-74fb-4ca7-bff6-973bec8af7a3"
    wsmap="managed"
  >
    <desc>
      The IDHCPServer interface represents the vbox dhcp server configuration.

      To enumerate all the dhcp servers on the host, use the
      <link to="IVirtualBox::DHCPServers"/> attribute.
    </desc>

    <attribute name="enabled" type="boolean">
      <desc>
        specifies if the dhcp server is enabled
      </desc>
    </attribute>

    <attribute name="IPAddress" type="wstring" readonly="yes">
      <desc>
        specifies server IP
      </desc>
    </attribute>

    <attribute name="networkMask" type="wstring" readonly="yes">
      <desc>
        specifies server network mask
      </desc>
    </attribute>

    <attribute name="networkName" type="wstring" readonly="yes">
      <desc>
        specifies internal network name the server is used for
      </desc>
    </attribute>

    <attribute name="lowerIP" type="wstring" readonly="yes">
      <desc>
        specifies from IP adrres in server address range
      </desc>
    </attribute>

    <attribute name="upperIP" type="wstring" readonly="yes">
      <desc>
        specifies to IP adrres in server address range
      </desc>
    </attribute>

    <method name="setConfiguration">
      <desc>
        configures the server
        <result name="E_INVALIDARG">
          invalid configuration supplied
        </result>
      </desc>
      <param name="IPAddress" type="wstring" dir="in">
        <desc>
          server IP address
        </desc>
      </param>
      <param name="networkMask" type="wstring" dir="in">
        <desc>
          server network mask
      </desc>
      </param>
      <param name="FromIPAddress" type="wstring" dir="in">
        <desc>
          server From IP address for address range
        </desc>
      </param>
      <param name="ToIPAddress" type="wstring" dir="in">
        <desc>
          server To IP address for address range
        </desc>
      </param>
    </method>

    <method name="start">
      <desc>
        Starts DHCP server process.
        <result name="E_FAIL">
          Failed to start the process.
        </result>
      </desc>
      <param name="networkName" type="wstring" dir="in">
        <desc>
          Name of internal network DHCP server should attach to.
        </desc>
      </param>
      <param name="trunkName" type="wstring" dir="in">
        <desc>
          Name of internal network trunk.
        </desc>
      </param>
      <param name="trunkType" type="wstring" dir="in">
        <desc>
          Type of internal network trunk.
        </desc>
      </param>
    </method>

    <method name="stop">
      <desc>
        Stops DHCP server process.
        <result name="E_FAIL">
          Failed to stop the process.
        </result>
      </desc>
    </method>
  </interface>

  <interface
    name="IVirtualBox" extends="$unknown"
    uuid="3f36e024-7fed-4f20-a02c-9158a82b44e6"
    wsmap="managed"
  >
    <desc>
      The IVirtualBox interface represents the main interface exposed by the
      product that provides virtual machine management.

      An instance of IVirtualBox is required for the product to do anything
      useful. Even though the interface does not expose this, internally,
      IVirtualBox is implemented as a singleton and actually lives in the
      process of the VirtualBox server (VBoxSVC.exe). This makes sure that
      IVirtualBox can track the state of all virtual machines on a particular
      host, regardless of which frontend started them.

      To enumerate all the virtual machines on the host, use the
      <link to="IVirtualBox::machines"/> attribute.
    </desc>

    <attribute name="version" type="wstring" readonly="yes">
      <desc>
        A string representing the version number of the product. The
        format is 3 integer numbers divided by dots (e.g. 1.0.1). The
        last number represents the build number and will frequently change.
      </desc>
    </attribute>

    <attribute name="revision" type="unsigned long" readonly="yes">
      <desc>
        The internal build revision number of the product.
      </desc>
    </attribute>

    <attribute name="packageType" type="wstring" readonly="yes">
      <desc>
        A string representing the package type of this product. The
        format is OS_ARCH_DIST where OS is either WINDOWS, LINUX,
        SOLARIS, DARWIN. ARCH is either 32BITS or 64BITS. DIST
        is either GENERIC, UBUNTU_606, UBUNTU_710, or something like
        this.
      </desc>
    </attribute>

    <attribute name="homeFolder" type="wstring" readonly="yes">
      <desc>
        Full path to the directory where the global settings file,
        <tt>VirtualBox.xml</tt>, is stored.

        In this version of VirtualBox, the value of this property is
        always <tt>&lt;user_dir&gt;/.VirtualBox</tt> (where
        <tt>&lt;user_dir&gt;</tt> is the path to the user directory,
        as determined by the host OS), and cannot be changed.

        This path is also used as the base to resolve relative paths in
        places where relative paths are allowed (unless otherwise
        expressly indicated).
      </desc>
    </attribute>

    <attribute name="settingsFilePath" type="wstring" readonly="yes">
      <desc>
        Full name of the global settings file.
        The value of this property corresponds to the value of
        <link to="#homeFolder"/> plus <tt>/VirtualBox.xml</tt>.
      </desc>
    </attribute>

    <attribute name="host" type="IHost" readonly="yes">
      <desc>Associated host object.</desc>
    </attribute>

    <attribute name="systemProperties" type="ISystemProperties" readonly="yes">
      <desc>Associated system information object.</desc>
    </attribute>

    <attribute name="machines" type="IMachine" readonly="yes" safearray="yes">
      <desc>
        Array of machine objects registered within this VirtualBox instance.
      </desc>
    </attribute>

    <attribute name="hardDisks" type="IMedium" readonly="yes" safearray="yes">
      <desc>
        Array of medium objects known to this VirtualBox installation.

        This array contains only base media. All differencing
        media of the given base medium can be enumerated using
        <link to="IMedium::children"/>.
      </desc>
    </attribute>

    <attribute name="DVDImages" type="IMedium" readonly="yes" safearray="yes">
      <desc>
        Array of CD/DVD image objects registered with this VirtualBox instance.
      </desc>
    </attribute>

    <attribute name="floppyImages" type="IMedium" readonly="yes" safearray="yes">
      <desc>
        Array of floppy image objects registered with this VirtualBox instance.
      </desc>
    </attribute>

    <attribute name="progressOperations" type="IProgress" readonly="yes" safearray="yes"/>

    <attribute name="guestOSTypes" type="IGuestOSType" readonly="yes" safearray="yes"/>

    <attribute name="sharedFolders" type="ISharedFolder" readonly="yes" safearray="yes">
      <desc>
        Collection of global shared folders. Global shared folders are
        available to all virtual machines.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.

        <note>
          In the current version of the product, global shared folders are not
          implemented and therefore this collection is always empty.
        </note>
      </desc>
    </attribute>

    <attribute name="performanceCollector" type="IPerformanceCollector" readonly="yes">
      <desc>
        Associated performance collector object.
      </desc>
    </attribute>

    <attribute name="DHCPServers" type="IDHCPServer" safearray="yes" readonly="yes">
      <desc>
        dhcp server settings.
      </desc>
    </attribute>

    <method name="createMachine">
      <desc>
        Creates a new virtual machine.

        The new machine is created unregistered, with the initial configuration
        set according to the specified guest OS type. A typical sequence of
        actions to create a new virtual machine is as follows:

        <ol>
          <li>
            Call this method to have a new machine created. The returned machine
            object will be "mutable" allowing to change any machine property.
          </li>

          <li>
            Configure the machine using the appropriate attributes and methods.
          </li>

          <li>
            Call <link to="IMachine::saveSettings" /> to write the settings
            to the machine's XML settings file. The configuration of the newly
            created machine will not be saved to disk until this method is
            called.
          </li>

          <li>
            Call <link to="#registerMachine" /> to add the machine to the list
            of machines known to VirtualBox.
          </li>
        </ol>

        You should specify valid name for the newly created machine when calling
        this method. See the <link to="IMachine::name"/> attribute description
        for more details about the machine name.

        The specified guest OS type identifier must match an ID of one of known
        guest OS types listed in the <link to="IVirtualBox::guestOSTypes"/>
        array.

        Every machine has a <i>settings file</i> that is used to store
        the machine configuration. This file is stored in a directory called the
        <i>machine settings subfolder</i>. Both the settings subfolder and file
        will have a name that corresponds to the name of the virtual machine.
        You can specify where to create the machine setting subfolder using the
        @a baseFolder argument. The base folder can be absolute (full path) or
        relative to the <link to="IVirtualBox::homeFolder">VirtualBox home
        directory</link>.

        If @a baseFolder is a @c null or empty string (which is recommended), the
        <link to="ISystemProperties::defaultMachineFolder">default machine
        settings folder</link> will be used as a base folder for the created
        machine. Otherwise the given base folder will be used. In either case,
        the full path to the resulting settings file has the following
        structure:
        <pre>
          &lt;base_folder&gt;/&lt;machine_name&gt;/&lt;machine_name&gt;.xml
        </pre>

        Note that if the resulting settings file already exists, this method
        will fail with <link to="VBOX_E_FILE_ERROR"/>.

        Optionally, you may specify an UUID of to assign to the created machine.
        However, this is not recommended and you should normally pass an empty
        (@c null) UUID to this method so that a new UUID will be automatically
        generated for every created machine. You can use UUID
        00000000-0000-0000-0000-000000000000 as @c null value.

        <note>
          There is no way to change the name of the settings file or
          subfolder of the created machine directly.
        </note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          @a osTypeId is invalid.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Resulting settings file name is invalid or the settings file already
          exists or could not be created due to an I/O error.
        </result>
        <result name="E_INVALIDARG">
          @a name is empty or @c null.
        </result>
      </desc>

      <param name="name" type="wstring" dir="in">
        <desc>Machine name.</desc>
      </param>
      <param name="osTypeId" type="wstring" dir="in">
        <desc>Guest OS Type ID.</desc>
      </param>
      <param name="baseFolder" type="wstring" dir="in">
        <desc>Base machine folder (optional).</desc>
      </param>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>Machine UUID (optional).</desc>
      </param>
      <param name="override" type="boolean" dir="in">
        <desc>Create the VM even if there are conflicting files.</desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Created machine object.</desc>
      </param>
    </method>

    <method name="createLegacyMachine">
      <desc>
        Creates a new virtual machine in "legacy" mode, using the specified
        settings file to store machine settings.

        As opposed to machines created by <link to="#createMachine"/>,
        the settings file of the machine created in "legacy" mode is not
        automatically renamed when the machine name is changed -- it will always
        remain the same as specified in this method call.

        The specified settings file name can be absolute (full path) or relative
        to the <link to="IVirtualBox::homeFolder">VirtualBox home
        directory</link>. If the file name doesn't contain an extension, the
        default extension (.xml) will be appended.

        Note that the configuration of the newly created machine is not
        saved to disk (and therefore no settings file is created)
        until <link to="IMachine::saveSettings"/> is called. If the
        specified settings file already exists, this method
        will fail with <link to="VBOX_E_FILE_ERROR"/>.

        See <link to="#createMachine"/> for more information.

        @deprecated This method may be removed later. Use <link
        to="IVirtualBox::createMachine"/> instead.

        <note>
          There is no way to change the name of the settings file
          of the machine created in "legacy" mode.
        </note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          @a osTypeId is invalid.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          @a settingsFile is invalid or the settings file already exists or
          could not be created due to an I/O error.
        </result>
        <result name="E_INVALIDARG">
          @a name or @a settingsFile is empty or @c null.
        </result>
      </desc>

      <param name="name" type="wstring" dir="in">
        <desc>Machine name.</desc>
      </param>
      <param name="osTypeId" type="wstring" dir="in">
        <desc>Machine OS Type ID.</desc>
      </param>
      <param name="settingsFile" type="wstring" dir="in">
        <desc>Name of the machine settings file.</desc>
      </param>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>Machine UUID (optional).</desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Created machine object.</desc>
      </param>
    </method>

    <method name="openMachine">
      <desc>
        Opens a virtual machine from the existing settings file.
        The opened machine remains unregistered until you call
        <link to="#registerMachine"/>.

        The specified settings file name can be absolute
        (full path) or relative to the <link to="IVirtualBox::homeFolder">
          VirtualBox home directory</link>. This file must exist
        and must be a valid machine settings file whose contents
        will be used to construct the machine object.

        @deprecated Will be removed soon.
        <result name="VBOX_E_FILE_ERROR">
          Settings file name invalid, not found or sharing violation.
        </result>
      </desc>
      <param name="settingsFile" type="wstring" dir="in">
        <desc>
          Name of the machine settings file.
        </desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Opened machine object.</desc>
      </param>
      <note>
        <link to="IMachine::settingsModified"/> will return
        @c false for the created machine, until any of machine settings
        are changed.
      </note>
    </method>

    <method name="registerMachine">
      <desc>

        Registers the machine previously created using
        <link to="#createMachine"/> or opened using
        <link to="#openMachine"/> within this VirtualBox installation. After
        successful method invocation, the
        <link to="IVirtualBoxCallback::onMachineRegistered"/> signal is sent
        to all registered callbacks.

        <note>
          This method implicitly calls <link to="IMachine::saveSettings"/>
          to save all current machine settings before registering it.
        </note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching virtual machine found.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Virtual machine was not created within this VirtualBox instance.
        </result>

      </desc>
      <param name="machine" type="IMachine" dir="in"/>
    </method>

    <method name="getMachine">
      <desc>
        Attempts to find a virtual machine given its UUID.
        To look up a machine by name, use <link to="IVirtualBox::findMachine" />
        instead.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Could not find registered machine matching @a id.
        </result>

      </desc>
      <param name="id" type="uuid" mod="string" dir="in"/>
      <param name="machine" type="IMachine" dir="return"/>
    </method>

    <method name="findMachine">
      <desc>
        Attempts to find a virtual machine given its name.
        To look up a machine by UUID, use <link to="IVirtualBox::getMachine" />
        instead.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Could not find registered machine matching @a name.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="machine" type="IMachine" dir="return"/>
    </method>

    <method name="unregisterMachine">
      <desc>

        Unregisters the machine previously registered using
        <link to="#registerMachine"/>. After successful method invocation, the
        <link to="IVirtualBoxCallback::onMachineRegistered"/> signal is sent
        to all registered callbacks.

        <note>
          The specified machine must not be in the Saved state, have an open
          (or a spawning) direct session associated with it, have snapshots or
          have any medium attached.
        </note>

        <note>
          This method implicitly calls <link to="IMachine::saveSettings"/> to
          save all current machine settings before unregistering it.
        </note>

        <note>
          If the given machine is inaccessible (see
          <link to="IMachine::accessible"/>), it will be unregistered and
          fully uninitialized right afterwards. As a result, the returned
          machine object will be unusable and an attempt to call
          <b>any</b> method will return the "Object not ready" error.
        </note>

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Could not find registered machine matching @a id.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Machine is in Saved state.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Machine has snapshot or open session or medium attached.
        </result>

      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the machine to unregister.</desc>
      </param>
      <param name="machine" type="IMachine" dir="return">
        <desc>Unregistered machine object.</desc>
      </param>
    </method>

    <method name="createAppliance">
      <desc>
        Creates a new appliance object, which represents an appliance in the Open Virtual Machine
        Format (OVF). This can then be used to import an OVF appliance into VirtualBox or to export
        machines as an OVF appliance; see the documentation for <link to="IAppliance" /> for details.
      </desc>
      <param name="appliance" type="IAppliance" dir="return">
        <desc>New appliance.</desc>
      </param>
    </method>

    <method name="createHardDisk">
      <desc>
        Creates a new base medium object that will use the given storage
        format and location for medium data.

        Note that the actual storage unit is not created by this method. In
        order to do it, and before you are able to attach the created medium
        to virtual machines, you must call one of the following methods to
        allocate a format-specific storage unit at the specified location:
        <ul>
          <li><link to="IMedium::createBaseStorage"/></li>
          <li><link to="IMedium::createDiffStorage"/></li>
        </ul>

        Some medium attributes, such as <link to="IMedium::id"/>, may
        remain uninitialized until the medium storage unit is successfully
        created by one of the above methods.

        After the storage unit is successfully created, the medium gets
        remembered by this VirtualBox installation and will be accessible
        through <link to="#getHardDisk"/> and <link to="#findHardDisk"/>
        methods. Remembered base medium are also returned as part of
        the <link to="#hardDisks"/> array. See IMedium for more details.

        The list of all storage formats supported by this VirtualBox
        installation can be obtained using
        <link to="ISystemProperties::mediumFormats"/>. If the @a format
        attribute is empty or @c null then the default storage format
        specified by <link to="ISystemProperties::defaultHardDiskFormat"/> will
        be used for creating a storage unit of the medium.

        Note that the format of the location string is storage format specific.
        See <link to="IMedium::location"/>, IMedium and
        <link to="ISystemProperties::defaultHardDiskFolder"/> for more details.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          @a format identifier is invalid. See
          <link to="ISystemProperties::mediumFormats"/>.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          @a location is a not valid file name (for file-based formats only).
        </result>
      </desc>
      <param name="format" type="wstring" dir="in">
        <desc>
          Identifier of the storage format to use for the new medium.
        </desc>
      </param>
      <param name="location" type="wstring" dir="in">
        <desc>
          Location of the storage unit for the new medium.
        </desc>
      </param>
      <param name="medium" type="IMedium" dir="return">
        <desc>Created medium object.</desc>
      </param>
    </method>

    <method name="openHardDisk">
      <desc>
        Opens a medium from an existing location, optionally replacing
        the image UUID and/or parent UUID.

        After the medium is successfully opened by this method, it gets
        remembered by (known to) this VirtualBox installation and will be
        accessible through <link to="#getHardDisk"/> and
        <link to="#findHardDisk"/> methods. Remembered base media
        are also returned as part of the <link to="#hardDisks"/> array and can
        be attached to virtual machines. See IMedium for more details.

        If a differencing medium is to be opened by this method, the
        operation will succeed only if its parent medium and all ancestors,
        if any, are already known to this VirtualBox installation (for example,
        were opened by this method before).

        This method tries to guess the storage format of the specified medium
        by reading medium data at the specified location.

        If @a accessMode is ReadWrite (which it should be), the image is opened
        for read/write access and must have according permissions, as VirtualBox
        may actually write status information into the disk's metadata sections.

        Note that write access is required for all typical image usage in VirtualBox,
        since VirtualBox may need to write metadata such as a UUID into the image.
        The only exception is opening a source image temporarily for copying and
        cloning when the image will quickly be closed again.

        Note that the format of the location string is storage format specific.
        See <link to="IMedium::location"/>, IMedium and
        <link to="ISystemProperties::defaultHardDiskFolder"/> for more details.

        <result name="VBOX_E_FILE_ERROR">
          Invalid medium storage file location or could not find the medium
          at the specified location.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not get medium storage format.
        </result>
        <result name="E_INVALIDARG">
          Invalid medium storage format.
        </result>

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>
          Location of the storage unit that contains medium data in one of
          the supported storage formats.
        </desc>
      </param>
      <param name="accessMode" type="AccessMode" dir="in">
          <desc>
              Determines whether to open the image in read/write or read-only mode.
          </desc>
      </param>
      <param name="setImageId" type="boolean" dir="in">
          <desc>
              Select whether a new image UUID is set or not.
          </desc>
      </param>
      <param name="imageId" type="uuid" mod="string" dir="in">
          <desc>
              New UUID for the image. If an empty string is passed, then a new
              UUID is automatically created. Specifying a zero UUIDs is not valid.
          </desc>
      </param>
      <param name="setParentId" type="boolean" dir="in">
          <desc>
              Select whether a new parent UUID is set or not.
          </desc>
      </param>
      <param name="parentId" type="uuid" mod="string" dir="in">
          <desc>
              New parent UUID for the image. If an empty string is passed, then a
              new UUID is automatically created, provided @a setParentId is
              @c true. A zero UUID is valid.
          </desc>
      </param>
      <param name="medium" type="IMedium" dir="return">
        <desc>Opened medium object.</desc>
      </param>
    </method>

    <method name="getHardDisk" const="yes">
      <desc>
        Returns a medium with the given UUID.

        The medium with the given UUID must be known to this VirtualBox
        installation, i.e. it must be previously created by
        <link to="#createHardDisk"/> or opened by <link
        to="#openHardDisk"/>, or attached to some known virtual machine.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No medium object matching @a id found.
        </result>

      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the medium to look for.</desc>
      </param>
      <param name="medium" type="IMedium" dir="return">
        <desc>Found medium object.</desc>
      </param>
    </method>

    <method name="findHardDisk">
      <desc>
        Returns a medium that uses the given location to store medium data.

        The given medium must be known to this VirtualBox installation, i.e.
        it must be previously created by
        <link to="#createHardDisk"/> or opened by <link
        to="#openHardDisk"/>, or attached to some known virtual machine.

        The search is done by comparing the value of the @a location argument to
        the <link to="IMedium::location"/> attribute of each known medium.

        For locations represented by file names in the host's file system, the
        requested location can be a path relative to the
        <link to="IVirtualBox::homeFolder">VirtualBox home folder</link>. If
        only a file name without any path is given, the
        <link to="ISystemProperties::defaultHardDiskFolder"> default medium
        folder</link> will be prepended to the file name before searching. Note
        that on case sensitive file systems, a case sensitive comparison is
        performed, otherwise the case of symbols in the file path is ignored.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No medium object matching @a location found.
        </result>

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>Location string to search for.</desc>
      </param>
      <param name="medium" type="IMedium" dir="return">
        <desc>Found medium object.</desc>
      </param>
    </method>

    <method name="openDVDImage">
      <desc>
        Opens a CD/DVD image contained in the specified file of the supported
        format and assigns it the given UUID.

        After the image is successfully opened by this method, it gets
        remembered by (known to) this VirtualBox installation and will be
        accessible through <link to="#getDVDImage"/> and
        <link to="#findDVDImage"/> methods. Remembered images are also
        returned as part of the <link to="#DVDImages"/> array and can be mounted
        to virtual machines. See IMedium for more details.

        See <link to="IMedium::location"/> to get more details about the format
        of the location string.

        <note>
          Currently only ISO 9960 CD/DVD images are supported by VirtualBox.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Invalid CD/DVD image file location or could not find the CD/DVD
          image at the specified location.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          CD/DVD image already exists in the media registry.
        </result>

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>
          Full path to the file that contains a valid CD/DVD image.
        </desc>
      </param>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>
          UUID to assign to the given image within this VirtualBox installation.
          If an empty (@c null) UUID is specified, the system will randomly
          generate a new UUID.
        </desc>
      </param>
      <param name="image" type="IMedium" dir="return">
        <desc>Opened CD/DVD image object.</desc>
      </param>
    </method>

    <method name="getDVDImage">
      <desc>
        Returns a CD/DVD image with the given UUID.

        The image with the given UUID must be known to this VirtualBox
        installation, i.e. it must be previously opened by <link
        to="#openDVDImage"/>, or mounted to some known virtual machine.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching DVD image found in the media registry.
        </result>

      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the image to look for.</desc>
      </param>
      <param name="image" type="IMedium" dir="return">
        <desc>Found CD/DVD image object.</desc>
      </param>
    </method>

    <method name="findDVDImage">
      <desc>
        Returns a CD/DVD image with the given image location.

        The image with the given UUID must be known to this VirtualBox
        installation, i.e. it must be previously opened by <link
        to="#openDVDImage"/>, or mounted to some known virtual machine.

        The search is done by comparing the value of the @a location argument to
        the <link to="IMedium::location"/> attribute of each known CD/DVD image.

        The requested location can be a path relative to the
        <link to="IVirtualBox::homeFolder">VirtualBox home folder</link>. If
        only a file name without any path is given, the
        <link to="ISystemProperties::defaultHardDiskFolder"> default hard disk
        folder</link> will be prepended to the file name before searching. Note
        that on case sensitive file systems, a case sensitive comparison is
        performed, otherwise the case in the file path is ignored.

        <result name="VBOX_E_FILE_ERROR">
          Invalid image file location.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching DVD image found in the media registry.
        </result>

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>CD/DVD image file path to look for.</desc>
      </param>
      <param name="image" type="IMedium" dir="return">
        <desc>Found CD/DVD image object.</desc>
      </param>
    </method>

    <method name="openFloppyImage">
      <desc>
        Opens a floppy image contained in the specified file of the supported
        format and assigns it the given UUID.

        After the image is successfully opened by this method, it gets
        remembered by (known to) this VirtualBox installation and will be
        accessible through <link to="#getFloppyImage"/> and
        <link to="#findFloppyImage"/> methods. Remembered images are also
        returned as part of the <link to="#floppyImages"/> array and can be
        mounted to virtual machines. See IMedium for more details.

        See <link to="IMedium::location"/> to get more details about the format
        of the location string.

        <result name="VBOX_E_FILE_ERROR">
          Invalid floppy image file location or could not find the floppy
          image at the specified location.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Floppy image already exists in the media registry.
        </result>

        <note>
          Currently, only raw floppy images are supported by VirtualBox.
        </note>
      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>
          Full path to the file that contains a valid floppy image.
        </desc>
      </param>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>
          UUID to assign to the given image file within this VirtualBox
          installation. If an empty (@c null) UUID is specified, the system will
          randomly generate a new UUID.
        </desc>
      </param>
      <param name="image" type="IMedium" dir="return">
        <desc>Opened floppy image object.</desc>
      </param>
    </method>

    <method name="getFloppyImage">
      <desc>
        Returns a floppy image with the given UUID.

        The image with the given UUID must be known to this VirtualBox
        installation, i.e. it must be previously opened by <link
        to="#openFloppyImage"/>, or mounted to some known virtual machine.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching floppy image found in the media registry.
        </result>

      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the image to look for.</desc>
      </param>
      <param name="image" type="IMedium" dir="return">
        <desc>Found floppy image object.</desc>
      </param>
    </method>

    <method name="findFloppyImage">
      <desc>
        Returns a floppy image with the given image location.

        The image with the given UUID must be known to this VirtualBox
        installation, i.e. it must be previously opened by <link
        to="#openFloppyImage"/>, or mounted to some known virtual machine.

        The search is done by comparing the value of the @a location argument to
        the <link to="IMedium::location"/> attribute of each known floppy image.

        The requested location can be a path relative to the
        <link to="IVirtualBox::homeFolder">VirtualBox home folder</link>. If
        only a file name without any path is given, the
        <link to="ISystemProperties::defaultHardDiskFolder"> default hard disk
        folder</link> will be prepended to the file name before searching. Note
        that on case sensitive file systems, a case sensitive comparison is
        performed, otherwise the case of symbols in the file path is ignored.

        <result name="VBOX_E_FILE_ERROR">
          Invalid image file location.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching floppy image found in the media registry.
        </result>

      </desc>
      <param name="location" type="wstring" dir="in">
        <desc>Floppy image file path to look for.</desc>
      </param>
      <param name="image" type="IMedium" dir="return">
        <desc>Found floppy image object.</desc>
      </param>
    </method>

    <method name="getGuestOSType">
      <desc>
        Returns an object describing the specified guest OS type.

        The requested guest OS type is specified using a string which is a
        mnemonic identifier of the guest operating system, such as
        <tt>"win31"</tt> or <tt>"ubuntu"</tt>. The guest OS type ID of a
        particular virtual machine can be read or set using the
        <link to="IMachine::OSTypeId"/> attribute.

        The <link to="IVirtualBox::guestOSTypes"/> collection contains all
        available guest OS type objects. Each object has an
        <link to="IGuestOSType::id"/> attribute which contains an identifier of
        the guest OS this object describes.

        <result name="E_INVALIDARG">
          @a id is not a valid Guest OS type.
        </result>

      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>Guest OS type ID string.</desc>
      </param>
      <param name="type" type="IGuestOSType" dir="return">
        <desc>Guest OS type object.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a new global shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.
        <note>
          In the current implementation, this operation is not
          implemented.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes the global shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.
        <note>
          In the current implementation, this operation is not
          implemented.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="getExtraDataKeys">
      <desc>
        Returns an array representing the global extra data keys which currently
        have values defined.
      </desc>
      <param name="value" type="wstring" dir="return" safearray="yes">
        <desc>Array of extra data keys.</desc>
      </param>
    </method>

    <method name="getExtraData">
      <desc>
        Returns associated global extra data.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Value of the requested data key.</desc>
      </param>
    </method>

    <method name="setExtraData">
      <desc>
        Sets associated global extra data.

        If you pass @c null or empty string as a key @a value, the given @a key
        will be deleted.

        <note>
          Before performing the actual data change, this method will ask all
          registered callbacks using the
          <link to="IVirtualBoxCallback::onExtraDataCanChange"/>
          notification for a permission. If one of the callbacks refuses the
          new value, the change will not be performed.
        </note>
        <note>
          On success, the
          <link to="IVirtualBoxCallback::onExtraDataChange"/> notification
          is called to inform all registered callbacks about a successful data
          change.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
        <result name="E_ACCESSDENIED">
          Modification request refused.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Value to assign to the key.</desc>
      </param>
    </method>

    <method name="openSession">
      <desc>
        Opens a new direct session with the given virtual machine.

        A direct session acts as a local lock on the given VM.
        There can be only one direct session open at a time for every
        virtual machine, protecting the VM from being manipulated by
        conflicting actions from different processes. Only after a
        direct session has been opened, one can change all VM settings
        and execute the VM in the process space of the session object.

        Sessions therefore can be compared to mutex semaphores that
        lock a given VM for modification and execution.
        See <link to="ISession">ISession</link> for details.

        <note>Unless you are writing a new VM frontend, you will not
        want to execute a VM in the current process. To spawn a new
        process that executes a VM, use
        <link to="IVirtualBox::openRemoteSession" />
        instead.</note>

        Upon successful return, the session object can be used to
        get access to the machine and to the VM console.

        In VirtualBox terminology, the machine becomes "mutable" after
        a session has been opened. Note that the "mutable" machine
        object, on which you may invoke IMachine methods to change its
        settings, will be a different object from the immutable IMachine
        objects returned by various IVirtualBox methods. To obtain a
        mutable IMachine object (upon which you can invoke settings methods),
        use the <link to="ISession::machine" /> attribute.

        One must always call <link to="ISession::close" /> to release the
        lock on the machine, or the machine's state will eventually be
        set to "Aborted".

        In other words, to change settings on a machine, the following
        sequence is typically performed:

        <ol>
        <li>Call this method (openSession) to have a machine locked for
        the current session.</li>

        <li>Obtain a mutable IMachine object from <link to="ISession::machine" />.</li>

        <li>Change the settings of the machine.</li>

        <li>Call <link to="IMachine::saveSettings" />.</li>

        <li>Close the session by calling <link to="ISession::close"/>.</li>
        </ol>

        <result name="E_UNEXPECTED">
          Virtual machine not registered.
        </result>
        <result name="E_ACCESSDENIED">
          Process not started by OpenRemoteSession.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No matching virtual machine found.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session already open or being opened.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Failed to assign machine to session.
        </result>

      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Session object that will represent the opened session after
          successful method invocation. This object must not represent
          the already open session.
          <note>
            This session will be automatically closed if the
            VirtualBox server is terminated for some reason.
          </note>
        </desc>
      </param>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>ID of the virtual machine to open a session with.</desc>
      </param>
    </method>

    <method name="openRemoteSession">
      <desc>
        Spawns a new process that executes a virtual machine (called a
        "remote session").

        Opening a remote session causes the VirtualBox server to start a new
        process that opens a direct session with the given VM. As a result, the
        VM is locked by that direct session in the new process, preventing
        conflicting changes from other processes. Since sessions act as locks
        that prevent conflicting changes, one cannot open a remote session
        for a VM that already has another open session (direct or remote), or
        is currently in the process of opening one (see <link
          to="IMachine::sessionState"/>).

        While the remote session still provides some level of control over the
        VM execution to the caller (using the <link to="IConsole" /> interface),
        not all VM settings are available for modification within the remote
        session context.

        This operation can take some time (a new VM is started in a new process,
        for which memory and other resources need to be set up). Because of this,
        an <link to="IProgress" /> is returned to allow the caller to wait for this
        asynchronous operation to be completed. Until then, the remote session
        object remains in the closed state, and accessing the machine or its
        console through it is invalid. It is recommended to use
        <link to="IProgress::waitForCompletion" /> or similar calls to wait for
        completion. Completion is signalled when the VM is powered on. Error
        messages etc. can be queried via the progress object, if available.

        As with all <link to="ISession" /> objects, it is recommended to call
        <link to="ISession::close" /> on the local session object once openRemoteSession()
        has been called. However, the session's state (see <link to="ISession::state" />)
        will not return to "Closed" until the remote session has also closed (i.e.
        until the VM is no longer running). In that case, however, the state of
        the session will automatically change back to "Closed".

        Currently supported session types (values of the @a type
        argument) are:
        <ul>
          <li><tt>"gui"</tt>: VirtualBox Qt GUI session</li>
          <li><tt>"vrdp"</tt>: VirtualBox VRDP Server session</li>
          <li><tt>"sdl"</tt>: VirtualBox SDL GUI session</li>
        </ul>

        The @a environment argument is a string containing definitions of
        environment variables in the following format:
        @code
          NAME[=VALUE]\n
          NAME[=VALUE]\n
          ...
        @endcode
        where <tt>\\n</tt> is the new line character. These environment
        variables will be appended to the environment of the VirtualBox server
        process. If an environment variable exists both in the server process
        and in this list, the value from this list takes precedence over the
        server's variable. If the value of the environment variable is
        omitted, this variable will be removed from the resulting environment.
        If the environment string is @c null or empty, the server environment
        is inherited by the started process as is.

        The progress object will have at least 2 operation. The first operation
        covers the period up to the new VM process calls powerUp. The
        subsequent operations mirrors the <link to="IConsole::powerUp"/>
        progress object. Because <link to="IConsole::powerUp"/> may require
        some extra operation, the <link to="IProgress::operationCount"/> may
        change at the completion of operation1.

        For details on the teleportation progress operation, see
        <link to="IConsole::powerUp"/>.

        <see>openExistingSession</see>

        <result name="E_UNEXPECTED">
          Virtual machine not registered.
        </result>
        <result name="E_INVALIDARG">
          Invalid session type @a type.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No machine matching @a machineId found.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session already open or being opened.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Launching process for machine failed.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Failed to assign machine to session.
        </result>

      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Session object that will represent the opened remote session
          after successful method invocation (this object must not
          represent an already open session).
        </desc>
      </param>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>ID of the virtual machine to open a session with.</desc>
      </param>
      <param name="type" type="wstring" dir="in">
        <desc>
          Type of the remote session (case sensitive).
        </desc>
      </param>
      <param name="environment" type="wstring" dir="in">
        <desc>
          Environment to pass to the opened session.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="openExistingSession">
      <desc>
        Opens a new remote session with the virtual machine for
        which a direct session is already open.

        The remote session provides some level of control over the VM
        execution (using the IConsole interface) to the caller; however,
        within the remote session context, not all VM settings are available
        for modification.

        As opposed to <link to="#openRemoteSession"/>, the number of
        remote sessions opened this way is not limited by the API

        <note>
          It is an error to open a remote session with the machine that
          doesn't have an open direct session.
        </note>

        <result name="E_UNEXPECTED">
          Virtual machine not registered.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No machine matching @a machineId found.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session already open or being opened.
        </result>
        <result name="VBOX_E_INVALID_SESSION_STATE">
          Direct session state not Open.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Failed to get console object from direct session or assign
          machine to session.
        </result>

        <see>openRemoteSession</see>
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>
          Session object that will represent the open remote session
          after successful method invocation. This object must not
          represent an already open session.
          <note>
            This session will be automatically closed when the peer
            (direct) session dies or gets closed.
          </note>
        </desc>
      </param>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>ID of the virtual machine to open a session with.</desc>
      </param>
    </method>

    <method name="registerCallback">
      <desc>
        Registers a new global VirtualBox callback. The methods of the given
        callback object will be called by VirtualBox when an appropriate
        event occurs.

        <result name="E_INVALIDARG">
          A @c null callback cannot be registered.
        </result>

      </desc>
      <param name="callback" type="IVirtualBoxCallback" dir="in">
        <desc>Callback object to register.</desc>
      </param>
    </method>

    <method name="unregisterCallback">
      <desc>
        Unregisters the previously registered global VirtualBox callback.

        <result name="E_INVALIDARG">
          Specified @a callback not registered.
        </result>

      </desc>
      <param name="callback" type="IVirtualBoxCallback" dir="in">
        <desc>Callback object to unregister.</desc>
      </param>
    </method>

    <method name="waitForPropertyChange">
      <desc>
        Blocks the caller until any of the properties represented by the
        @a what argument changes the value or until the given timeout interval
        expires.

        The @a what argument is a comma separated list of property masks that
        describe properties the caller is interested in. The property mask is
        a string in the following format:

        <pre>
        [[group.]subgroup.]name
        </pre>

        where @c name is the property name and @c group, @c subgroup are zero
        or more property group specifiers. Each element (group or name) in
        the property mask may be either a Latin string or an asterisk symbol
        (@c "*") which is used to match any string for the given element. A
        property mask that doesn't contain asterisk symbols represents a
        single fully qualified property name.

        Groups in the fully qualified property name go from more generic (the
        left-most part) to more specific (the right-most part). The first
        element is usually a name of the object the property belongs to.  The
        second element may be either a property name, or a child object name,
        or an index if the preceding element names an object which is one of
        many objects of the same type. This way, property names form a
        hierarchy of properties.  Here are some examples of property names:

        <table>
          <tr>
            <td><tt>VirtualBox.version</tt></td>
            <td><link to="IVirtualBox::version"/> property</td>
          </tr>
          <tr>
            <td><tt>Machine.&lt;UUID&gt;.name</tt></td>
            <td><link to="IMachine::name"/> property of the machine with the
            given UUID</td>
            </tr>
        </table>

        Most property names directly correspond to the properties of objects
        (components) provided by the VirtualBox library and may be used to
        track changes to these properties. However, there may be
        pseudo-property names that don't correspond to any existing object's
        property directly, as well as there may be object properties that
        don't have a corresponding property name that is understood by this
        method, and therefore changes to such properties cannot be
        tracked. See individual object's property descriptions to get a
        fully qualified property name that can be used with this method (if
        any).

        There is a special property mask @c "*" (i.e. a string consisting of a
        single asterisk symbol) that can be used to match all properties.
        Below are more examples of property masks:

        <table>
          <tr>
            <td><tt>VirtualBox.*</tt></td>
            <td>Track all properties of the VirtualBox object</td>
          </tr>
          <tr>
            <td><tt>Machine.*.name</tt></td>
            <td>Track changes to the <link to="IMachine::name"/> property of
            all registered virtual machines</td>
          </tr>
        </table>

        <note>
          This function is not implemented in the current version of the
          product.
        </note>
      </desc>
      <param name="what" type="wstring" dir="in">
        <desc>Comma separated list of property masks.</desc>
      </param>
      <param name="timeout" type="unsigned long" dir="in">
        <desc>
          Wait timeout in milliseconds.
          Specify -1 for an indefinite wait.
        </desc>
      </param>
      <param name="changed" type="wstring" dir="out">
        <desc>
          Comma separated list of properties that have been changed and caused
          this method to return to the caller.
        </desc>
      </param>
      <param name="values" type="wstring" dir="out">
        <desc>Reserved, not currently used.</desc>
      </param>
    </method>

    <!--method name="createDHCPServerForInterface">
      <desc>
        Creates a dhcp server settings to be used for the given interface
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="interface" type="IHostNetworkInterface" dir="in">
        <desc>Network Interface</desc>
      </param>
      <param name="server" type="IDHCPServer" dir="out">
        <desc>Dhcp server settings</desc>
      </param>
    </method-->

    <method name="createDHCPServer">
      <desc>
        Creates a dhcp server settings to be used for the given internal network name
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>server name</desc>
      </param>
      <param name="server" type="IDHCPServer" dir="return">
        <desc>Dhcp server settings</desc>
      </param>
    </method>

    <method name="findDHCPServerByNetworkName">
      <desc>
        Searches a dhcp server settings to be used for the given internal network name
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>server name</desc>
      </param>
      <param name="server" type="IDHCPServer" dir="return">
        <desc>Dhcp server settings</desc>
      </param>
    </method>

    <!--method name="findDHCPServerForInterface">
      <desc>
        Searches a dhcp server settings to be used for the given interface
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="interface" type="IHostNetworkInterface" dir="in">
        <desc>Network Interface</desc>
      </param>
      <param name="server" type="IDHCPServer" dir="out">
        <desc>Dhcp server settings</desc>
      </param>
    </method-->

    <method name="removeDHCPServer">
      <desc>
        Removes the dhcp server settings
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="server" type="IDHCPServer" dir="in">
        <desc>Dhcp server settings to be removed</desc>
      </param>
    </method>


    <method name="checkFirmwarePresent">
      <desc>
        Check if this VirtualBox installation has a firmware
        of the given type available, either system-wide or per-user.
        Optionally, this may return a hint where this firmware can be
        downloaded from.
      </desc>
      <param name="firmwareType" type="FirmwareType" dir="in">
        <desc>
          Type of firmware to check.
        </desc>
      </param>
      <param name="version" type="wstring" dir="in">
        <desc>Expected version number, usually empty string (presently ignored).</desc>
      </param>

      <param name="url" type="wstring" dir="out">
        <desc>
          Suggested URL to download this firmware from.
        </desc>
      </param>

      <param name="file" type="wstring" dir="out">
        <desc>
          Filename of firmware, only valid if result == TRUE.
        </desc>
      </param>

      <param name="result" type="boolean" dir="return">
        <desc>If firmware of this type and version is available.</desc>
      </param>
    </method>

  </interface>

  <!--
  // IVFSExplorer
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="VFSType"
    uuid="813999ba-b949-48a8-9230-aadc6285e2f2"
  >
    <desc>
      Virtual file systems supported by VFSExplorer.
    </desc>

    <const name="File" value="1" />
    <const name="Cloud" value="2" />
    <const name="S3" value="3" />
    <const name="WebDav" value="4" />
  </enum>

  <enum
    name="VFSFileType"
    uuid="714333cd-44e2-415f-a245-d378fa9b1242"
  >
    <desc>
      File types known by VFSExplorer.
    </desc>

    <const name="Unknown" value="1" />
    <const name="Fifo" value="2" />
    <const name="DevChar" value="3" />
    <const name="Directory" value="4" />
    <const name="DevBlock" value="5" />
    <const name="File" value="6" />
    <const name="SymLink" value="7" />
    <const name="Socket" value="8" />
    <const name="WhiteOut" value="9" />
  </enum>

  <interface
     name="IVFSExplorer" extends="$unknown"
     uuid="2bb864a1-02a3-4474-a1d4-fb5f23b742e1"
     wsmap="managed"
     >
    <desc>
      The VFSExplorer interface unifies access to different file system
      types. This includes local file systems as well remote file systems like
      S3. For a list of supported types see <link to="VFSType" />.
      An instance of this is returned by <link to="IAppliance::createVFSExplorer" />.
    </desc>

    <attribute name="path" type="wstring" readonly="yes">
      <desc>Returns the current path in the virtual file system.</desc>
    </attribute>

    <attribute name="type" type="VFSType" readonly="yes">
      <desc>Returns the file system type which is currently in use.</desc>
    </attribute>

    <method name="update">
      <desc>Updates the internal list of files/directories from the
      current directory level. Use <link to="#entryList" /> to get the full list
      after a call to this method.</desc>

      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="cd">
      <desc>Change the current directory level.</desc>

      <param name="aDir" type="wstring" dir="in">
        <desc>The name of the directory to go in.</desc>
      </param>

      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="cdUp">
      <desc>Go one directory upwards from the current directory level.</desc>

      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="entryList">
      <desc>Returns a list of files/directories after a call to <link
      to="#update" />. The user is responsible for keeping this internal
      list up do date.</desc>

      <param name="aNames" type="wstring" safearray="yes" dir="out">
        <desc>The list of names for the entries.</desc>
      </param>

      <param name="aTypes" type="unsigned long" safearray="yes" dir="out">
        <desc>The list of types for the entries.</desc>
      </param>
    </method>

    <method name="exists">
      <desc>Checks if the given file list exists in the current directory
      level.</desc>

      <param name="aNames" type="wstring" safearray="yes" dir="in">
        <desc>The names to check.</desc>
      </param>

      <param name="aExists" type="wstring" safearray="yes" dir="return">
        <desc>The names which exist.</desc>
      </param>
    </method>

    <method name="remove">
      <desc>Deletes the given files in the current directory level.</desc>

      <param name="aNames" type="wstring" safearray="yes" dir="in">
        <desc>The names to remove.</desc>
      </param>

      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

  </interface>

  <!--
  // IAppliance
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IAppliance" extends="$unknown"
     uuid="e3ba9ab9-ac2c-4266-8bd2-91c4bf721ceb"
     wsmap="managed"
     >
    <desc>
        Represents a platform-independent appliance in OVF format. An instance of this is returned
        by <link to="IVirtualBox::createAppliance" />, which can then be used to import and export
        virtual machines within an appliance with VirtualBox.

        The OVF standard suggests two different physical file formats:

        <ol>
            <li>If the appliance is distributed as a set of files, there must be at least one XML descriptor
                file that conforms to the OVF standard and carries an <tt>.ovf</tt> file extension. If
                this descriptor file references other files such as disk images, as OVF appliances typically
                do, those additional files must be in the same directory as the descriptor file.</li>

              <li>If the appliance is distributed as a single file, it must be in TAR format and have the
                <tt>.ova</tt> file extension. This TAR file must then contain at least the OVF descriptor
                files and optionally other files.

                At this time, VirtualBox does not not yet support the packed (TAR) variant; support will
                be added with a later version.</li>
        </ol>

        <b>Importing</b> an OVF appliance into VirtualBox as instances of
        <link to="IMachine" /> involves the following sequence of API calls:

        <ol>
          <li>Call <link to="IVirtualBox::createAppliance" />. This will create an empty IAppliance object.
          </li>

          <li>On the new object, call <link to="#read" /> with the full path of the OVF file you
              would like to import. So long as this file is syntactically valid, this will succeed
              and fill the appliance object with the parsed data from the OVF file.
          </li>

          <li>Next, call <link to="#interpret" />, which analyzes the OVF data and sets up the
              contents of the IAppliance attributes accordingly. These can be inspected by a
              VirtualBox front-end such as the GUI, and the suggestions can be displayed to the
              user. In particular, the <link to="#virtualSystemDescriptions" /> array contains
              instances of <link to="IVirtualSystemDescription" /> which represent the virtual
              systems (machines) in the OVF, which in turn describe the virtual hardware prescribed
              by the OVF (network and hardware adapters, virtual disk images, memory size and so on).
              The GUI can then give the user the option to confirm and/or change these suggestions.
          </li>

          <li>If desired, call <link to="IVirtualSystemDescription::setFinalValues" /> for each
              virtual system (machine) to override the suggestions made by the interpret() routine.
          </li>

          <li>Finally, call <link to="#importMachines" /> to  create virtual machines in
              VirtualBox as instances of <link to="IMachine" /> that match the information in the
              virtual system descriptions.
          </li>
        </ol>

        <b>Exporting</b> VirtualBox machines into an OVF appliance involves the following steps:

        <ol>
            <li>As with importing, first call <link to="IVirtualBox::createAppliance" /> to create
                an empty IAppliance object.
            </li>

            <li>For each machine you would like to export, call <link to="IMachine::export" />
                with the IAppliance object you just created. Each such call creates one instance of
                <link to="IVirtualSystemDescription" /> inside the appliance.
            </li>

            <li>If desired, call <link to="IVirtualSystemDescription::setFinalValues" /> for each
                virtual system (machine) to override the suggestions made by the export() routine.
            </li>

            <li>Finally, call <link to="#write" /> with a path specification to have the OVF
                file written.</li>
        </ol>

    </desc>

    <attribute name="path" type="wstring" readonly="yes">
      <desc>Path to the main file of the OVF appliance, which is either the <tt>.ovf</tt> or
          the <tt>.ova</tt> file passed to <link to="#read" /> (for import) or
          <link to="#write" /> (for export).
          This attribute is empty until one of these methods has been called.
      </desc>
    </attribute>

    <attribute name="disks" type="wstring" readonly="yes" safearray="yes">
      <desc>
        Array of virtual disk definitions. One such description exists for each
        disk definition in the OVF; each string array item represents one such piece of
        disk information, with the information fields separated by tab (\t) characters.

        The caller should be prepared for additional fields being appended to
        this string in future versions of VirtualBox and therefore check for
        the number of tabs in the strings returned.

        In the current version, the following eight fields are returned per string
        in the array:

        <ol>
            <li>Disk ID (unique string identifier given to disk)</li>

            <li>Capacity (unsigned integer indicating the maximum capacity of the disk)</li>

            <li>Populated size (optional unsigned integer indicating the current size of the
            disk; can be approximate; -1 if unspecified)</li>

            <li>Format (string identifying the disk format, typically
            "http://www.vmware.com/specifications/vmdk.html#sparse")</li>

            <li>Reference (where to find the disk image, typically a file name; if empty,
            then the disk should be created on import)</li>

            <li>Image size (optional unsigned integer indicating the size of the image,
            which need not necessarily be the same as the values specified above, since
            the image may be compressed or sparse; -1 if not specified)</li>

            <li>Chunk size (optional unsigned integer if the image is split into chunks;
            presently unsupported and always -1)</li>

            <li>Compression (optional string equalling "gzip" if the image is gzip-compressed)</li>
        </ol>
      </desc>
    </attribute>

    <attribute name="virtualSystemDescriptions" type="IVirtualSystemDescription" readonly="yes" safearray="yes">
      <desc> Array of virtual system descriptions. One such description is created
      for each virtual system (machine) found in the OVF.
      This array is empty until either <link to="#interpret" /> (for import) or <link to="IMachine::export" />
      (for export) has been called.
      </desc>
    </attribute>

    <method name="read">
      <desc>
        Reads an OVF file into the appliance object.

        This method succeeds if the OVF is syntactically valid and, by itself, without errors. The
        mere fact that this method returns successfully does not mean that VirtualBox supports all
        features requested by the appliance; this can only be examined after a call to <link to="#interpret" />.
      </desc>
      <param name="file" type="wstring" dir="in">
        <desc>
          Name of appliance file to open (either with an <tt>.ovf</tt> or <tt>.ova</tt> extension, depending
          on whether the appliance is distributed as a set of files or as a single file, respectively).
        </desc>
      </param>
      <param name="aProgress" type="IProgress" dir="return">
        <desc></desc>
      </param>
    </method>

    <method name="interpret">
      <desc>
        Interprets the OVF data that was read when the appliance was constructed. After
        calling this method, one can inspect the
        <link to="#virtualSystemDescriptions" /> array attribute, which will then contain
        one <link to="IVirtualSystemDescription" /> for each virtual machine found in
        the appliance.

        Calling this method is the second step of importing an appliance into VirtualBox;
        see <link to="IAppliance" /> for an overview.

        After calling this method, one should call <link to="#getWarnings" /> to find out
        if problems were encountered during the processing which might later lead to
        errors.
      </desc>
    </method>

    <method name="importMachines">
      <desc>
        Imports the appliance into VirtualBox by creating instances of <link to="IMachine" />
        and other interfaces that match the information contained in the appliance as
        closely as possible, as represented by the import instructions in the
        <link to="#virtualSystemDescriptions" /> array.

        Calling this method is the final step of importing an appliance into VirtualBox;
        see <link to="IAppliance" /> for an overview.

        Since importing the appliance will most probably involve copying and converting
        disk images, which can take a long time, this method operates asynchronously and
        returns an IProgress object to allow the caller to monitor the progress.
      </desc>

      <param name="aProgress" type="IProgress" dir="return">
        <desc></desc>
      </param>
    </method>

    <method name="createVFSExplorer">
      <desc>Returns a <link to="IVFSExplorer" /> object for the given URI.</desc>

      <param name="aUri" type="wstring" dir="in">
        <desc>The URI describing the file system to use.</desc>
      </param>

      <param name="aExplorer" type="IVFSExplorer" dir="return">
        <desc></desc>
      </param>
    </method>

    <method name="write">
      <desc>
          Writes the contents of the appliance exports into a new OVF file.

          Calling this method is the final step of exporting an appliance from VirtualBox;
          see <link to="IAppliance" /> for an overview.

          Since exporting the appliance will most probably involve copying and converting
          disk images, which can take a long time, this method operates asynchronously and
          returns an IProgress object to allow the caller to monitor the progress.
      </desc>
      <param name="format" type="wstring" dir="in">
        <desc>
            Output format, as a string. Currently supported formats are "ovf-0.9" and "ovf-1.0";
            future versions of VirtualBox may support additional formats.
        </desc>
      </param>
      <param name="path" type="wstring" dir="in">
          <desc>
              Name of appliance file to open (either with an <tt>.ovf</tt> or <tt>.ova</tt> extension, depending
              on whether the appliance is distributed as a set of files or as a single file, respectively).
          </desc>
      </param>
      <param name="aProgress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="getWarnings">
        <desc>Returns textual warnings which occured during execution of <link to="#interpret" />.</desc>

        <param name="aWarnings" type="wstring" dir="return" safearray="yes">
            <desc></desc>
        </param>
    </method>

  </interface>

  <enum
    name="VirtualSystemDescriptionType"
    uuid="c0f8f135-3a1d-417d-afa6-b38b95a91f90"
  >
    <desc>Used with <link to="IVirtualSystemDescription" /> to describe the type of
    a configuration value.</desc>

    <const name="Ignore" value="1" />
    <const name="OS" value="2" />
    <const name="Name" value="3" />
    <const name="Product" value="4" />
    <const name="Vendor" value="5" />
    <const name="Version" value="6" />
    <const name="ProductUrl" value="7" />
    <const name="VendorUrl" value="8" />
    <const name="Description" value="9" />
    <const name="License" value="10" />
    <const name="Miscellaneous" value="11" />
    <const name="CPU" value="12" />
    <const name="Memory" value="13" />
    <const name="HardDiskControllerIDE" value="14" />
    <const name="HardDiskControllerSATA" value="15" />
    <const name="HardDiskControllerSCSI" value="16" />
    <const name="HardDiskControllerSAS" value="17" />
    <const name="HardDiskImage" value="18" />
    <const name="Floppy" value="19" />
    <const name="CDROM" value="20" />
    <const name="NetworkAdapter" value="21" />
    <const name="USBController" value="22" />
    <const name="SoundCard" value="23" />

  </enum>

  <enum
    name="VirtualSystemDescriptionValueType"
    uuid="56d9403f-3425-4118-9919-36f2a9b8c77c"
  >
    <desc>Used with <link to="IVirtualSystemDescription::getValuesByType" /> to describe the value
    type to fetch.</desc>

    <const name="Reference" value="1" />
    <const name="Original" value="2" />
    <const name="Auto" value="3" />
    <const name="ExtraConfig" value="4" />

  </enum>

  <interface
     name="IVirtualSystemDescription" extends="$unknown"
     uuid="d7525e6c-531a-4c51-8e04-41235083a3d8"
     wsmap="managed"
     >

    <desc>Represents one virtual system (machine) in an appliance. This interface is used in
      the <link to="IAppliance::virtualSystemDescriptions" /> array. After
      <link to="IAppliance::interpret" /> has been called, that array contains information
      about how the virtual systems described in the OVF should best be imported into
      VirtualBox virtual machines. See <link to="IAppliance" /> for the steps required to
      import an OVF into VirtualBox.
    </desc>

    <attribute name="count" type="unsigned long" readonly="yes">
      <desc>Return the number of virtual system description entries.</desc>
    </attribute>

    <method name="getDescription">
      <desc>Returns information about the virtual system as arrays of instruction items. In each array, the
      items with the same indices correspond and jointly represent an import instruction for VirtualBox.

      The list below identifies the value sets that are possible depending on the
      <link to="VirtualSystemDescriptionType" /> enum value in the array item in @a aTypes[]. In each case,
      the array item with the same index in @a aOvfValues[] will contain the original value as contained
      in the OVF file (just for informational purposes), and the corresponding item in @a aVBoxValues[]
      will contain a suggested value to be used for VirtualBox. Depending on the description type,
      the @a aExtraConfigValues[] array item may also be used.

      <ul>
      <li>
        "OS": the guest operating system type. There must be exactly one such array item on import. The
        corresponding item in @a  aVBoxValues[] contains the suggested guest operating system for VirtualBox.
        This will be one of the values listed in <link to="IVirtualBox::guestOSTypes" />. The corresponding
        item in @a aOvfValues[] will contain a numerical value that described the operating system in the OVF.
      </li>
      <li>
        "Name": the name to give to the new virtual machine. There can be at most one such array item;
        if none is present on import, then an automatic name will be created from the operating system
        type. The correponding item im @a aOvfValues[] will contain the suggested virtual machine name
        from the OVF file, and @a aVBoxValues[] will contain a suggestion for a unique VirtualBox
        <link to="IMachine" /> name that does not exist yet.
      </li>
      <li>
          "Description": an arbitrary description.
      </li>
      <li>
          "License": the EULA section from the OVF, if present. It is the responsibility of the calling
          code to display such a license for agreement; the Main API does not enforce any such policy.
      </li>
      <li>
          Miscellaneous: reserved for future use.
      </li>
      <li>
        "CPU": the number of CPUs. There can be at most one such item, which will presently be ignored.
      </li>
      <li>
        "Memory": the amount of guest RAM, in bytes. There can be at most one such array item; if none
        is present on import, then VirtualBox will set a meaningful default based on the operating system
        type.
      </li>
      <li>
        "HardDiskControllerIDE": an IDE hard disk controller. There can be at most two such items.
        An optional value in @a aOvfValues[] and @a aVBoxValues[] can be "PIIX3" or "PIIX4" to specify
        the type of IDE controller; this corresponds to the ResourceSubType element which VirtualBox
        writes into the OVF.
        The matching item in the @a aRefs[] array will contain an integer that items of the "Harddisk"
        type can use to specify which hard disk controller a virtual disk should be connected to.
        Note that in OVF, an IDE controller has two channels, corresponding to "master" and "slave"
        in traditional terminology, whereas the IDE storage controller that VirtualBox supports in
        its virtual machines supports four channels (primary master, primary slave, secondary master,
        secondary slave) and thus maps to two IDE controllers in the OVF sense.
      </li>
      <li>
        "HardDiskControllerSATA": an SATA hard disk controller. There can be at most one such item. This
        has no value in @a aOvfValues[] or @a aVBoxValues[].
        The matching item in the @a aRefs[] array will be used as with IDE controllers (see above).
      </li>
      <li>
        "HardDiskControllerSCSI": a SCSI hard disk controller. There can be at most one such item.
        The items in @a aOvfValues[] and @a aVBoxValues[] will either be "LsiLogic", "BusLogic" or
        "LsiLogicSas". (Note that in OVF, the LsiLogicSas controller is treated as a SCSI controller
        whereas VirtualBox considers it a class of storage controllers of its own; see
        <link to="StorageControllerType" />).
        The matching item in the @a aRefs[] array will be used as with IDE controllers (see above).
      </li>
      <li>
        "HardDiskImage": a virtual hard disk, most probably as a reference to an image file. There can be an
        arbitrary number of these items, one for each virtual disk image that accompanies the OVF.

        The array item in @a aOvfValues[] will contain the file specification from the OVF file (without
        a path since the image file should be in the same location as the OVF file itself), whereas the
        item in @a aVBoxValues[] will contain a qualified path specification to where VirtualBox uses the
        hard disk image. This means that on import the image will be copied and converted from the
        "ovf" location to the "vbox" location; on export, this will be handled the other way round.
        On import, the target image will also be registered with VirtualBox.

        The matching item in the @a aExtraConfigValues[] array must contain a string of the following
        format: "controller=&lt;index&gt;;channel=&lt;c&gt;"
        In this string, &lt;index&gt; must be an integer specifying the hard disk controller to connect
        the image to. That number must be the index of an array item with one of the hard disk controller
        types (HardDiskControllerSCSI, HardDiskControllerSATA, HardDiskControllerIDE).
        In addition, &lt;c&gt; must specify the channel to use on that controller. For IDE controllers,
        this can be 0 or 1 for master or slave, respectively. For compatibility with VirtualBox versions
        before 3.2, the values 2 and 3 (for secondary master and secondary slave) are also supported, but
        no longer exported. For SATA and SCSI controllers, the channel can range from 0-29.
      </li>
      <li>
         "CDROM": a virtual CD-ROM drive. The matching item in @a aExtraConfigValue[] contains the same
         attachment information as with "HardDiskImage" items.
      </li>
      <li>
        "CDROM": a virtual floppy drive. The matching item in @a aExtraConfigValue[] contains the same
        attachment information as with "HardDiskImage" items.
      </li>
      <li>
        "NetworkAdapter": a network adapter. The array item in @a aVBoxValues[] will specify the hardware
        for the network adapter, whereas the array item in @a aExtraConfigValues[] will have a string
        of the "type=&lt;X&gt;" format, where &lt;X&gt; must be either "NAT" or "Bridged".
      </li>
      <li>
          "USBController": a USB controller. There can be at most one such item. If and only if such an
          item ispresent, USB support will be enabled for the new virtual machine.
      </li>
      <li>
          "SoundCard": a sound card. There can be at most one such item. If and only if such an item is
          present, sound support will be enabled for the new virtual machine. Note that the virtual
          machine in VirtualBox will always be presented with the standard VirtualBox soundcard, which
          may be different from the virtual soundcard expected by the appliance.
      </li>
      </ul>

      </desc>

      <param name="aTypes" type="VirtualSystemDescriptionType" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aRefs" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aOvfValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aVBoxValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aExtraConfigValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

    </method>

    <method name="getDescriptionByType">
      <desc>This is the same as <link to="#getDescription" /> except that you can specify which types
      should be returned.</desc>

      <param name="aType" type="VirtualSystemDescriptionType" dir="in">
        <desc></desc>
      </param>

      <param name="aTypes" type="VirtualSystemDescriptionType" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aRefs" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aOvfValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aVBoxValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

      <param name="aExtraConfigValues" type="wstring" dir="out" safearray="yes">
        <desc></desc>
      </param>

    </method>

    <method name="getValuesByType">
      <desc>This is the same as <link to="#getDescriptionByType" /> except that you can specify which
      value types should be returned. See <link to="VirtualSystemDescriptionValueType" /> for possible
      values.</desc>

      <param name="aType" type="VirtualSystemDescriptionType" dir="in">
        <desc></desc>
      </param>

      <param name="aWhich" type="VirtualSystemDescriptionValueType" dir="in">
        <desc></desc>
      </param>

      <param name="aValues" type="wstring" dir="return" safearray="yes">
        <desc></desc>
      </param>

    </method>

    <method name="setFinalValues">
      <desc>
        This method allows the appliance's user to change the configuration for the virtual
        system descriptions. For each array item returned from <link to="#getDescription" />,
        you must pass in one boolean value and one configuration value.

        Each item in the boolean array determines whether the particular configuration item
        should be enabled.
        You can only disable items of the types HardDiskControllerIDE, HardDiskControllerSATA,
        HardDiskControllerSCSI, HardDiskImage, CDROM, Floppy, NetworkAdapter, USBController
        and SoundCard.

        For the "vbox" and "extra configuration" values, if you pass in the same arrays
        as returned in the aVBoxValues and aExtraConfigValues arrays from getDescription(),
        the configuration remains unchanged. Please see the documentation for getDescription()
        for valid configuration values for the individual array item types. If the
        corresponding item in the aEnabled array is @c false, the configuration value is ignored.
      </desc>

      <param name="aEnabled" type="boolean" dir="in" safearray="yes">
        <desc></desc>
      </param>

      <param name="aVBoxValues" type="wstring" dir="in" safearray="yes">
        <desc></desc>
      </param>

      <param name="aExtraConfigValues" type="wstring" dir="in" safearray="yes">
        <desc></desc>
      </param>
    </method>

    <method name="addDescription">
      <desc>
      This method adds an additional description entry to the stack of already
      available descriptions for this virtual system. This is handy for writing
      values which aren't directly supported by VirtualBox. One example would
      be the License type of <link to="VirtualSystemDescriptionType" />.
      </desc>

      <param name="aType" type="VirtualSystemDescriptionType" dir="in">
        <desc></desc>
      </param>

      <param name="aVBoxValue" type="wstring" dir="in">
        <desc></desc>
      </param>

      <param name="aExtraConfigValue" type="wstring" dir="in">
        <desc></desc>
      </param>
    </method>
  </interface>


  <!--
  // IMachine
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IInternalMachineControl" extends="$unknown"
     uuid="26604a54-8628-491b-a0ea-e1392a16d13b"
     internal="yes"
     wsmap="suppress"
     >
    <method name="setRemoveSavedState">
      <desc>
        Updates the flag whether saved state is removed on a machine state
        change from Saved to PoweredOff.
      </desc>
      <param name="aRemove" type="boolean" dir="in"/>
    </method>

    <method name="updateState">
      <desc>
        Updates the VM state.
        <note>
          This operation will also update the settings file with
          the correct information about the saved state file
          and delete this file from disk when appropriate.
        </note>
      </desc>
      <param name="state" type="MachineState" dir="in"/>
    </method>

    <method name="getIPCId">
      <param name="id" type="wstring" dir="return"/>
    </method>

    <method name="beginPowerUp">
      <desc>
        Tells VBoxSVC that <link to="IConsole::powerUp"/> is under ways and
	gives it the progress object that should be part of any pending
	<link to="IVirtualBox::openRemoteSession"/> operations.  The progress
	object may be called back to reflect an early cancelation, so some care
	have to be taken with respect to any cancelation callbacks. The console
	object will call <link to="IInternalMachineControl::endPowerUp"/>
	to signal the completion of the progress object.
      </desc>
      <param name="progress" type="IProgress" dir="in"/>
    </method>

    <method name="endPowerUp">
      <desc>
        Tells VBoxSVC that <link to="IConsole::powerUp"/> has completed.
	This method may query status information from the progress object it
	received in <link to="IInternalMachineControl::beginPowerUp"/> and copy
	it over to any in progress <link to="IVirtualBox::openRemoteSession"/>
	call in order to complete that progress object.
      </desc>
      <param name="result" type="long" dir="in"/>
    </method>

    <method name="runUSBDeviceFilters">
      <desc>
        Asks the server to run USB devices filters of the associated
        machine against the given USB device and tell if there is
        a match.
        <note>
          Intended to be used only for remote USB devices. Local
          ones don't require to call this method (this is done
          implicitly by the Host and USBProxyService).
        </note>
      </desc>
      <param name="device" type="IUSBDevice" dir="in"/>
      <param name="matched" type="boolean" dir="out"/>
      <param name="maskedInterfaces" type="unsigned long" dir="out"/>
    </method>

    <method name="captureUSBDevice">
      <desc>
        Requests a capture of the given host USB device.
        When the request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceAttach"/>
        notification.
      </desc>
      <param name="id" type="uuid" mod="string" dir="in"/>
    </method>

    <method name="detachUSBDevice">
      <desc>
        Notification that a VM is going to detach (@a done = @c false) or has
        already detached (@a done = @c true) the given USB device.
        When the @a done = @c true request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceDetach"/>
        notification.
        <note>
          In the @a done = @c true case, the server must run its own filters
          and filters of all VMs but this one on the detached device
          as if it were just attached to the host computer.
        </note>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in"/>
      <param name="done" type="boolean" dir="in"/>
    </method>

    <method name="autoCaptureUSBDevices">
      <desc>
        Requests a capture all matching USB devices attached to the host.
        When the request is completed, the VM process will
        get a <link to="IInternalSessionControl::onUSBDeviceAttach"/>
        notification per every captured device.
      </desc>
    </method>

    <method name="detachAllUSBDevices">
      <desc>
        Notification that a VM that is being powered down. The done
        parameter indicates whether which stage of the power down
        we're at. When @a done = @c false the VM is announcing its
        intentions, while when @a done = @c true the VM is reporting
        what it has done.
        <note>
          In the @a done = @c true case, the server must run its own filters
          and filters of all VMs but this one on all detach devices as
          if they were just attached to the host computer.
        </note>
      </desc>
      <param name="done" type="boolean" dir="in"/>
    </method>

    <method name="onSessionEnd">
      <desc>
        Triggered by the given session object when the session is about
        to close normally.
      </desc>
      <param name="session" type="ISession" dir="in">
        <desc>Session that is being closed</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Used to wait until the corresponding machine is actually
          dissociated from the given session on the server.
          Returned only when this session is a direct one.
        </desc>
      </param>
    </method>

    <method name="beginSavingState">
      <desc>
        Called by the VM process to inform the server it wants to
        save the current state and stop the VM execution.
      </desc>
      <param name="progress" type="IProgress" dir="in">
        <desc>
          Progress object created by the VM process to wait until
          the state is saved.
        </desc>
      </param>
      <param name="stateFilePath" type="wstring" dir="out">
        <desc>
          File path the VM process must save the execution state to.
        </desc>
      </param>
    </method>

    <method name="endSavingState">
      <desc>
        Called by the VM process to inform the server that saving
        the state previously requested by #beginSavingState is either
        successfully finished or there was a failure.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>

      <param name="success" type="boolean" dir="in">
        <desc>@c true to indicate success and @c false otherwise.
        </desc>
      </param>
    </method>

    <method name="adoptSavedState">
      <desc>
        Gets called by IConsole::adoptSavedState.
        <result name="VBOX_E_FILE_ERROR">
          Invalid saved state file path.
        </result>
      </desc>
      <param name="savedStateFile" type="wstring" dir="in">
        <desc>Path to the saved state file to adopt.</desc>
      </param>
    </method>

    <method name="beginTakingSnapshot">
      <desc>
        Called from the VM process to request from the server to perform the
        server-side actions of creating a snapshot (creating differencing images
        and the snapshot object).

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="name" type="wstring" dir="in">
        <desc>Snapshot name.</desc>
      </param>
      <param name="description" type="wstring" dir="in">
        <desc>Snapshot description.</desc>
      </param>
      <param name="consoleProgress" type="IProgress" dir="in">
        <desc>
          Progress object created by the VM process tracking the
          snapshot's progress. This has the following sub-operations:
          <ul>
            <li>setting up (weight 1);</li>
            <li>one for each medium attachment that needs a differencing image (weight 1 each);</li>
            <li>another one to copy the VM state (if offline with saved state, weight is VM memory size in MB);</li>
            <li>another one to save the VM state (if online, weight is VM memory size in MB);</li>
            <li>finishing up (weight 1)</li>
          </ul>
        </desc>
      </param>
      <param name="fTakingSnapshotOnline" type="boolean" dir="in">
        <desc>
          Whether this is an online snapshot (i.e. the machine is running).
        </desc>
      </param>
      <param name="stateFilePath" type="wstring" dir="out">
        <desc>
          File path the VM process must save the execution state to.
        </desc>
      </param>
    </method>

    <method name="endTakingSnapshot">
      <desc>
        Called by the VM process to inform the server that the snapshot
        previously requested by #beginTakingSnapshot is either
        successfully taken or there was a failure.
      </desc>

      <param name="success" type="boolean" dir="in">
        <desc>@c true to indicate success and @c false otherwise</desc>
      </param>
    </method>

    <method name="deleteSnapshot">
      <desc>
        Gets called by IConsole::deleteSnapshot.
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Snapshot has more than one child snapshot.
        </result>
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the snapshot to delete.</desc>
      </param>
      <param name="machineState" type="MachineState" dir="out">
        <desc>New machine state after this operation is started.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="finishOnlineMergeMedium">
      <desc>
        Gets called by IConsole::onlineMergeMedium.
      </desc>
      <param name="mediumAttachment" type="IMediumAttachment" dir="in">
        <desc>The medium attachment which needs to be cleaned up.</desc>
      </param>
      <param name="source" type="IMedium" dir="in">
        <desc>Merge source medium.</desc>
      </param>
      <param name="target" type="IMedium" dir="in">
        <desc>Merge target medium.</desc>
      </param>
      <param name="mergeForward" type="boolean" dir="in">
        <desc>Merge direction.</desc>
      </param>
      <param name="parentForTarget" type="IMedium" dir="in">
        <desc>For forward merges: new parent for target medium.</desc>
      </param>
      <param name="childrenToReparent" type="IMedium" safearray="yes" dir="in">
        <desc>For backward merges: list of media which need their parent UUID
        updated.</desc>
      </param>
    </method>

    <method name="restoreSnapshot">
      <desc>
        Gets called by IConsole::RestoreSnapshot.
      </desc>
      <param name="initiator" type="IConsole" dir="in">
        <desc>The console object that initiated this call.</desc>
      </param>
      <param name="snapshot" type="ISnapshot" dir="in">
        <desc>The snapshot to restore the VM state from.</desc>
      </param>
      <param name="machineState" type="MachineState" dir="out">
        <desc>New machine state after this operation is started.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="pullGuestProperties">
      <desc>
        Get the list of the guest properties matching a set of patterns along
        with their values, time stamps and flags and give responsibility for
        managing properties to the console.
      </desc>
      <param name="name" type="wstring" dir="out" safearray="yes">
        <desc>
          The names of the properties returned.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out" safearray="yes">
        <desc>
          The values of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="out" safearray="yes">
        <desc>
          The time stamps of the properties returned.  The array entries match
          the corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out" safearray="yes">
        <desc>
          The flags of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
    </method>

    <method name="pushGuestProperty">
      <desc>
        Update a single guest property in IMachine.
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          The name of the property to be updated.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The value of the property.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="in">
        <desc>
          The timestamp of the property.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="in">
        <desc>
          The flags of the property.
        </desc>
      </param>
    </method>

    <method name="lockMedia">
      <desc>
        Locks all media attached to the machine for writing and parents of
        attached differencing media (if any) for reading. This operation is
        atomic so that if it fails no media is actually locked.

        This method is intended to be called when the machine is in Starting or
        Restoring state. The locked media will be automatically unlocked when
        the machine is powered off or crashed.
      </desc>
    </method>
    <method name="unlockMedia">
      <desc>
        Unlocks all media previously locked using
        <link to="IInternalMachineControl::lockMedia"/>.

        This method is intended to be used with teleportation so that it is
        possible to teleport between processes on the same machine.
      </desc>
    </method>
  </interface>

  <interface
     name="IBIOSSettings" extends="$unknown"
     uuid="38b54279-dc35-4f5e-a431-835b867c6b5e"
     wsmap="managed"
     >
    <desc>
        The IBIOSSettings interface represents BIOS settings of the virtual
        machine. This is used only in the <link to="IMachine::BIOSSettings" /> attribute.
    </desc>
    <attribute name="logoFadeIn" type="boolean">
      <desc>Fade in flag for BIOS logo animation.</desc>
    </attribute>

    <attribute name="logoFadeOut" type="boolean">
      <desc>Fade out flag for BIOS logo animation.</desc>
    </attribute>

    <attribute name="logoDisplayTime" type="unsigned long">
      <desc>BIOS logo display time in milliseconds (0 = default).</desc>
    </attribute>

    <attribute name="logoImagePath" type="wstring">
      <desc>
        Local file system path for external BIOS splash image. Empty string
        means the default image is shown on boot.
      </desc>
    </attribute>

    <attribute name="bootMenuMode" type="BIOSBootMenuMode">
      <desc>Mode of the BIOS boot device menu.</desc>
    </attribute>

    <attribute name="ACPIEnabled" type="boolean">
      <desc>ACPI support flag.</desc>
    </attribute>

    <attribute name="IOAPICEnabled" type="boolean">
      <desc>
        IO APIC support flag. If set, VirtualBox will provide an IO APIC
        and support IRQs above 15.
      </desc>
    </attribute>

    <attribute name="timeOffset" type="long long">
      <desc>
        Offset in milliseconds from the host system time. This allows for
        guests running with a different system date/time than the host.
        It is equivalent to setting the system date/time in the BIOS except
        it is not an absolute value but a relative one. Guest Additions
        time synchronization honors this offset.
      </desc>
    </attribute>

    <attribute name="PXEDebugEnabled" type="boolean">
      <desc>
        PXE debug logging flag. If set, VirtualBox will write extensive
        PXE trace information to the release log.
      </desc>
    </attribute>

  </interface>

  <interface
     name="IMachine" extends="$unknown"
     uuid="6d9212cb-a5c0-48b7-bbc1-3fa2ba2ee6d2"
     wsmap="managed"
     >
    <desc>
      The IMachine interface represents a virtual machine, or guest, created
      in VirtualBox.

      This interface is used in two contexts. First of all, a collection of
      objects implementing this interface is stored in the
      <link to="IVirtualBox::machines"/> attribute which lists all the virtual
      machines that are currently registered with this VirtualBox
      installation. Also, once a session has been opened for the given virtual
      machine (e.g. the virtual machine is running), the machine object
      associated with the open session can be queried from the session object;
      see <link to="ISession"/> for details.

      The main role of this interface is to expose the settings of the virtual
      machine and provide methods to change various aspects of the virtual
      machine's configuration. For machine objects stored in the
      <link to="IVirtualBox::machines"/> collection, all attributes are
      read-only unless explicitly stated otherwise in individual attribute
      and method descriptions. In order to change a machine setting, a session
      for this machine must be opened using one of
      <link to="IVirtualBox::openSession"/>,
      <link to="IVirtualBox::openRemoteSession"/> or
      <link to="IVirtualBox::openExistingSession"/> methods. After the
      session has been successfully opened, a mutable machine object needs to
      be queried from the session object and then the desired settings changes
      can be applied to the returned object using IMachine attributes and
      methods. See the <link to="ISession"/> interface description for more
      information about sessions.

      Note that IMachine does not provide methods to control virtual machine
      execution (such as start the machine, or power it down) -- these methods
      are grouped in a separate interface called <link to="IConsole" />.

      <see>ISession, IConsole</see>
    </desc>

    <attribute name="parent" type="IVirtualBox" readonly="yes">
      <desc>Associated parent object.</desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>
        Whether this virtual machine is currently accessible or not.

        A machine is always deemed accessible unless it is registered <i>and</i>
        its settings file cannot be read or parsed (either because the file itself
        is unavailable or has invalid XML contents).

        Every time this property is read, the accessibility state of
        this machine is re-evaluated. If the returned value is @c false,
        the <link to="#accessError"/> property may be used to get the
        detailed error information describing the reason of
        inaccessibility, including XML error messages.

        When the machine is inaccessible, only the following properties
        can be used on it:
        <ul>
          <li><link to="#parent"/></li>
          <li><link to="#id"/></li>
          <li><link to="#settingsFilePath"/></li>
          <li><link to="#accessible"/></li>
          <li><link to="#accessError"/></li>
        </ul>

        An attempt to access any other property or method will return
        an error.

        The only possible action you can perform on an inaccessible
        machine is to unregister it using the
        <link to="IVirtualBox::unregisterMachine"/> call (or, to check
        for the accessibility state once more by querying this
        property).

        <note>
          In the current implementation, once this property returns
          @c true, the machine will never become inaccessible
          later, even if its settings file cannot be successfully
          read/written any more (at least, until the VirtualBox
          server is restarted). This limitation may be removed in
          future releases.
        </note>
      </desc>
    </attribute>

    <attribute name="accessError" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Error information describing the reason of machine
        inaccessibility.

        Reading this property is only valid after the last call to
        <link to="#accessible"/> returned @c false (i.e. the
        machine is currently unaccessible). Otherwise, a @c null
        IVirtualBoxErrorInfo object will be returned.
      </desc>
    </attribute>

    <attribute name="name" type="wstring">
      <desc>
        Name of the virtual machine.

        Besides being used for human-readable identification purposes
        everywhere in VirtualBox, the virtual machine name is also used
        as a name of the machine's settings file and as a name of the
        subdirectory this settings file resides in. Thus, every time you
        change the value of this property, the settings file will be
        renamed once you call <link to="#saveSettings"/> to confirm the
        change. The containing subdirectory will be also renamed, but
        only if it has exactly the same name as the settings file
        itself prior to changing this property (for backward compatibility
        with previous API releases). The above implies the following
        limitations:
        <ul>
          <li>The machine name cannot be empty.</li>
          <li>The machine name can contain only characters that are valid
            file name characters according to the rules of the file
            system used to store VirtualBox configuration.</li>
          <li>You cannot have two or more machines with the same name
            if they use the same subdirectory for storing the machine
            settings files.</li>
          <li>You cannot change the name of the machine if it is running,
            or if any file in the directory containing the settings file
            is being used by another running machine or by any other
            process in the host operating system at a time when
            <link to="#saveSettings"/> is called.
          </li>
        </ul>
        If any of the above limitations are hit, <link to="#saveSettings"/>
        will return an appropriate error message explaining the exact
        reason and the changes you made to this machine will not be
        saved.
        <note>
          For "legacy" machines created using the
          <link to="IVirtualBox::createLegacyMachine"/> call,
          the above naming limitations do not apply because the
          machine name does not affect the settings file name.
          The settings file name remains the same as it was specified
          during machine creation and never changes.
        </note>
      </desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>
        Description of the virtual machine.

        The description attribute can contain any text and is
        typically used to describe the hardware and software
        configuration of the virtual machine in detail (i.e. network
        settings, versions of the installed software and so on).
      </desc>
    </attribute>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>UUID of the virtual machine.</desc>
    </attribute>

    <attribute name="OSTypeId" type="wstring">
      <desc>
        User-defined identifier of the Guest OS type.
        You may use <link to="IVirtualBox::getGuestOSType"/> to obtain
        an IGuestOSType object representing details about the given
        Guest OS type.
        <note>
          This value may differ from the value returned by
          <link to="IGuest::OSTypeId"/> if Guest Additions are
          installed to the guest OS.
        </note>
      </desc>
    </attribute>

    <attribute name="HardwareVersion" type="wstring">
      <desc>Hardware version identifier. Internal use only for now.</desc>
    </attribute>

    <attribute name="hardwareUUID" type="uuid" mod="string">
      <desc>
        The UUID presented to the guest via memory tables, hardware and guest
        properties.  For most VMs this is the same as the @a id, but for VMs
        which have been cloned or teleported it may be the same as the source
        VM.  This latter is because the guest shouldn't notice that it was
        cloned or teleported.
      </desc>
    </attribute>

    <attribute name="CPUCount" type="unsigned long">
      <desc>Number of virtual CPUs in the VM.</desc>
    </attribute>

    <attribute name="CPUHotPlugEnabled" type="boolean">
      <desc>
        This setting determines whether VirtualBox allows CPU
        hotplugging for this machine.</desc>
    </attribute>

    <attribute name="memorySize" type="unsigned long">
      <desc>System memory size in megabytes.</desc>
    </attribute>

    <attribute name="memoryBalloonSize" type="unsigned long">
      <desc>Memory balloon size in megabytes.</desc>
    </attribute>

    <attribute name="PageFusionEnabled" type="boolean">
      <desc>
        This setting determines whether VirtualBox allows page
        fusion for this machine (64 bits host only).
      </desc>
    </attribute>

    <attribute name="VRAMSize" type="unsigned long">
      <desc>Video memory size in megabytes.</desc>
    </attribute>

    <attribute name="accelerate3DEnabled" type="boolean" default="false">
      <desc>
        This setting determines whether VirtualBox allows this machine to make
        use of the 3D graphics support available on the host.</desc>
    </attribute>

    <attribute name="accelerate2DVideoEnabled" type="boolean" default="false">
      <desc>
        This setting determines whether VirtualBox allows this machine to make
        use of the 2D video acceleration support available on the host.</desc>
    </attribute>

    <attribute name="monitorCount" type="unsigned long">
      <desc>
        Number of virtual monitors.
        <note>
          Only effective on Windows XP and later guests with
          Guest Additions installed.
        </note>
      </desc>
    </attribute>

    <attribute name="BIOSSettings" type="IBIOSSettings" readonly="yes">
      <desc>Object containing all BIOS settings.</desc>
    </attribute>

    <attribute name="firmwareType" type="FirmwareType">
      <desc>Type of firmware (such as legacy BIOS or EFI), used for initial
       bootstrap in this VM.</desc>
    </attribute>

    <attribute name="pointingHidType" type="PointingHidType">
      <desc>Type of pointing HID (such as mouse or tablet) used in this VM.
        The default is typically "PS2Mouse" but can vary depending on the
        requirements of the guest operating system.</desc>
    </attribute>

    <attribute name="keyboardHidType" type="KeyboardHidType">
      <desc>Type of keyboard HID used in this VM.
        The default is typically "PS2Keyboard" but can vary depending on the
        requirements of the guest operating system.</desc>
    </attribute>

    <attribute name="hpetEnabled" type="boolean">
      <desc>This attribute controls if High Precision Event Timer (HPET) is
        enabled in this VM. Use this property if you want to provide guests
        with additional time source, or if guest requires HPET to function correctly.
        Default is false.</desc>
    </attribute>

    <attribute name="snapshotFolder" type="wstring">
      <desc>
        Full path to the directory used to store snapshot data
        (differencing media and saved state files) of this machine.

        The initial value of this property is
        <tt>&lt;</tt><link to="#settingsFilePath">
          path_to_settings_file</link><tt>&gt;/&lt;</tt>
        <link to="#id">machine_uuid</link>
        <tt>&gt;</tt>.

        Currently, it is an error to try to change this property on
        a machine that has snapshots (because this would require to
        move possibly large files to a different location).
        A separate method will be available for this purpose later.

        <note>
          Setting this property to @c null or to an empty string will restore
          the initial value.
        </note>
        <note>
          When setting this property, the specified path can be
          absolute (full path) or relative to the directory where the
          <link to="#settingsFilePath">machine settings file</link>
          is located. When reading this property, a full path is
          always returned.
        </note>
        <note>
          The specified path may not exist, it will be created
          when necessary.
        </note>
      </desc>
    </attribute>

    <attribute name="VRDPServer" type="IVRDPServer" readonly="yes">
      <desc>VRDP server object.</desc>
    </attribute>

    <attribute name="mediumAttachments" type="IMediumAttachment" readonly="yes" safearray="yes">
      <desc>Array of media attached to this machine.</desc>
    </attribute>

    <attribute name="USBController" type="IUSBController" readonly="yes">
      <desc>
        Associated USB controller object.

        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>
      </desc>
    </attribute>

    <attribute name="audioAdapter" type="IAudioAdapter" readonly="yes">
      <desc>Associated audio adapter, always present.</desc>
    </attribute>

    <attribute name="storageControllers" type="IStorageController" readonly="yes" safearray="yes">
      <desc>Array of storage controllers attached to this machine.</desc>
    </attribute>

    <attribute name="settingsFilePath" type="wstring" readonly="yes">
      <desc>
        Full name of the file containing machine settings data.
      </desc>
    </attribute>

    <attribute name="settingsModified" type="boolean" readonly="yes">
      <desc>
        Whether the settings of this machine have been modified
        (but neither yet saved nor discarded).
        <note>
          Reading this property is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or opened
          by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>. For all other
          cases, the settings can never be modified.
        </note>
        <note>
          For newly created unregistered machines, the value of this
          property is always @c true until <link to="#saveSettings"/>
          is called (no matter if any machine settings have been
          changed after the creation or not). For opened machines
          the value is set to @c false (and then follows to normal rules).
        </note>
      </desc>
    </attribute>

    <attribute name="sessionState" type="SessionState" readonly="yes">
      <desc>Current session state for this machine.</desc>
    </attribute>

    <attribute name="sessionType" type="wstring" readonly="yes">
      <desc>
        Type of the session.  If <link to="#sessionState"/> is
        SessionSpawning or SessionOpen, this attribute contains the
        same value as passed to the
        <link to="IVirtualBox::openRemoteSession"/> method in the
        @a type parameter. If the session was opened directly using
        <link to="IVirtualBox::openSession"/>, or if
        <link to="#sessionState"/> is SessionClosed, the value of this
        attribute is an empty string.
      </desc>
    </attribute>

    <attribute name="sessionPid" type="unsigned long" readonly="yes">
      <desc>
        Identifier of the session process. This attribute contains the
        platform-dependent identifier of the process that has opened a
        direct session for this machine using the
        <link to="IVirtualBox::openSession"/> call. The returned value
        is only valid if <link to="#sessionState"/> is SessionOpen or
        SessionClosing (i.e. a session is currently open or being
        closed) by the time this property is read.
      </desc>
    </attribute>

    <attribute name="state" type="MachineState" readonly="yes">
      <desc>Current execution state of this machine.</desc>
    </attribute>

    <attribute name="lastStateChange" type="long long" readonly="yes">
      <desc>
        Time stamp of the last execution state change,
        in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="stateFilePath" type="wstring" readonly="yes">
      <desc>
        Full path to the file that stores the execution state of
        the machine when it is in the <link to="MachineState_Saved"/> state.
        <note>
          When the machine is not in the Saved state, this attribute is
          an empty string.
        </note>
      </desc>
    </attribute>

    <attribute name="logFolder" type="wstring" readonly="yes">
      <desc>
        Full path to the folder that stores a set of rotated log files
        recorded during machine execution. The most recent log file is
        named <tt>VBox.log</tt>, the previous log file is
        named <tt>VBox.log.1</tt> and so on (up to <tt>VBox.log.3</tt>
        in the current version).
      </desc>
    </attribute>

    <attribute name="currentSnapshot" type="ISnapshot" readonly="yes">
      <desc>
        Current snapshot of this machine. This is @c null if the machine
        currently has no snapshots. If it is not @c null, then it was
        set by one of <link to="Console::takeSnapshot" />,
        <link to="Console::deleteSnapshot" />
        or <link to="Console::restoreSnapshot" />, depending on which
        was called last. See <link to="ISnapshot"/> for details.
      </desc>
    </attribute>

    <attribute name="snapshotCount" type="unsigned long" readonly="yes">
      <desc>
        Number of snapshots taken on this machine. Zero means the
        machine doesn't have any snapshots.
      </desc>
    </attribute>

    <attribute name="currentStateModified" type="boolean" readonly="yes">
      <desc>
        Returns @c true if the current state of the machine is not
        identical to the state stored in the current snapshot.

        The current state is identical to the current snapshot only
        directly after one of the following calls are made:

        <ul>
          <li><link to="IConsole::restoreSnapshot"/>
          </li>
          <li><link to="IConsole::takeSnapshot"/> (issued on a
            "powered off" or "saved" machine, for which
            <link to="#settingsModified"/> returns @c false)
          </li>
          <li><link to="IMachine::setCurrentSnapshot"/>
          </li>
        </ul>

        The current state remains identical until one of the following
        happens:
        <ul>
          <li>settings of the machine are changed</li>
          <li>the saved state is deleted</li>
          <li>the current snapshot is deleted</li>
          <li>an attempt to execute the machine is made</li>
        </ul>

        <note>
          For machines that don't have snapshots, this property is
          always @c false.
        </note>
      </desc>
    </attribute>

    <attribute name="sharedFolders" type="ISharedFolder" readonly="yes" safearray="yes">
      <desc>
        Collection of shared folders for this machine (permanent shared
        folders). These folders are shared automatically at machine startup
        and available only to the guest OS installed within this machine.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.
      </desc>
    </attribute>

    <attribute name="clipboardMode" type="ClipboardMode">
      <desc>
        Synchronization mode between the host OS clipboard
        and the guest OS clipboard.
      </desc>
    </attribute>

    <attribute name="guestPropertyNotificationPatterns" type="wstring">
      <desc>
        A comma-separated list of simple glob patterns.  Changes to guest
        properties whose name matches one of the patterns will generate an
        <link to="IVirtualBoxCallback::onGuestPropertyChange"/> signal.
      </desc>
    </attribute>

    <attribute name="teleporterEnabled" type="boolean">
      <desc>
        When set to @a true, the virtual machine becomes a target teleporter
        the next time it is powered on.  This can only set to @a true when the
        VM is in the @a PoweredOff or @a Aborted state.

        <!-- This property is automatically set to @a false when the VM is powered
        on. (bird: This doesn't work yet ) -->
      </desc>
    </attribute>

    <attribute name="teleporterPort" type="unsigned long">
      <desc>
        The TCP port the target teleporter will listen for incoming
        teleportations on.

        0 means the port is automatically selected upon power on.  The actual
        value can be read from this property while the machine is waiting for
        incoming teleportations.
      </desc>
    </attribute>

    <attribute name="teleporterAddress" type="wstring">
      <desc>
        The address the target teleporter will listen on.  If set to an empty
        string, it will listen on all addresses.
      </desc>
    </attribute>

    <attribute name="teleporterPassword" type="wstring">
      <desc>
        The password the to check for on the target teleporter.  This is just a
        very basic measure to prevent simple hacks and operators accidentally
        beaming a virtual machine to the wrong place.
      </desc>
    </attribute>

    <attribute name="RTCUseUTC" type="boolean">
      <desc>
        When set to @a true, the RTC device of the virtual machine will run
        in UTC time, otherwise in local time. Especially Unix guests prefer
        the time in UTC.
      </desc>
    </attribute>

    <attribute name="ioCacheEnabled" type="boolean">
      <desc>
        When set to @a true, the builtin I/O cache of the virtual machine
        will be enabled.
      </desc>
    </attribute>

    <attribute name="ioCacheSize" type="unsigned long">
      <desc>
        Maximum size of the I/O cache in MB.
      </desc>
    </attribute>

    <attribute name="ioBandwidthMax" type="unsigned long">
      <desc>
        The maximum number of MB the VM is allowed to transfer per second.
        0 means unlimited bandwidth.
      </desc>
    </attribute>

    <method name="setBootOrder">
      <desc>
        Puts the given device to the specified position in
        the boot order.

        To indicate that no device is associated with the given position,
        <link to="DeviceType_Null"/> should be used.

        @todo setHardDiskBootOrder(), setNetworkBootOrder()

        <result name="E_INVALIDARG">
          Boot @a position out of range.
        </result>
        <result name="E_NOTIMPL">
          Booting from USB @a device currently not supported.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>
          Position in the boot order (@c 1 to the total number of
          devices the machine can boot from, as returned by
          <link to="ISystemProperties::maxBootPosition"/>).
        </desc>
      </param>
      <param name="device" type="DeviceType" dir="in">
        <desc>
          The type of the device used to boot at the given position.
        </desc>
      </param>
    </method>

    <method name="getBootOrder" const="yes">
      <desc>
        Returns the device type that occupies the specified
        position in the boot order.

        @todo [remove?]
        If the machine can have more than one device of the returned type
        (such as hard disks), then a separate method should be used to
        retrieve the individual device that occupies the given position.

        If here are no devices at the given position, then
        <link to="DeviceType_Null"/> is returned.

        @todo getHardDiskBootOrder(), getNetworkBootOrder()

        <result name="E_INVALIDARG">
          Boot @a position out of range.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>
          Position in the boot order (@c 1 to the total number of
          devices the machine can boot from, as returned by
          <link to="ISystemProperties::maxBootPosition"/>).
        </desc>
      </param>
      <param name="device" type="DeviceType" dir="return">
        <desc>
          Device at the given position.
        </desc>
      </param>
    </method>

    <method name="attachDevice">
      <desc>
        Attaches a device and optionally mounts a medium to the given storage
        controller (<link to="IStorageController" />, identified by @a name),
        at the indicated port and device.

        This method is intended for managing storage devices in general (it works
        for both fixed and removable media). For storage devices supporting removable
        media (such as DVDs and floppies), you can also use <link to="IMedium::mountMedium"/>
        for changing the media while the machine is running.

        In a VM's default configuration of virtual machines, the secondary
        master of the IDE controller is used for a CD/DVD drive.

        For fixed media such as hard disks, the given medium identifier cannot
        be a zero UUID. It may be a zero UUID for removable media such as DVDs
        and floppies.

        After calling this returns successfully, a new instance of
        <link to="IMediumAttachment"/> will appear in the machine's list of medium
        attachments (<link to="IMachine::mediumAttachments"/>).

        The specified device slot must not have a device attached to it,
        or this method will fail.

        See <link to="IMedium"/> and <link to="IMediumAttachment"/> for more
        information about attaching media.

        <note>
          You cannot attach a device to a running machine. Also, you cannot
          attach a device to a newly created machine until this machine's
          settings are saved to disk using <link to="#saveSettings"/>.
        </note>
        <note>
          If the medium is being attached indirectly, a new differencing medium
          will implicitly be created for it and attached instead. If the
          changes made to the machine settings (including this indirect
          attachment) are later cancelled using <link to="#discardSettings"/>,
          this implicitly created differencing medium will implicitly
          be deleted.
        </note>

        <result name="E_INVALIDARG">
          SATA device, SATA port, IDE port or IDE slot out of range.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Attempt to attach medium to an unregistered virtual machine.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>
        <result name="VBOX_E_OBJECT_IN_USE">
          Hard disk already attached to this or another virtual machine.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller to attach the device to.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Port to attach the device to. For an IDE controller, 0 specifies
        the primary controller and 1 specifies the secondary controller.
        For a SCSI controller, this must range from 0 to 15; for a SATA controller,
        from 0 to 29; for an SAS controller, from 0 to 7.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port to attach the device to. This is only
        relevant for IDE controllers, for which 0 specifies the master device and
        1 specifies the slave device. For all other controller types, this must
        be 0.</desc>
      </param>
      <param name="type" type="DeviceType" dir="in">
        <desc>Device type of the attached device.</desc>
      </param>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the medium to mount. Zero UUID means do not mount any
        medium.</desc>
      </param>
    </method>

    <method name="detachDevice">
      <desc>
        Detaches the device attached to a device slot of the specified bus.

        Detaching the device from the virtual machine is deferred. This means
        that the medium remains associated with the machine when this method
        returns and gets actually de-associated only after a successful
        <link to="#saveSettings"/> call. See <link to="IMedium"/>
        for more detailed information about attaching media.

        <note>
          You cannot detach a device from a running machine.
        </note>
        <note>
          Detaching differencing media implicitly created by <link
          to="#attachDevice"/> for the indirect attachment using this
          method will <b>not</b> implicitly delete them. The
          <link to="IMedium::deleteStorage"/> operation should be
          explicitly performed by the caller after the medium is successfully
          detached and the settings are saved with
          <link to="#saveSettings"/>, if it is the desired action.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Attempt to detach medium from a running virtual machine.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No medium attached to given slot/bus.
        </result>
        <result name="VBOX_E_NOT_SUPPORTED">
          Medium format does not support storage deletion.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller to detach the medium from.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Port number to detach the medium from.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot number to detach the medium from.</desc>
      </param>
    </method>

    <method name="passthroughDevice">
      <desc>
        Sets the passthrough mode of an existing DVD device. Changing the
        setting while the VM is running is forbidden. The setting is only used
        if at VM start the device is configured as a host DVD drive, in all
        other cases it is ignored. The device must already exist; see
        <link to="IMachine::attachDevice"/> for how to attach a new device.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with <link to="IMachine::attachDevice" />.

        <result name="E_INVALIDARG">
          SATA device, SATA port, IDE port or IDE slot out of range.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Attempt to modify an unregistered virtual machine.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Storage controller port.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port.</desc>
      </param>
      <param name="passthrough" type="boolean" dir="in">
        <desc>New value for the passthrough setting.</desc>
      </param>
    </method>

    <method name="mountMedium">
      <desc>
        Mounts a medium (<link to="IMedium" />, identified
        by the given UUID @a id) to the given storage controller
        (<link to="IStorageController" />, identified by @a name),
        at the indicated port and device. The device must already exist;
        see <link to="IMachine::attachDevice"/> for how to attach a new device.

        This method is intended only for managing removable media, where the
        device is fixed but media is changeable at runtime (such as DVDs
        and floppies). It cannot be used for fixed media such as hard disks.

        The @a controllerPort and @a device parameters specify the device slot and
        have have the same meaning as with <link to="IMachine::attachDevice" />.

        The specified device slot can have a medium mounted, which will be
        unmounted first. Specifying a zero UUID (or an empty string) for
        @a medium does just an unmount.

        See <link to="IMedium"/> for more detailed information about
        attaching media.

        <result name="E_INVALIDARG">
          SATA device, SATA port, IDE port or IDE slot out of range.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Attempt to attach medium to an unregistered virtual machine.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Invalid machine state.
        </result>
        <result name="VBOX_E_OBJECT_IN_USE">
          Medium already attached to this or another virtual machine.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller to attach the medium to.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Port to attach the medium to.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port to attach the medium to.</desc>
      </param>
      <param name="medium" type="uuid" mod="string" dir="in">
        <desc>UUID of the medium to attach. A zero UUID means unmount the
          currently mounted medium.</desc>
      </param>
      <param name="force" type="boolean" dir="in">
        <desc>Allows to force unmount/mount of a medium which is locked by
          theDevice slot in the given port to attach the medium to.</desc>
      </param>
    </method>

    <method name="getMedium" const="yes">
      <desc>
        Returns the virtual medium attached to a device slot of the specified
        bus.

        Note that if the medium was indirectly attached by
        <link to="#mountMedium"/> to the given device slot then this
        method will return not the same object as passed to the
        <link to="#mountMedium"/> call. See <link to="IMedium"/> for
        more detailed information about mounting a medium.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No medium attached to given slot/bus.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the storage controller the medium is attached to.</desc>
      </param>
      <param name="controllerPort" type="long" dir="in">
        <desc>Port to query.</desc>
      </param>
      <param name="device" type="long" dir="in">
        <desc>Device slot in the given port to query.</desc>
      </param>
      <param name="medium" type="IMedium" dir="return">
        <desc>Attached medium object.</desc>
      </param>
    </method>

    <method name="getMediumAttachmentsOfController" const="yes">
      <desc>
        Returns an array of medium attachments which are attached to the
        the controller with the given name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          A storage controller with given name doesn't exist.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="mediumAttachments" type="IMediumAttachment" safearray="yes" dir="return"/>
    </method>

    <method name="getMediumAttachment" const="yes">
      <desc>
        Returns a medium attachment which corresponds to the controller with
        the given name, on the given port and device slot.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No attachment exists for the given controller/port/device combination.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="controllerPort" type="long" dir="in"/>
      <param name="device" type="long" dir="in"/>
      <param name="attachment" type="IMediumAttachment" dir="return"/>
    </method>

    <method name="getNetworkAdapter" const="yes">
      <desc>
        Returns the network adapter associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of adapters per machine is defined by the
        <link to="ISystemProperties::networkAdapterCount"/> property,
        so the maximum slot number is one less than that property's value.

        <result name="E_INVALIDARG">
          Invalid @a slot number.
        </result>

      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="adapter" type="INetworkAdapter" dir="return"/>
    </method>

    <method name="addStorageController">
      <desc>
        Adds a new storage controller (SCSI, SAS or SATA controller) to the
        machine and returns it as an instance of
        <link to="IStorageController" />.

        @a name identifies the controller for subsequent calls such as
        <link to="#getStorageControllerByName" />,
        <link to="#getStorageControllerByInstance" />,
        <link to="#removeStorageController" />,
        <link to="#attachDevice" /> or <link to="#mountMedium" />.

        After the controller has been added, you can set its exact
        type by setting the <link to="IStorageController::controllerType" />.

        <result name="VBOX_E_OBJECT_IN_USE">
          A storage controller with given name exists already.
        </result>
        <result name="E_INVALIDARG">
          Invalid @a controllerType.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="connectionType" type="StorageBus" dir="in"/>
      <param name="controller" type="IStorageController" dir="return"/>
    </method>

    <method name="getStorageControllerByName" const="yes">
      <desc>
        Returns a storage controller with the given name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          A storage controller with given name doesn't exist.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="storageController" type="IStorageController" dir="return"/>
    </method>

    <method name="getStorageControllerByInstance" const="yes">
      <desc>
        Returns a storage controller with the given instance number.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          A storage controller with given instance number doesn't exist.
        </result>
      </desc>
      <param name="instance" type="unsigned long" dir="in"/>
      <param name="storageController" type="IStorageController" dir="return"/>
    </method>

   <method name="removeStorageController">
      <desc>
        Removes a storage controller from the machine.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          A storage controller with given name doesn't exist.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in"/>
    </method>

    <method name="getSerialPort" const="yes">
      <desc>
        Returns the serial port associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of serial ports per machine is defined by the
        <link to="ISystemProperties::serialPortCount"/> property,
        so the maximum slot number is one less than that property's value.

        <result name="E_INVALIDARG">
          Invalid @a slot number.
        </result>

      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="port" type="ISerialPort" dir="return"/>
    </method>

    <method name="getParallelPort" const="yes">
      <desc>
        Returns the parallel port associated with the given slot.
        Slots are numbered sequentially, starting with zero. The total
        number of parallel ports per machine is defined by the
        <link to="ISystemProperties::parallelPortCount"/> property,
        so the maximum slot number is one less than that property's value.

        <result name="E_INVALIDARG">
          Invalid @a slot number.
        </result>

      </desc>
      <param name="slot" type="unsigned long" dir="in"/>
      <param name="port" type="IParallelPort" dir="return"/>
    </method>

    <method name="getExtraDataKeys">
        <desc>
            Returns an array representing the machine-specific extra data keys
            which currently have values defined.
        </desc>
        <param name="value" type="wstring" dir="return" safearray="yes">
            <desc>Array of extra data keys.</desc>
        </param>
    </method>

    <method name="getExtraData">
      <desc>
        Returns associated machine-specific extra data.

        If the requested data @a key does not exist, this function will
        succeed and return an empty string in the @a value argument.

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Value of the requested data key.</desc>
      </param>
    </method>

    <method name="setExtraData">
      <desc>
        Sets associated machine-specific extra data.

        If you pass @c null or an empty string as a key @a value, the given
        @a key will be deleted.

        <note>
          Before performing the actual data change, this method will ask all
          registered callbacks using the
          <link to="IVirtualBoxCallback::onExtraDataCanChange"/>
          notification for a permission. If one of the callbacks refuses the
          new value, the change will not be performed.
        </note>
        <note>
          On success, the
          <link to="IVirtualBoxCallback::onExtraDataChange"/> notification
          is called to inform all registered callbacks about a successful data
          change.
        </note>
        <note>
          This method can be called outside the machine session and therefore
          it's a caller's responsibility to handle possible race conditions
          when several clients change the same key at the same time.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
      <param name="key" type="wstring" dir="in">
        <desc>Name of the data key to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Value to assign to the key.</desc>
      </param>
    </method>

    <method name="getCPUProperty" const="yes">
      <desc>
        Returns the virtual CPU boolean value of the specified property.

        <result name="E_INVALIDARG">
          Invalid property.
        </result>

      </desc>
      <param name="property" type="CPUPropertyType" dir="in">
        <desc>
          Property type to query.
        </desc>
      </param>
      <param name="value" type="boolean" dir="return">
        <desc>
          Property value.
        </desc>
      </param>
    </method>

    <method name="setCPUProperty">
      <desc>
        Sets the virtual CPU boolean value of the specified property.

        <result name="E_INVALIDARG">
          Invalid property.
        </result>

      </desc>
      <param name="property" type="CPUPropertyType" dir="in">
        <desc>
          Property type to query.
        </desc>
      </param>
      <param name="value" type="boolean" dir="in">
        <desc>
          Property value.
        </desc>
      </param>
    </method>

    <method name="getCPUIDLeaf" const="yes">
      <desc>
        Returns the virtual CPU cpuid information for the specified leaf.

        Currently supported index values for cpuid:
        Standard CPUID leafs: 0 - 0xA
        Extended CPUID leafs: 0x80000000 - 0x8000000A

        See the Intel and AMD programmer's manuals for detailed information
        about the cpuid instruction and its leafs.
        <result name="E_INVALIDARG">
          Invalid id.
        </result>

      </desc>
      <param name="id" type="unsigned long" dir="in">
        <desc>
          CPUID leaf index.
        </desc>
      </param>
      <param name="valEax" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register eax.
        </desc>
      </param>
      <param name="valEbx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register ebx.
        </desc>
      </param>
      <param name="valEcx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register ecx.
        </desc>
      </param>
      <param name="valEdx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register edx.
        </desc>
      </param>
    </method>

    <method name="setCPUIDLeaf">
      <desc>
        Sets the virtual CPU cpuid information for the specified leaf. Note that these values
        are not passed unmodified. VirtualBox clears features that it doesn't support.

        Currently supported index values for cpuid:
        Standard CPUID leafs: 0 - 0xA
        Extended CPUID leafs: 0x80000000 - 0x8000000A

        See the Intel and AMD programmer's manuals for detailed information
        about the cpuid instruction and its leafs.

        Do not use this method unless you know exactly what you're doing. Misuse can lead to
        random crashes inside VMs.
        <result name="E_INVALIDARG">
          Invalid id.
        </result>

      </desc>
      <param name="id" type="unsigned long" dir="in">
        <desc>
          CPUID leaf index.
        </desc>
      </param>
      <param name="valEax" type="unsigned long" dir="in">
        <desc>
          CPUID leaf value for register eax.
        </desc>
      </param>
      <param name="valEbx" type="unsigned long" dir="in">
        <desc>
          CPUID leaf value for register ebx.
        </desc>
      </param>
      <param name="valEcx" type="unsigned long" dir="in">
        <desc>
          CPUID leaf value for register ecx.
        </desc>
      </param>
      <param name="valEdx" type="unsigned long" dir="in">
        <desc>
          CPUID leaf value for register edx.
        </desc>
      </param>
    </method>

    <method name="removeCPUIDLeaf">
      <desc>
        Removes the virtual CPU cpuid leaf for the specified index

        <result name="E_INVALIDARG">
          Invalid id.
        </result>

      </desc>
      <param name="id" type="unsigned long" dir="in">
        <desc>
          CPUID leaf index.
        </desc>
      </param>
    </method>

    <method name="removeAllCPUIDLeaves">
      <desc>
        Removes all the virtual CPU cpuid leaves
      </desc>
    </method>

    <method name="getHWVirtExProperty" const="yes">
      <desc>
        Returns the value of the specified hardware virtualization boolean property.

        <result name="E_INVALIDARG">
          Invalid property.
        </result>

      </desc>
      <param name="property" type="HWVirtExPropertyType" dir="in">
        <desc>
          Property type to query.
        </desc>
      </param>
      <param name="value" type="boolean" dir="return">
        <desc>
          Property value.
        </desc>
      </param>
    </method>

    <method name="setHWVirtExProperty">
      <desc>
        Sets a new value for the specified hardware virtualization boolean property.

        <result name="E_INVALIDARG">
          Invalid property.
        </result>

      </desc>
      <param name="property" type="HWVirtExPropertyType" dir="in">
        <desc>
          Property type to set.
        </desc>
      </param>
      <param name="value" type="boolean" dir="in">
        <desc>
          New property value.
        </desc>
      </param>
    </method>

    <method name="saveSettings">
      <desc>
        Saves any changes to machine settings made since the session
        has been opened or a new machine has been created, or since the
        last call to <link to="#saveSettings"/> or <link to="#discardSettings"/>.
        For registered machines, new settings become visible to all
        other VirtualBox clients after successful invocation of this
        method.
        <note>
          The method sends <link to="IVirtualBoxCallback::onMachineDataChange"/>
          notification event after the configuration has been successfully
          saved (only for registered machines).
        </note>
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>.
        </note>

        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>
        <result name="E_ACCESSDENIED">
          Modification request refused.
        </result>

      </desc>
    </method>

    <method name="discardSettings">
      <desc>
        Discards any changes to the machine settings made since the session
        has been opened or since the last call to <link to="#saveSettings"/>
        or <link to="#discardSettings"/>.
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or
          opened by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>

      </desc>
    </method>

    <method name="deleteSettings">
      <desc>
        Deletes the settings file of this machine from disk.
        The machine must not be registered in order for this operation
        to succeed.
        <note>
          <link to="#settingsModified"/> will return @c true after this
          method successfully returns.
        </note>
        <note>
          Calling this method is only valid on instances returned
          by <link to="ISession::machine"/> and on new machines
          created by <link to="IVirtualBox::createMachine"/> or
          opened by <link to="IVirtualBox::openMachine"/> but not
          yet registered, or on unregistered machines after calling
          <link to="IVirtualBox::unregisterMachine"/>.
        </note>
        <note>
          The deleted machine settings file can be restored (saved again)
          by calling <link to="#saveSettings"/>.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Cannot delete settings of a registered machine or
          machine not mutable.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not delete the settings file.
        </result>

      </desc>
    </method>

    <method name="export">
        <desc>Exports the machine to an OVF appliance. See <link to="IAppliance" /> for the
              steps required to export VirtualBox machines to OVF.
        </desc>

        <param name="aAppliance" type="IAppliance" dir="in">
            <desc>Appliance to export this machine to.</desc>
        </param>
        <param name="aDescription" type="IVirtualSystemDescription" dir="return">
            <desc>VirtualSystemDescription object which is created for this machine.</desc>
        </param>
    </method >

    <method name="getSnapshot">
      <desc>
        Returns a snapshot of this machine with the given UUID.
        A @c null UUID can be used to obtain the first snapshot
        taken on this machine. This is useful if you want to traverse
        the whole tree of snapshots starting from the root.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Virtual machine has no snapshots or snapshot not found.
        </result>

      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the snapshot to get</desc>
      </param>
      <param name="snapshot" type="ISnapshot" dir="return">
        <desc>Snapshot object with the given UUID.</desc>
      </param>
    </method>

    <method name="findSnapshot">
      <desc>
        Returns a snapshot of this machine with the given name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Virtual machine has no snapshots or snapshot not found.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the snapshot to find</desc>
      </param>
      <param name="snapshot" type="ISnapshot" dir="return">
        <desc>Snapshot object with the given name.</desc>
      </param>
    </method>

    <method name="setCurrentSnapshot">
      <desc>
        Sets the current snapshot of this machine.
        <note>
          In the current implementation, this operation is not
          implemented.
        </note>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the snapshot to set as the current snapshot.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a new permanent shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.

        <result name="VBOX_E_OBJECT_IN_USE">
          Shared folder already exists.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Shared folder @a hostPath not accessible.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes the permanent shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Shared folder @a name does not exist.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="canShowConsoleWindow">
      <desc>
        Returns @c true if the VM console process can activate the
        console window and bring it to foreground on the desktop of
        the host PC.
        <note>
          This method will fail if a session for this machine is not
          currently open.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="canShow" type="boolean" dir="return">
        <desc>
          @c true if the console window can be shown and @c false otherwise.
        </desc>
      </param>
    </method>

    <method name="showConsoleWindow">
      <desc>
        Activates the console window and brings it to foreground on
        the desktop of the host PC. Many modern window managers on
        many platforms implement some sort of focus stealing
        prevention logic, so that it may be impossible to activate
        a window without the help of the currently active
        application. In this case, this method will return a non-zero
        identifier that represents the top-level window of the VM
        console process. The caller, if it represents a currently
        active process, is responsible to use this identifier (in a
        platform-dependent manner) to perform actual window
        activation.
        <note>
          This method will fail if a session for this machine is not
          currently open.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="winId" type="unsigned long long" dir="return">
        <desc>
          Platform-dependent identifier of the top-level VM console
          window, or zero if this method has performed all actions
          necessary to implement the <i>show window</i> semantics for
          the given platform and/or VirtualBox front-end.
        </desc>
      </param>
    </method>

    <method name="getGuestProperty" const="yes">
      <desc>
        Reads an entry from the machine's guest property store.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          The name of the property to read.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out">
        <desc>
          The value of the property.  If the property does not exist then this
          will be empty.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="out">
        <desc>
          The time at which the property was last modified, as seen by the
          server process.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out">
        <desc>
          Additional property parameters, passed as a comma-separated list of
          "name=value" type entries.
        </desc>
      </param>
    </method>

    <method name="getGuestPropertyValue" const="yes">
      <desc>
        Reads a value from the machine's guest property store.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to read.
        </desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>
          The value of the property.  If the property does not exist then this
          will be empty.
        </desc>
      </param>
    </method>

    <method name="getGuestPropertyTimestamp" const="yes">
      <desc>
        Reads a property timestamp from the machine's guest property store.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>

      </desc>
      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to read.
        </desc>
      </param>
      <param name="value" type="unsigned long long" dir="return">
        <desc>
          The timestamp.  If the property does not exist then this will be
          empty.
        </desc>
      </param>
    </method>

    <method name="setGuestProperty">
      <desc>
        Sets, changes or deletes an entry in the machine's guest property
        store.

        <result name="E_ACCESSDENIED">
          Property cannot be changed.
        </result>
        <result name="E_INVALIDARG">
          Invalid @a flags.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable or session not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Cannot set transient property when machine not running.
        </result>

      </desc>
      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to set, change or delete.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The new value of the property to set, change or delete.  If the
          property does not yet exist and value is non-empty, it will be
          created.  If the value is @c null or empty, the property will be
          deleted if it exists.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="in">
        <desc>
          Additional property parameters, passed as a comma-separated list of
          "name=value" type entries.
        </desc>
      </param>
    </method>

    <method name="setGuestPropertyValue">
      <desc>
        Sets, changes or deletes a value in the machine's guest property
        store.  The flags field will be left unchanged or created empty for a
        new property.

        <result name="E_ACCESSDENIED">
          Property cannot be changed.
        </result>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable or session not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Cannot set transient property when machine not running.
        </result>
      </desc>

      <param name="property" type="wstring" dir="in">
        <desc>
          The name of the property to set, change or delete.
        </desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>
          The new value of the property to set, change or delete.  If the
          property does not yet exist and value is non-empty, it will be
          created.  If the value is @c null or empty, the property will be
          deleted if it exists.
        </desc>
      </param>
    </method>

    <method name="enumerateGuestProperties">
      <desc>
        Return a list of the guest properties matching a set of patterns along
        with their values, time stamps and flags.
      </desc>
      <param name="patterns" type="wstring" dir="in">
        <desc>
          The patterns to match the properties against, separated by '|'
          characters.  If this is empty or @c null, all properties will match.
        </desc>
      </param>
      <param name="name" type="wstring" dir="out" safearray="yes">
        <desc>
          The names of the properties returned.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out" safearray="yes">
        <desc>
          The values of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="out" safearray="yes">
        <desc>
          The time stamps of the properties returned.  The array entries match
          the corresponding entries in the @a name array.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out" safearray="yes">
        <desc>
          The flags of the properties returned.  The array entries match the
          corresponding entries in the @a name array.
        </desc>
      </param>
    </method>

    <method name="querySavedThumbnailSize">
      <desc>
        Returns size in bytes and dimensions in pixels of a saved thumbnail bitmap from saved state.
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Saved guest screen to query info from.
        </desc>
      </param>
      <param name="size" type="unsigned long" dir="out">
        <desc>
          Size of buffer required to store the bitmap.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="out">
        <desc>
          Bitmap width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="out">
        <desc>
          Bitmap height.
        </desc>
      </param>
    </method>

    <method name="readSavedThumbnailToArray">
      <desc>
        Thumbnail is retrieved to an array of bytes in uncompressed 32-bit BGRA or RGBA format.
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Saved guest screen to read from.
        </desc>
      </param>
      <param name="BGR" type="boolean" dir="in">
        <desc>
          How to order bytes in the pixel. A pixel consists of 4 bytes. If this parameter is true, then
          bytes order is: B, G, R, 0xFF. If this parameter is false, then bytes order is: R, G, B, 0xFF.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="out">
        <desc>
          Bitmap width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="out">
        <desc>
          Bitmap height.
        </desc>
      </param>
      <param name="data" type="octet" dir="return" safearray="yes">
        <desc>
          Array with resulting bitmap data.
        </desc>
      </param>
    </method>

    <method name="querySavedScreenshotPNGSize">
      <desc>
        Returns size in bytes and dimensions of a saved PNG image of screenshot from saved state.
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Saved guest screen to query info from.
        </desc>
      </param>
      <param name="size" type="unsigned long" dir="out">
        <desc>
          Size of buffer required to store the PNG binary data.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="out">
        <desc>
          Image width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="out">
        <desc>
          Image height.
        </desc>
      </param>
    </method>

    <method name="readSavedScreenshotPNGToArray">
      <desc>
        Screenshot in PNG format is retrieved to an array of bytes.
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Saved guest screen to read from.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="out">
        <desc>
          Image width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="out">
        <desc>
          Image height.
        </desc>
      </param>
      <param name="data" type="octet" dir="return" safearray="yes">
        <desc>
          Array with resulting PNG data.
        </desc>
      </param>
    </method>

    <method name="hotPlugCPU">
      <desc>
        Plugs a CPU into the machine.
      </desc>
      <param name="cpu" type="unsigned long" dir="in">
        <desc>
          The CPU id to insert.
        </desc>
      </param>
    </method>

    <method name="hotUnplugCPU">
      <desc>
        Removes a CPU from the machine.
      </desc>
      <param name="cpu" type="unsigned long" dir="in">
        <desc>
          The CPU id to remove.
        </desc>
      </param>
    </method>

    <method name="getCPUStatus">
      <desc>
        Returns the current status of the given CPU.
      </desc>
      <param name="cpu" type="unsigned long" dir="in">
        <desc>
          The CPU id to check for.
        </desc>
      </param>
      <param name="attached" type="boolean" dir="return">
        <desc>
          Status of the CPU.
        </desc>
      </param>
    </method>

    <method name="queryLogFilename">
      <desc>
        Queries for the VM log file name of an given index. Returns an empty
        string if a log file with that index doesn't exists.
      </desc>
      <param name="idx" type="unsigned long" dir="in">
        <desc>
          Which log file name to query. 0=current log file.
        </desc>
      </param>
      <param name="filename" type="wstring" dir="return">
        <desc>
          On return the full path to the log file or an empty string on error.
        </desc>
      </param>
    </method>

    <method name="readLog">
      <desc>
        Reads the VM log file. The chunk size is limited, so even if you
        ask for a big piece there might be less data returned.
      </desc>
      <param name="idx" type="unsigned long" dir="in">
        <desc>
          Which log file to read. 0=current log file.
        </desc>
      </param>
      <param name="offset" type="unsigned long long" dir="in">
        <desc>
          Offset in the log file.
        </desc>
      </param>
      <param name="size" type="unsigned long long" dir="in">
        <desc>
          Chunk size to read in the log file.
        </desc>
      </param>
      <param name="data" type="octet" dir="return" safearray="yes">
        <desc>
          Data read from the log file. A data size of 0 means end of file
          if the requested chunk size was not 0. This is the unprocessed
          file data, i.e. the line ending style depends on the platform of
          the system the server is running on.
        </desc>
      </param>
    </method>
  </interface>

  <!--
  // IConsole
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IConsoleCallback" extends="$unknown"
     uuid="60703f8d-81e4-4b45-a147-dcfd07692b19"
     wsmap="suppress"
     >

    <desc>
        This interface is used by a client of the Main API that need to
        be notified of events. For example, a graphical user interface
        can use this to learn about machine state changes so they can
        update the list of virtual machines without having to rely
        on polling.

        Whenever relevant events occur in VirtualBox, the callbacks in
        objects of this interface are called. In order for this to be
        useful, a client needs to create its own subclass that implements
        this interface in which the methods for the relevant callbacks
        are overridden. An instance of this subclass interface can then
        be passed to <link to="IConsole::registerCallback" />.
    </desc>

    <method name="onMousePointerShapeChange">
      <desc>
        Notification when the guest mouse pointer shape has
        changed. The new shape data is given.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="visible" type="boolean" dir="in">
        <desc>
          Flag whether the pointer is visible.
        </desc>
      </param>
      <param name="alpha" type="boolean" dir="in">
        <desc>
          Flag whether the pointer has an alpha channel.
        </desc>
      </param>
      <param name="xHot" type="unsigned long" dir="in">
        <desc>
          The pointer hot spot x coordinate.
        </desc>
      </param>
      <param name="yHot" type="unsigned long" dir="in">
        <desc>
          The pointer hot spot y coordinate.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>
          Width of the pointer shape in pixels.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>
          Height of the pointer shape in pixels.
        </desc>
      </param>
      <param name="shape" type="octet" safearray="yes" dir="in">
        <desc>
          Shape buffer arrays.

          The @a shape buffer contains a 1-bpp (bits per pixel) AND mask
          followed by a 32-bpp XOR (color) mask.

          For pointers without alpha channel the XOR mask pixels are 32
          bit values: (lsb)BGR0(msb). For pointers with alpha channel
          the XOR mask consists of (lsb)BGRA(msb) 32 bit values.

          An AND mask is used for pointers with alpha channel, so if the
          callback does not support alpha, the pointer could be
          displayed as a normal color pointer.

          The AND mask is a 1-bpp bitmap with byte aligned scanlines. The
          size of the AND mask therefore is <tt>cbAnd = (width + 7) / 8 *
          height</tt>. The padding bits at the end of each scanline are
          undefined.

          The XOR mask follows the AND mask on the next 4-byte aligned
          offset: <tt>uint8_t *pXor = pAnd + (cbAnd + 3) &amp; ~3</tt>.
          Bytes in the gap between the AND and the XOR mask are undefined.
          The XOR mask scanlines have no gap between them and the size of
          the XOR mask is: <tt>cXor = width * 4 * height</tt>.

          <note>
            If @a shape is 0, only the pointer visibility is changed.
          </note>
        </desc>
      </param>
    </method>

    <method name="onMouseCapabilityChange">
      <desc>
        Notification when the mouse capabilities reported by the
        guest have changed. The new capabilities are passed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="supportsAbsolute" type="boolean" dir="in"/>
      <param name="supportsRelative" type="boolean" dir="in"/>
      <param name="needsHostCursor" type="boolean" dir="in"/>
    </method>

    <method name="onKeyboardLedsChange">
      <desc>
        Notification when the guest OS executes the KBD_CMD_SET_LEDS command
        to alter the state of the keyboard LEDs.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="numLock" type="boolean" dir="in"/>
      <param name="capsLock" type="boolean" dir="in"/>
      <param name="scrollLock" type="boolean" dir="in"/>
    </method>

    <method name="onStateChange">
      <desc>
        Notification when the execution state of the machine has changed.
        The new state will be given.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="state" type="MachineState" dir="in"/>
    </method>

    <method name="onAdditionsStateChange">
      <desc>
        Notification when a Guest Additions property changes.
        Interested callees should query IGuest attributes to
        find out what has changed.
      </desc>
    </method>

    <method name="onNetworkAdapterChange">
      <desc>
        Notification when a property of one of the
        virtual <link to="IMachine::getNetworkAdapter">network adapters</link>
        changes.  Interested callees should use INetworkAdapter methods and
        attributes to find out what has changed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="networkAdapter" type="INetworkAdapter" dir="in">
        <desc>Network adapter that is subject to change.</desc>
      </param>
    </method>

    <method name="onSerialPortChange">
      <desc>
        Notification when a property of one of the
        virtual <link to="IMachine::getSerialPort">serial ports</link> changes.
        Interested callees should use ISerialPort methods and attributes
        to find out what has changed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="serialPort" type="ISerialPort" dir="in">
        <desc>Serial port that is subject to change.</desc>
      </param>
    </method>

    <method name="onParallelPortChange">
      <desc>
        Notification when a property of one of the
        virtual <link to="IMachine::getParallelPort">parallel ports</link>
        changes.  Interested callees should use ISerialPort methods and
        attributes to find out what has changed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="parallelPort" type="IParallelPort" dir="in">
        <desc>Parallel port that is subject to change.</desc>
      </param>
    </method>

    <method name="onStorageControllerChange">
      <desc>
        Notification when a property of one of the
        virtual <link to="IMachine::storageControllers">storage controllers</link>
        changes. Interested callees should query the corresponding collections
        to find out what has changed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
    </method>

    <method name="onMediumChange">
      <desc>
        Notification when a
        <link to="IMachine::mediumAttachments">medium attachment</link>
        changes.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="mediumAttachment" type="IMediumAttachment" dir="in">
        <desc>Medium attachment that is subject to change.</desc>
      </param>
    </method>

    <method name="onCPUChange">
      <desc>
        Notification when a CPU changes.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="cpu" type="unsigned long" dir="in">
        <desc>The CPU which changed</desc>
      </param>
      <param name="add" type="boolean" dir="in">
        <desc>Flag whether the CPU was added or removed</desc>
      </param>
    </method>

    <method name="onVRDPServerChange">
      <desc>
        Notification when a property of the
        <link to="IMachine::VRDPServer">VRDP server</link> changes.
        Interested callees should use IVRDPServer methods and attributes to
        find out what has changed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
    </method>

    <method name="onRemoteDisplayInfoChange">
      <desc>
        Notification when the status of the VRDP server changes. Interested callees
        should use <link to="IConsole::RemoteDisplayInfo">IRemoteDisplayInfo</link>
        attributes to find out what is the current status.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
    </method>

    <method name="onUSBControllerChange">
      <desc>
        Notification when a property of the virtual
        <link to="IMachine::USBController">USB controller</link> changes.
        Interested callees should use IUSBController methods and attributes to
        find out what has changed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
    </method>

    <method name="onUSBDeviceStateChange">
      <desc>
        Notification when a USB device is attached to or detached from
        the virtual USB controller.

        This notification is sent as a result of the indirect
        request to attach the device because it matches one of the
        machine USB filters, or as a result of the direct request
        issued by <link to="IConsole::attachUSBDevice"/> or
        <link to="IConsole::detachUSBDevice"/>.

        This notification is sent in case of both a succeeded and a
        failed request completion. When the request succeeds, the
        @a error parameter is @c null, and the given device has been
        already added to (when @a attached is @c true) or removed from
        (when @a attached is @c false) the collection represented by
        <link to="IConsole::USBDevices"/>. On failure, the collection
        doesn't change and the @a error parameter represents the error
        message describing the failure.

        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="device" type="IUSBDevice" dir="in">
        <desc>Device that is subject to state change.</desc>
      </param>
      <param name="attached" type="boolean" dir="in">
        <desc>
          @c true if the device was attached and @c false otherwise.
        </desc>
      </param>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in">
        <desc>
          @c null on success or an error message object on failure.
        </desc>
      </param>
    </method>

    <method name="onSharedFolderChange">
      <desc>
        Notification when a shared folder is added or removed.
        The @a scope argument defines one of three scopes:
        <link to="IVirtualBox::sharedFolders">global shared folders</link>
        (<link to="Scope_Global">Global</link>),
        <link to="IMachine::sharedFolders">permanent shared folders</link> of
        the machine (<link to="Scope_Machine">Machine</link>) or <link
        to="IConsole::sharedFolders">transient shared folders</link> of the
        machine (<link to="Scope_Session">Session</link>). Interested callees
        should use query the corresponding collections to find out what has
        changed.
        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="scope" type="Scope" dir="in">
        <desc>Scope of the notification.</desc>
      </param>
    </method>

    <method name="onRuntimeError">
      <desc>
        Notification when an error happens during the virtual
        machine execution.

        There are three kinds of runtime errors:
        <ul>
          <li><i>fatal</i></li>
          <li><i>non-fatal with retry</i></li>
          <li><i>non-fatal warnings</i></li>
        </ul>

        <b>Fatal</b> errors are indicated by the @a fatal parameter set
        to @c true. In case of fatal errors, the virtual machine
        execution is always paused before calling this notification, and
        the notification handler is supposed either to immediately save
        the virtual machine state using <link to="IConsole::saveState"/>
        or power it off using <link to="IConsole::powerDown"/>.
        Resuming the execution can lead to unpredictable results.

        <b>Non-fatal</b> errors and warnings are indicated by the
        @a fatal parameter set to @c false. If the virtual machine
        is in the Paused state by the time the error notification is
        received, it means that the user can <i>try to resume</i> the machine
        execution after attempting to solve the problem that caused the
        error. In this case, the notification handler is supposed
        to show an appropriate message to the user (depending on the
        value of the @a id parameter) that offers several actions such
        as <i>Retry</i>, <i>Save</i> or <i>Power Off</i>. If the user
        wants to retry, the notification handler should continue
        the machine execution using the <link to="IConsole::resume"/>
        call. If the machine execution is not Paused during this
        notification, then it means this notification is a <i>warning</i>
        (for example, about a fatal condition that can happen very soon);
        no immediate action is required from the user, the machine
        continues its normal execution.

        Note that in either case the notification handler
        <b>must not</b> perform any action directly on a thread
        where this notification is called. Everything it is allowed to
        do is to post a message to another thread that will then talk
        to the user and take the corresponding action.

        Currently, the following error identifiers are known:
        <ul>
          <li><tt>"HostMemoryLow"</tt></li>
          <li><tt>"HostAudioNotResponding"</tt></li>
          <li><tt>"VDIStorageFull"</tt></li>
          <li><tt>"3DSupportIncompatibleAdditions"</tt></li>
        </ul>

        <note>
          This notification is not designed to be implemented by
          more than one callback at a time. If you have multiple
          IConsoleCallback instances registered on the given
          IConsole object, make sure you simply do nothing but
          return @c S_OK from all but one of them that does actual
          user notification and performs necessary actions.
        </note>

        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="fatal" type="boolean" dir="in">
        <desc>Whether the error is fatal or not</desc>
      </param>
      <param name="id" type="wstring" dir="in">
        <desc>Error identifier</desc>
      </param>
      <param name="message" type="wstring" dir="in">
        <desc>Optional error message</desc>
      </param>
    </method>

    <method name="onCanShowWindow">
      <desc>
        Notification when a call to
        <link to="IMachine::canShowConsoleWindow"/> is made by a
        front-end to check if a subsequent call to
        <link to="IMachine::showConsoleWindow"/> can succeed.

        The callee should give an answer appropriate to the current
        machine state in the @a canShow argument. This answer must
        remain valid at least until the next
        <link to="IConsole::state">machine state</link> change.

        <note>
          This notification is not designed to be implemented by
          more than one callback at a time. If you have multiple
          IConsoleCallback instances registered on the given
          IConsole object, make sure you simply do nothing but
          return @c true and @c S_OK from all but one of them that
          actually manages console window activation.
        </note>

        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="canShow" type="boolean" dir="return">
        <desc>
          @c true if the console window can be shown and @c false otherwise.
        </desc>
      </param>
    </method>

    <method name="onShowWindow">
      <desc>
        Notification when a call to
        <link to="IMachine::showConsoleWindow"/>
        requests the console window to be activated and brought to
        foreground on the desktop of the host PC.

        This notification should cause the VM console process to
        perform the requested action as described above. If it is
        impossible to do it at a time of this notification, this
        method should return a failure.

        Note that many modern window managers on many platforms
        implement some sort of focus stealing prevention logic, so
        that it may be impossible to activate a window without the
        help of the currently active application (which is supposedly
        an initiator of this notification). In this case, this method
        must return a non-zero identifier that represents the
        top-level window of the VM console process. The caller, if it
        represents a currently active process, is responsible to use
        this identifier (in a platform-dependent manner) to perform
        actual window activation.

        This method must set @a winId to zero if it has performed all
        actions necessary to complete the request and the console
        window is now active and in foreground, to indicate that no
        further action is required on the caller's side.

        <note>
          This notification is not designed to be implemented by
          more than one callback at a time. If you have multiple
          IConsoleCallback instances registered on the given
          IConsole object, make sure you simply do nothing but
          return @c S_OK from all but one of them that actually
          manages console window activation.
        </note>

        <result name="VBOX_E_DONT_CALL_AGAIN">
          Do not call again, this method is a NOP.
        </result>
      </desc>
      <param name="winId" type="unsigned long long" dir="return">
        <desc>
          Platform-dependent identifier of the top-level VM console
          window, or zero if this method has performed all actions
          necessary to implement the <i>show window</i> semantics for
          the given platform and/or this VirtualBox front-end.
        </desc>
      </param>
    </method>

  </interface>

  <interface
     name="IRemoteDisplayInfo" extends="$unknown"
     uuid="b3741084-806f-4c3b-8c42-ebad1a81e45a"
     wsmap="struct"
     >
     <desc>
        Contains information about the remote display (VRDP) capabilities and status.
        This is used in the <link to="IConsole::remoteDisplayInfo" /> attribute.
     </desc>

    <attribute name="active" type="boolean" readonly="yes">
      <desc>
        Whether the remote display connection is active.
      </desc>
    </attribute>

    <attribute name="port" type="long" readonly="yes">
      <desc>
        VRDP server port number. If this property is equal to <tt>0</tt>, then
        the VRDP server failed to start, usually because there are no free TCP
        ports to bind to. If this property is equal to <tt>-1</tt>, then the VRDP
        server has not yet been started.
      </desc>
    </attribute>

    <attribute name="numberOfClients" type="unsigned long" readonly="yes">
      <desc>
        How many times a client connected.
      </desc>
    </attribute>

    <attribute name="beginTime" type="long long" readonly="yes">
      <desc>
        When the last connection was established, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="endTime" type="long long" readonly="yes">
      <desc>
        When the last connection was terminated or the current time, if
        connection is still active, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="bytesSent" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were sent in last or current, if still active, connection.
      </desc>
    </attribute>

    <attribute name="bytesSentTotal" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were sent in all connections.
      </desc>
    </attribute>

    <attribute name="bytesReceived" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were received in last or current, if still active, connection.
      </desc>
    </attribute>

    <attribute name="bytesReceivedTotal" type="unsigned long long" readonly="yes">
      <desc>
        How many bytes were received in all connections.
      </desc>
    </attribute>

    <attribute name="user" type="wstring" readonly="yes">
      <desc>
        Login user name supplied by the client.
      </desc>
    </attribute>

    <attribute name="domain" type="wstring" readonly="yes">
      <desc>
        Login domain name supplied by the client.
      </desc>
    </attribute>

    <attribute name="clientName" type="wstring" readonly="yes">
      <desc>
        The client name supplied by the client.
      </desc>
    </attribute>

    <attribute name="clientIP" type="wstring" readonly="yes">
      <desc>
        The IP address of the client.
      </desc>
    </attribute>

    <attribute name="clientVersion" type="unsigned long" readonly="yes">
      <desc>
        The client software version number.
      </desc>
    </attribute>

    <attribute name="encryptionStyle" type="unsigned long" readonly="yes">
      <desc>
        Public key exchange method used when connection was established.
        Values: 0 - RDP4 public key exchange scheme.
        1 - X509 certificates were sent to client.
      </desc>
    </attribute>

  </interface>

  <interface
     name="IConsole" extends="$unknown"
     uuid="6375231a-c17c-464b-92cb-ae9e128d71c3"
     wsmap="managed"
     >
    <desc>
      The IConsole interface represents an interface to control virtual
      machine execution.

      The console object that implements the IConsole interface is obtained
      from a session object after the session for the given machine has been
      opened using one of <link to="IVirtualBox::openSession"/>,
      <link to="IVirtualBox::openRemoteSession"/> or
      <link to="IVirtualBox::openExistingSession"/> methods.

      Methods of the IConsole interface allow the caller to query the current
      virtual machine execution state, pause the machine or power it down, save
      the machine state or take a snapshot, attach and detach removable media
      and so on.

      <see>ISession</see>
    </desc>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>
        Machine object this console is sessioned with.
        <note>
          This is a convenience property, it has the same value as
          <link to="ISession::machine"/> of the corresponding session
          object.
        </note>
      </desc>
    </attribute>

    <attribute name="state" type="MachineState" readonly="yes">
      <desc>
        Current execution state of the machine.
        <note>
          This property always returns the same value as the corresponding
          property of the IMachine object this console is sessioned with.
          For the process that owns (executes) the VM, this is the
          preferable way of querying the VM state, because no IPC
          calls are made.
        </note>
      </desc>
    </attribute>

    <attribute name="guest" type="IGuest" readonly="yes">
      <desc>Guest object.</desc>
    </attribute>

    <attribute name="keyboard" type="IKeyboard" readonly="yes">
      <desc>
        Virtual keyboard object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="mouse" type="IMouse" readonly="yes">
      <desc>
        Virtual mouse object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="display" type="IDisplay" readonly="yes">
      <desc>Virtual display object.
        <note>
          If the machine is not running, any attempt to use
          the returned object will result in an error.
        </note>
      </desc>
    </attribute>

    <attribute name="debugger" type="IMachineDebugger" readonly="yes">
      <desc>Debugging interface.</desc>
    </attribute>

    <attribute name="USBDevices" type="IUSBDevice" readonly="yes" safearray="yes">
      <desc>
        Collection of USB devices currently attached to the virtual
        USB controller.
        <note>
          The collection is empty if the machine is not running.
        </note>
      </desc>
    </attribute>

    <attribute name="remoteUSBDevices" type="IHostUSBDevice" readonly="yes" safearray="yes">
      <desc>
        List of USB devices currently attached to the remote VRDP client.
        Once a new device is physically attached to the remote host computer,
        it appears in this list and remains there until detached.
      </desc>
    </attribute>

    <attribute name="sharedFolders" type="ISharedFolder" readonly="yes" safearray="yes">
      <desc>
        Collection of shared folders for the current session.  These folders
        are called transient shared folders because they are available to the
        guest OS running inside the associated virtual machine only for the
        duration of the session (as opposed to
        <link to="IMachine::sharedFolders"/> which represent permanent shared
        folders). When the session is closed (e.g. the machine is powered down),
        these folders are automatically discarded.

        New shared folders are added to the collection using
        <link to="#createSharedFolder"/>. Existing shared folders can be
        removed using <link to="#removeSharedFolder"/>.
      </desc>
    </attribute>

    <attribute name="remoteDisplayInfo" type="IRemoteDisplayInfo" readonly="yes">
      <desc>
        Interface that provides information on Remote Display (VRDP) connection.
      </desc>
    </attribute>

    <method name="powerUp">
      <desc>
        Starts the virtual machine execution using the current machine
        state (that is, its current execution state, current settings and
        current storage devices).

        If the machine is powered off or aborted, the execution will
        start from the beginning (as if the real hardware were just
        powered on).

        If the machine is in the <link to="MachineState_Saved"/> state,
        it will continue its execution the point where the state has
        been saved.

        If the machine <link to="IMachine::teleporterEnabled"/> property is
        enabled on the machine being powered up, the machine will wait for an
        incoming teleportation in the <link to="MachineState_TeleportingIn"/>
        state. The returned progress object will have at least three
        operations where the last three are defined as: (1) powering up and
        starting TCP server, (2) waiting for incoming teleportations, and
        (3) perform teleportation. These operations will be reflected as the
        last three operations of the progress objected returned by
        <link to="IVirtualBox::openRemoteSession"/> as well.

        <note>
          Unless you are trying to write a new VirtualBox front-end that
          performs direct machine execution (like the VirtualBox or VBoxSDL
          front-ends), don't call <link to="IConsole::powerUp"/> in a direct
          session opened by <link to="IVirtualBox::openSession"/> and use this
          session only to change virtual machine settings. If you simply want to
          start virtual machine execution using one of the existing front-ends
          (for example the VirtualBox GUI or headless server), simply use
          <link to="IVirtualBox::openRemoteSession"/>; these front-ends will
          power up the machine automatically for you.
        </note>

        <see>#saveState</see>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine already running.
        </result>
        <result name="VBOX_E_HOST_ERROR">
          Host interface does not exist or name not set.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Invalid saved state file.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="powerUpPaused">
      <desc>
        Identical to powerUp except that the VM will enter the
        <link to="MachineState_Paused"/> state, instead of
        <link to="MachineState_Running"/>.

        <see>#powerUp</see>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine already running.
        </result>
        <result name="VBOX_E_HOST_ERROR">
          Host interface does not exist or name not set.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Invalid saved state file.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="powerDown">
      <desc>
        Initiates the power down procedure to stop the virtual machine
        execution.

        The completion of the power down procedure is tracked using the returned
        IProgress object. After the operation is complete, the machine will go
        to the PoweredOff state.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine must be Running, Paused or Stuck to be powered down.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="reset">
      <desc>Resets the virtual machine.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Virtual machine error in reset operation.
        </result>
      </desc>
    </method>

    <method name="pause">
      <desc>Pauses the virtual machine execution.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Virtual machine error in suspend operation.
        </result>
      </desc>
    </method>

    <method name="resume">
      <desc>Resumes the virtual machine execution.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Paused state.
        </result>
        <result name="VBOX_E_VM_ERROR">
          Virtual machine error in resume operation.
        </result>
      </desc>
    </method>

    <method name="powerButton">
      <desc>Sends the ACPI power button event to the guest.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Controlled power off failed.
        </result>
      </desc>
    </method>

    <method name="sleepButton">
      <desc>Sends the ACPI sleep button event to the guest.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Sending sleep button event failed.
        </result>
      </desc>
    </method>

    <method name="getPowerButtonHandled">
      <desc>Checks if the last power button event was handled by guest.
        <result name="VBOX_E_PDM_ERROR">
          Checking if the event was handled by the guest OS failed.
        </result>
      </desc>
      <param name="handled" type="boolean" dir="return"/>
    </method>

    <method name="getGuestEnteredACPIMode">
      <desc>Checks if the guest entered the ACPI mode G0 (working) or
        G1 (sleeping). If this method returns @c false, the guest will
        most likely not respond to external ACPI events.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in Running state.
        </result>
      </desc>
      <param name="entered" type="boolean" dir="return"/>
    </method>

    <method name="saveState">
      <desc>
        Saves the current execution state of a running virtual machine
        and stops its execution.

        After this operation completes, the machine will go to the
        Saved state. Next time it is powered up, this state will
        be restored and the machine will continue its execution from
        the place where it was saved.

        This operation differs from taking a snapshot to the effect
        that it doesn't create new differencing media. Also, once
        the machine is powered up from the state saved using this method,
        the saved state is deleted, so it will be impossible to return
        to this state later.

        <note>
          On success, this method implicitly calls
          <link to="IMachine::saveSettings"/> to save all current machine
          settings (including runtime changes to the DVD medium, etc.).
          Together with the impossibility to change any VM settings when it is
          in the Saved state, this guarantees adequate hardware
          configuration of the machine when it is restored from the saved
          state file.
        </note>

        <note>
          The machine must be in the Running or Paused state, otherwise
          the operation will fail.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state neither Running nor Paused.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Failed to create directory for saved state file.
        </result>

        <see><link to="#takeSnapshot"/></see>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="adoptSavedState">
      <desc>
        Associates the given saved state file to the virtual machine.

        On success, the machine will go to the Saved state. Next time it is
        powered up, it will be restored from the adopted saved state and
        continue execution from the place where the saved state file was
        created.

        The specified saved state file path may be absolute or relative to the
        folder the VM normally saves the state to (usually,
        <link to="IMachine::snapshotFolder"/>).

        <note>
          It's a caller's responsibility to make sure the given saved state
          file is compatible with the settings of this virtual machine that
          represent its virtual hardware (memory size, storage disk configuration
          etc.). If there is a mismatch, the behavior of the virtual machine
          is undefined.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state neither PoweredOff nor Aborted.
        </result>
      </desc>
      <param name="savedStateFile" type="wstring" dir="in">
        <desc>Path to the saved state file to adopt.</desc>
      </param>
    </method>

    <method name="forgetSavedState">
      <desc>
        Forgets the saved state of the virtual machine previously created
        by <link to="#saveState"/>. Next time the machine is powered up, a
        clean boot will occur. If @a remove is @c true the saved state file
        is deleted.
        <note>
          This operation is equivalent to resetting or powering off
          the machine without doing a proper shutdown in the guest OS.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not in state Saved.
        </result>
      </desc>
      <param name="remove" type="boolean" dir="in">
        <desc>If @c true remove the saved state file.</desc>
      </param>
    </method>

    <method name="getDeviceActivity">
      <desc>
        Gets the current activity type of a given device or device group.
        <result name="E_INVALIDARG">
          Invalid device type.
        </result>
      </desc>
      <param name="type" type="DeviceType" dir="in"/>
      <param name="activity" type="DeviceActivity" dir="return"/>
    </method>

    <method name="attachUSBDevice">
      <desc>
        Attaches a host USB device with the given UUID to the
        USB controller of the virtual machine.

        The device needs to be in one of the following states:
        <link to="USBDeviceState_Busy"/>,
        <link to="USBDeviceState_Available"/> or
        <link to="USBDeviceState_Held"/>,
        otherwise an error is immediately returned.

        When the device state is
        <link to="USBDeviceState_Busy">Busy</link>, an error may also
        be returned if the host computer refuses to release it for some reason.

        <see>IUSBController::deviceFilters, USBDeviceState</see>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine state neither Running nor Paused.
        </result>
        <result name="VBOX_E_PDM_ERROR">
          Virtual machine does not have a USB controller.
        </result>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the host USB device to attach.</desc>
      </param>
    </method>

    <method name="detachUSBDevice">
      <desc>
        Detaches an USB device with the given UUID from the USB controller
        of the virtual machine.

        After this method succeeds, the VirtualBox server re-initiates
        all USB filters as if the device were just physically attached
        to the host, but filters of this machine are ignored to avoid
        a possible automatic re-attachment.

        <see>IUSBController::deviceFilters, USBDeviceState</see>

        <result name="VBOX_E_PDM_ERROR">
          Virtual machine does not have a USB controller.
        </result>
        <result name="E_INVALIDARG">
          USB device not attached to this virtual machine.
        </result>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the USB device to detach.</desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Detached USB device.</desc>
      </param>
    </method>

    <method name="findUSBDeviceByAddress">
      <desc>
        Searches for a USB device with the given host address.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c name does not correspond to any USB device.
        </result>

        <see>IUSBDevice::address</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Address of the USB device (as assigned by the host) to
          search for.
        </desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="findUSBDeviceById">
      <desc>
        Searches for a USB device with the given UUID.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c id does not correspond to any USB device.
        </result>

        <see>IUSBDevice::id</see>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the USB device to search for.</desc>
      </param>
      <param name="device" type="IUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="createSharedFolder">
      <desc>
        Creates a transient new shared folder by associating the given logical
        name with the given host path, adds it to the collection of shared
        folders and starts sharing it. Refer to the description of
        <link to="ISharedFolder"/> to read more about logical names.

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine in Saved state or currently changing state.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Shared folder already exists or not accessible.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Unique logical name of the shared folder.</desc>
      </param>
      <param name="hostPath" type="wstring" dir="in">
        <desc>Full path to the shared folder in the host file system.</desc>
      </param>
      <param name="writable" type="boolean" dir="in">
        <desc>Whether the share is writable or readonly</desc>
      </param>
    </method>

    <method name="removeSharedFolder">
      <desc>
        Removes a transient shared folder with the given name previously
        created by <link to="#createSharedFolder"/> from the collection of
        shared folders and stops sharing it.
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine in Saved state or currently changing state.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Shared folder does not exists.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Logical name of the shared folder to remove.</desc>
      </param>
    </method>

    <method name="takeSnapshot">
      <desc>
        Saves the current execution state
        and all settings of the machine and creates differencing images
        for all normal (non-independent) media.
        See <link to="ISnapshot" /> for an introduction to snapshots.

        This method can be called for a PoweredOff, Saved (see
        <link to="#saveState"/>), Running or
        Paused virtual machine. When the machine is PoweredOff, an
        offline snapshot is created. When the machine is Running a live
        snapshot is created, and an online snapshot is is created when Paused.

        The taken snapshot is always based on the
        <link to="IMachine::currentSnapshot">current snapshot</link>
        of the associated virtual machine and becomes a new current snapshot.

        <note>
          This method implicitly calls <link to="IMachine::saveSettings"/> to
          save all current machine settings before taking an offline snapshot.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine currently changing state.
        </result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Short name for the snapshot.</desc>
      </param>
      <param name="description" type="wstring" dir="in">
        <desc>Optional description of the snapshot.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="deleteSnapshot">
      <desc>
        Starts deleting the specified snapshot asynchronously.
        See <link to="ISnapshot" /> for an introduction to snapshots.

        The execution state and settings of the associated machine stored in
        the snapshot will be deleted. The contents of all differencing media of
        this snapshot will be merged with the contents of their dependent child
        media to keep the medium chain valid (in other words, all changes
        represented by media being deleted will be propagated to their child
        medium). After that, this snapshot's differencing medium will be
        deleted. The parent of this snapshot will become a new parent for all
        its child snapshots.

        If the deleted snapshot is the current one, its parent snapshot will
        become a new current snapshot. The current machine state is not directly
        affected in this case, except that currently attached differencing
        media based on media of the deleted snapshot will be also merged as
        described above.

        If the deleted snapshot is the first or current snapshot, then the
        respective IMachine attributes will be adjusted. Deleting the current
        snapshot will also implicitly call <link to="IMachine::saveSettings"/>
        to make all current machine settings permanent.

        Deleting a snapshot has the following preconditions:

        <ul>
          <li>Child media of all normal media of the deleted snapshot
            must be accessible (see <link to="IMedium::state"/>) for this
            operation to succeed.  In particular, this means that all virtual
            machines, whose media are directly or indirectly based on the
            media of deleted snapshot, must be powered off.</li>

          <li>You cannot delete the snapshot if a medium attached to it has
          more than once child medium (differencing images) because otherwise
          merging would be impossible. This might be the case if there is
          more than one child snapshot or differencing images were created
          for other reason (e.g. implicitly because of multiple machine
          attachments).</li>
        </ul>


        The virtual machine's <link to="IMachine::state">state</link> is changed to "DeletingSnapshot"
        while this operation is in progress.

        <note>
          Merging medium contents can be very time and disk space
          consuming, if these media are big in size and have many
          children. However, if the snapshot being deleted is the last
          (head) snapshot on the branch, the operation will be rather
          quick.
        </note>
        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is running.
        </result>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the snapshot to delete.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="restoreSnapshot">
      <desc>
        Starts resetting the machine's current state to the state contained
        in the given snapshot, asynchronously. All current settings of the
        machine will be reset and changes stored in differencing media
        will be lost.
        See <link to="ISnapshot" /> for an introduction to snapshots.

        After this operation is successfully completed, new empty differencing
        media are created for all normal media of the machine.

        If the given snapshot is an online snapshot, the machine will go to
        the <link to="MachineState_Saved"> saved state</link>, so that the
        next time it is powered on, the execution state will be restored
        from the state of the snapshot.

        <note>
          The machine must not be running, otherwise the operation will fail.
        </note>

        <note>
          If the machine state is <link to="MachineState_Saved">Saved</link>
          prior to this operation, the saved state file will be implicitly
          deleted (as if <link to="IConsole::forgetSavedState"/> were
          called).
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is running.
        </result>
      </desc>
      <param name="snapshot" type="ISnapshot" dir="in">
        <desc>The snapshot to restore the VM state from.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="teleport">
      <desc>
        Teleport the VM to a different host machine or process.

        TODO explain the details.

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine not running or paused.
        </result>
      </desc>
      <param name="hostname" type="wstring" dir="in">
        <desc>The name or IP of the host to teleport to.</desc>
      </param>
      <param name="tcpport" type="unsigned long" dir="in">
        <desc>The TCP port to connect to (1..65535).</desc>
      </param>
      <param name="password" type="wstring" dir="in">
        <desc>The password.</desc>
      </param>
      <param name="maxDowntime" type="unsigned long" dir="in">
        <desc>
          The maximum allowed downtime given as milliseconds.  0 is not a valid
          value.  Recommended value: 250 ms.

          The higher the value is, the greater the chance for a successful
          teleportation.  A small value may easily result in the teleportation
          process taking hours and eventually fail.

          <note>
            The current implementation treats this a guideline, not as an
            absolute rule.
          </note>
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="registerCallback">
      <desc>
        Registers a new console callback on this instance. The methods of the
        callback interface will be called by this instance when the appropriate
        event occurs.
      </desc>
      <param name="callback" type="IConsoleCallback" dir="in"/>
    </method>

    <method name="unregisterCallback">
      <desc>
        Unregisters the console callback previously registered using
        <link to="#registerCallback"/>.
        <result name="E_INVALIDARG">
          Given @a callback handler is not registered.
        </result>
      </desc>
      <param name="callback" type="IConsoleCallback" dir="in"/>
    </method>
  </interface>

  <!--
  // IHost
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="HostNetworkInterfaceMediumType"
    uuid="1aa54aaf-2497-45a2-bfb1-8eb225e93d5b"
  >
    <desc>
      Type of encapsulation. Ethernet encapsulation includes both wired and
      wireless Ethernet connections.
      <see>IHostNetworkInterface</see>
    </desc>

    <const name="Unknown" value="0">
      <desc>
        The type of interface cannot be determined.
      </desc>
    </const>
    <const name="Ethernet" value="1">
      <desc>
        Ethernet frame encapsulation.
      </desc>
    </const>
    <const name="PPP" value="2">
      <desc>
        Point-to-point protocol encapsulation.
      </desc>
    </const>
    <const name="SLIP" value="3">
      <desc>
        Serial line IP encapsulation.
      </desc>
    </const>
  </enum>

  <enum
    name="HostNetworkInterfaceStatus"
    uuid="CC474A69-2710-434B-8D99-C38E5D5A6F41"
  >
    <desc>
      Current status of the interface.
      <see>IHostNetworkInterface</see>
    </desc>

    <const name="Unknown" value="0">
      <desc>
        The state of interface cannot be determined.
      </desc>
    </const>
    <const name="Up" value="1">
      <desc>
        The interface is fully operational.
      </desc>
    </const>
    <const name="Down" value="2">
      <desc>
        The interface is not functioning.
      </desc>
    </const>
  </enum>

  <enum
    name="HostNetworkInterfaceType"
    uuid="67431b00-9946-48a2-bc02-b25c5919f4f3"
  >
    <desc>
      Network interface type.
    </desc>
    <const name="Bridged"               value="1"/>
    <const name="HostOnly"              value="2"/>
  </enum>

  <interface
     name="IHostNetworkInterface" extends="$unknown"
     uuid="ce6fae58-7642-4102-b5db-c9005c2320a8"
     wsmap="managed"
     >
    <desc>
      Represents one of host's network interfaces. IP V6 address and network
      mask are strings of 32 hexdecimal digits grouped by four. Groups are
      separated by colons.
      For example, fe80:0000:0000:0000:021e:c2ff:fed2:b030.
    </desc>
    <attribute name="name" type="wstring" readonly="yes">
      <desc>Returns the host network interface name.</desc>
    </attribute>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>Returns the interface UUID.</desc>
    </attribute>

    <attribute name="networkName" type="wstring" readonly="yes">
      <desc>Returns the name of a virtual network the interface gets attached to.</desc>
    </attribute>

    <attribute name="dhcpEnabled" type="boolean" readonly="yes">
      <desc>Specifies whether the DHCP is enabled for the interface.</desc>
    </attribute>

    <attribute name="IPAddress" type="wstring" readonly="yes">
      <desc>Returns the IP V4 address of the interface.</desc>
    </attribute>

    <attribute name="networkMask" type="wstring" readonly="yes">
      <desc>Returns the network mask of the interface.</desc>
    </attribute>

    <attribute name="IPV6Supported" type="boolean" readonly="yes">
      <desc>Specifies whether the IP V6 is supported/enabled for the interface.</desc>
    </attribute>

    <attribute name="IPV6Address" type="wstring" readonly="yes">
      <desc>Returns the IP V6 address of the interface.</desc>
    </attribute>

    <attribute name="IPV6NetworkMaskPrefixLength" type="unsigned long" readonly="yes">
      <desc>Returns the length IP V6 network mask prefix of the interface.</desc>
    </attribute>

    <attribute name="hardwareAddress" type="wstring" readonly="yes">
      <desc>Returns the hardware address. For Ethernet it is MAC address.</desc>
    </attribute>

    <attribute name="mediumType" type="HostNetworkInterfaceMediumType" readonly="yes">
      <desc>Type of protocol encapsulation used.</desc>
    </attribute>

    <attribute name="status" type="HostNetworkInterfaceStatus" readonly="yes">
      <desc>Status of the interface.</desc>
    </attribute>

    <attribute name="interfaceType" type="HostNetworkInterfaceType" readonly="yes">
      <desc>specifies the host interface type.</desc>
    </attribute>

    <method name="enableStaticIpConfig">
      <desc>sets and enables the static IP V4 configuration for the given interface.</desc>
      <param name="IPAddress" type="wstring" dir="in">
        <desc>
          IP address.
        </desc>
      </param>
      <param name="networkMask" type="wstring" dir="in">
        <desc>
          network mask.
        </desc>
      </param>
    </method>

    <method name="enableStaticIpConfigV6">
      <desc>sets and enables the static IP V6 configuration for the given interface.</desc>
      <param name="IPV6Address" type="wstring" dir="in">
        <desc>
          IP address.
        </desc>
      </param>
      <param name="IPV6NetworkMaskPrefixLength" type="unsigned long" dir="in">
        <desc>
          network mask.
        </desc>
      </param>
    </method>

    <method name="enableDynamicIpConfig">
      <desc>enables the dynamic IP configuration.</desc>
    </method>

    <method name="dhcpRediscover">
      <desc>refreshes the IP configuration for dhcp-enabled interface.</desc>
    </method>

  </interface>

  <interface
     name="IHost" extends="$unknown"
     uuid="35b004f4-7806-4009-bfa8-d1308adba7e5"
     wsmap="managed"
     >
    <desc>
      The IHost interface represents the physical machine that this VirtualBox
      installation runs on.

      An object implementing this interface is returned by the
      <link to="IVirtualBox::host" /> attribute. This interface contains
      read-only information about the host's physical hardware (such as what
      processors and disks are available, what the host operating system is,
      and so on) and also allows for manipulating some of the host's hardware,
      such as global USB device filters and host interface networking.

    </desc>
    <attribute name="DVDDrives" type="IMedium" readonly="yes" safearray="yes">
      <desc>List of DVD drives available on the host.</desc>
    </attribute>

    <attribute name="floppyDrives" type="IMedium" readonly="yes" safearray="yes">
      <desc>List of floppy drives available on the host.</desc>
    </attribute>

    <attribute name="USBDevices" type="IHostUSBDevice" readonly="yes" safearray="yes">
      <desc>
        List of USB devices currently attached to the host.
        Once a new device is physically attached to the host computer,
        it appears in this list and remains there until detached.

        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>
      </desc>
    </attribute>

    <attribute name="USBDeviceFilters" type="IHostUSBDeviceFilter" readonly="yes" safearray="yes">
      <desc>
        List of USB device filters in action.
        When a new device is physically attached to the host computer,
        filters from this list are applied to it (in order they are stored
        in the list). The first matched filter will determine the
        <link to="IHostUSBDeviceFilter::action">action</link>
        performed on the device.

        Unless the device is ignored by these filters, filters of all
        currently running virtual machines
        (<link to="IUSBController::deviceFilters"/>) are applied to it.

        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see>IHostUSBDeviceFilter, USBDeviceState</see>
      </desc>
    </attribute>

    <attribute name="networkInterfaces" type="IHostNetworkInterface" safearray="yes" readonly="yes">
      <desc>List of host network interfaces currently defined on the host.</desc>
    </attribute>

    <attribute name="processorCount" type="unsigned long" readonly="yes">
      <desc>Number of (logical) CPUs installed in the host system.</desc>
    </attribute>

    <attribute name="processorOnlineCount" type="unsigned long" readonly="yes">
      <desc>Number of (logical) CPUs online in the host system.</desc>
    </attribute>

    <attribute name="processorCoreCount" type="unsigned long" readonly="yes">
      <desc>Number of physical processor cores installed in the host system.</desc>
    </attribute>

    <method name="getProcessorSpeed">
      <desc>Query the (approximate) maximum speed of a specified host CPU in
        Megahertz.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>
          Identifier of the CPU.
        </desc>
      </param>
      <param name="speed" type="unsigned long" dir="return">
        <desc>
          Speed value. 0 is returned if value is not known or @a cpuId is
          invalid.
        </desc>
      </param>
    </method>

    <method name="getProcessorFeature">
      <desc>Query whether a CPU feature is supported or not.</desc>
      <param name="feature" type="ProcessorFeature" dir="in">
        <desc>
          CPU Feature identifier.
        </desc>
      </param>
      <param name="supported" type="boolean" dir="return">
        <desc>
          Feature is supported or not.
        </desc>
      </param>
    </method>

    <method name="getProcessorDescription">
      <desc>Query the model string of a specified host CPU.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>
          Identifier of the CPU.
          <note>
            The current implementation might not necessarily return the
            description for this exact CPU.
          </note>
        </desc>
      </param>
      <param name="description" type="wstring" dir="return">
        <desc>
          Model string. An empty string is returned if value is not known or
          @a cpuId is invalid.
        </desc>
      </param>
    </method>

    <method name="getProcessorCPUIDLeaf">
      <desc>
        Returns the CPU cpuid information for the specified leaf.
      </desc>
      <param name="cpuId" type="unsigned long" dir="in">
        <desc>
          Identifier of the CPU.  The CPU most be online.
          <note>
            The current implementation might not necessarily return the
            description for this exact CPU.
          </note>
        </desc>
      </param>
      <param name="leaf" type="unsigned long" dir="in">
        <desc>
          CPUID leaf index (eax).
        </desc>
      </param>
      <param name="subLeaf" type="unsigned long" dir="in">
        <desc>
          CPUID leaf sub index (ecx).  This currently only applies to cache
          information on Intel CPUs.  Use 0 if retriving values for
          <link to="IMachine::setCPUIDLeaf"/>.
        </desc>
      </param>
      <param name="valEax" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register eax.
        </desc>
      </param>
      <param name="valEbx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register ebx.
        </desc>
      </param>
      <param name="valEcx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register ecx.
        </desc>
      </param>
      <param name="valEdx" type="unsigned long" dir="out">
        <desc>
          CPUID leaf value for register edx.
        </desc>
      </param>
    </method>

    <attribute name="memorySize" type="unsigned long" readonly="yes">
      <desc>Amount of system memory in megabytes installed in the host system.</desc>
    </attribute>

    <attribute name="memoryAvailable" type="unsigned long" readonly="yes">
      <desc>Available system memory in the host system.</desc>
    </attribute>

    <attribute name="operatingSystem" type="wstring" readonly="yes">
      <desc>Name of the host system's operating system.</desc>
    </attribute>

    <attribute name="OSVersion" type="wstring" readonly="yes">
      <desc>Host operating system's version string.</desc>
    </attribute>

    <attribute name="UTCTime" type="long long" readonly="yes">
      <desc>Returns the current host time in milliseconds since 1970-01-01 UTC.</desc>
    </attribute>

    <attribute name="Acceleration3DAvailable" type="boolean" readonly="yes">
      <desc>Returns @c true when the host supports 3D hardware acceleration.</desc>
    </attribute>

    <method name="createHostOnlyNetworkInterface">
      <desc>
        Creates a new adapter for Host Only Networking.
        <result name="E_INVALIDARG">
          Host network interface @a name already exists.
        </result>
      </desc>
      <param name="hostInterface" type="IHostNetworkInterface" dir="out">
        <desc>
          Created host interface object.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Progress object to track the operation completion.
        </desc>
      </param>
    </method>

    <method name="removeHostOnlyNetworkInterface">
      <desc>
        Removes the given Host Only Networking interface.
        <result name="VBOX_E_OBJECT_NOT_FOUND">
          No host network interface matching @a id found.
        </result>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>
          Adapter GUID.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>
          Progress object to track the operation completion.
        </desc>
      </param>
    </method>

    <method name="createUSBDeviceFilter">
      <desc>
        Creates a new USB device filter. All attributes except
        the filter name are set to empty (any match),
        <i>active</i> is @c false (the filter is not active).

        The created filter can be added to the list of filters using
        <link to="#insertUSBDeviceFilter"/>.

        <see>#USBDeviceFilters</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Filter name. See <link to="IHostUSBDeviceFilter::name"/>
          for more info.
        </desc>
      </param>
      <param name="filter" type="IHostUSBDeviceFilter" dir="return">
        <desc>Created filter object.</desc>
      </param>
    </method>

    <method name="insertUSBDeviceFilter">
      <desc>
        Inserts the given USB device to the specified position
        in the list of filters.

        Positions are numbered starting from @c 0. If the specified
        position is equal to or greater than the number of elements in
        the list, the filter is added at the end of the collection.

        <note>
          Duplicates are not allowed, so an attempt to insert a
          filter already in the list is an error.
        </note>
        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see>#USBDeviceFilters</see>

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          USB device filter is not created within this VirtualBox instance.
        </result>
        <result name="E_INVALIDARG">
          USB device filter already in list.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to insert the filter to.</desc>
      </param>
      <param name="filter" type="IHostUSBDeviceFilter" dir="in">
        <desc>USB device filter to insert.</desc>
      </param>
    </method>

    <method name="removeUSBDeviceFilter">
      <desc>
        Removes a USB device filter from the specified position in the
        list of filters.

        Positions are numbered starting from @c 0. Specifying a
        position equal to or greater than the number of elements in
        the list will produce an error.

        <note>
          If USB functionality is not available in the given edition of
          VirtualBox, this method will set the result code to @c E_NOTIMPL.
        </note>

        <see>#USBDeviceFilters</see>

        <result name="E_INVALIDARG">
          USB device filter list empty or invalid @a position.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to remove the filter from.</desc>
      </param>
    </method>

    <method name="findHostDVDDrive">
      <desc>
        Searches for a host DVD drive with the given @c name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c name does not correspond to any host drive.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host drive to search for</desc>
      </param>
      <param name="drive" type="IMedium" dir="return">
        <desc>Found host drive object</desc>
      </param>
    </method>

    <method name="findHostFloppyDrive">
      <desc>
        Searches for a host floppy drive with the given @c name.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c name does not correspond to any host floppy drive.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host floppy drive to search for</desc>
      </param>
      <param name="drive" type="IMedium" dir="return">
        <desc>Found host floppy drive object</desc>
      </param>
    </method>

    <method name="findHostNetworkInterfaceByName">
      <desc>
        Searches through all host network interfaces for an interface with
        the given @c name.
        <note>
          The method returns an error if the given @c name does not
          correspond to any host network interface.
        </note>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the host network interface to search for.</desc>
      </param>
      <param name="networkInterface" type="IHostNetworkInterface" dir="return">
        <desc>Found host network interface object.</desc>
      </param>
    </method>
    <method name="findHostNetworkInterfaceById">
      <desc>
        Searches through all host network interfaces for an interface with
        the given GUID.
        <note>
          The method returns an error if the given GUID does not
          correspond to any host network interface.
        </note>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>GUID of the host network interface to search for.</desc>
      </param>
      <param name="networkInterface" type="IHostNetworkInterface" dir="return">
        <desc>Found host network interface object.</desc>
      </param>
    </method>
    <method name="findHostNetworkInterfacesOfType">
      <desc>
        Searches through all host network interfaces and returns a list of interfaces of the specified type
      </desc>
      <param name="type" type="HostNetworkInterfaceType" dir="in">
        <desc>type of the host network interfaces to search for.</desc>
      </param>
      <param name="networkInterfaces" type="IHostNetworkInterface" safearray="yes" dir="return">
        <desc>Found host network interface objects.</desc>
      </param>
    </method>

    <method name="findUSBDeviceById">
      <desc>
        Searches for a USB device with the given UUID.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c id does not correspond to any USB device.
        </result>

        <see>IHostUSBDevice::id</see>
      </desc>
      <param name="id" type="uuid" mod="string" dir="in">
        <desc>UUID of the USB device to search for.</desc>
      </param>
      <param name="device" type="IHostUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

    <method name="findUSBDeviceByAddress">
      <desc>
        Searches for a USB device with the given host address.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Given @c name does not correspond to any USB device.
        </result>

        <see>IHostUSBDevice::address</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Address of the USB device (as assigned by the host) to
          search for.
        </desc>
      </param>
      <param name="device" type="IHostUSBDevice" dir="return">
        <desc>Found USB device object.</desc>
      </param>
    </method>

  </interface>

  <!--
  // ISystemProperties
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="ISystemProperties"
     extends="$unknown"
     uuid="07c3ffd8-8f59-49cc-b608-53a332e85cc3"
     wsmap="managed"
     >
    <desc>
      The ISystemProperties interface represents global properties of the given
      VirtualBox installation.

      These properties define limits and default values for various attributes
      and parameters. Most of the properties are read-only, but some can be
      changed by a user.
    </desc>

    <attribute name="minGuestRAM" type="unsigned long" readonly="yes">
      <desc>Minimum guest system memory in Megabytes.</desc>
    </attribute>

    <attribute name="maxGuestRAM" type="unsigned long" readonly="yes">
      <desc>Maximum guest system memory in Megabytes.</desc>
    </attribute>

    <attribute name="minGuestVRAM" type="unsigned long" readonly="yes">
      <desc>Minimum guest video memory in Megabytes.</desc>
    </attribute>

    <attribute name="maxGuestVRAM" type="unsigned long" readonly="yes">
      <desc>Maximum guest video memory in Megabytes.</desc>
    </attribute>

    <attribute name="minGuestCPUCount" type="unsigned long" readonly="yes">
      <desc>Minimum CPU count.</desc>
    </attribute>

    <attribute name="maxGuestCPUCount" type="unsigned long" readonly="yes">
      <desc>Maximum CPU count.</desc>
    </attribute>

    <attribute name="maxGuestMonitors" type="unsigned long" readonly="yes">
      <desc>Maximum of monitors which could be connected.</desc>
    </attribute>

    <attribute name="maxVDISize" type="unsigned long long" readonly="yes">
      <desc>Maximum size of a virtual disk image in Megabytes.</desc>
    </attribute>

    <attribute name="networkAdapterCount" type="unsigned long" readonly="yes">
      <desc>
        Number of network adapters associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="serialPortCount" type="unsigned long" readonly="yes">
      <desc>
        Number of serial ports associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="parallelPortCount" type="unsigned long" readonly="yes">
      <desc>
        Number of parallel ports associated with every
        <link to="IMachine"/> instance.
      </desc>
    </attribute>

    <attribute name="maxBootPosition" type="unsigned long" readonly="yes">
      <desc>
        Maximum device position in the boot order. This value corresponds
        to the total number of devices a machine can boot from, to make it
        possible to include all possible devices to the boot list.
        <see><link to="IMachine::setBootOrder"/></see>
      </desc>
    </attribute>

    <attribute name="defaultMachineFolder" type="wstring">
      <desc>
        Full path to the default directory used to create new or open
        existing machines when a settings file name contains no
        path.

        The initial value of this property is
        <tt>&lt;</tt><link to="IVirtualBox::homeFolder">
          VirtualBox_home</link><tt>&gt;/Machines</tt>.

        <note>
          Setting this property to @c null or an empty string will restore the
          initial value.
        </note>
        <note>
          When settings this property, the specified path can be
          absolute (full path) or relative
          to the <link to="IVirtualBox::homeFolder">
            VirtualBox home directory</link>.
          When reading this property, a full path is
          always returned.
        </note>
        <note>
          The specified path may not exist, it will be created
          when necessary.
        </note>

        <see>
          <link to="IVirtualBox::createMachine"/>,
          <link to="IVirtualBox::openMachine"/>
        </see>
      </desc>
    </attribute>

    <attribute name="defaultHardDiskFolder" type="wstring">
      <desc>
        Full path to the default directory used to create new or open existing
        virtual disks.

        This path is used when the storage unit of a hard disk is a regular file
        in the host's file system and only a file name that contains no path is
        given.

        The initial value of this property is
        <tt>&lt;</tt>
        <link to="IVirtualBox::homeFolder">VirtualBox_home</link>
        <tt>&gt;/HardDisks</tt>.

        <note>
          Setting this property to @c null or empty string will restore the
          initial value.
        </note>
        <note>
          When settings this property, the specified path can be relative
          to the
          <link to="IVirtualBox::homeFolder">VirtualBox home directory</link> or
          absolute. When reading this property, a full path is
          always returned.
        </note>
        <note>
          The specified path may not exist, it will be created
          when necessary.
        </note>

        <see>
          IMedium,
          <link to="IVirtualBox::createHardDisk"/>,
          <link to="IVirtualBox::openHardDisk"/>,
          <link to="IMedium::location"/>
        </see>
      </desc>
    </attribute>

    <attribute name="mediumFormats" type="IMediumFormat" safearray="yes" readonly="yes">
      <desc>
        List of all medium storage formats supported by this VirtualBox
        installation.

        Keep in mind that the medium format identifier
        (<link to="IMediumFormat::id"/>) used in other API calls like
        <link to="IVirtualBox::createHardDisk"/> to refer to a particular
        medium format is a case-insensitive string. This means that, for
        example, all of the following strings:
        <pre>
          "VDI"
          "vdi"
          "VdI"</pre>
        refer to the same medium format.

        Note that the virtual medium framework is backend-based, therefore
        the list of supported formats depends on what backends are currently
        installed.

        <see>
          <link to="IMediumFormat"/>,
        </see>
      </desc>
    </attribute>

    <attribute name="defaultHardDiskFormat" type="wstring">
      <desc>
        Identifier of the default medium format used by VirtualBox.

        The medium format set by this attribute is used by VirtualBox
        when the medium format was not specified explicitly. One example is
        <link to="IVirtualBox::createHardDisk"/> with the empty
        format argument. A more complex example is implicit creation of
        differencing media when taking a snapshot of a virtual machine:
        this operation will try to use a format of the parent medium first
        and if this format does not support differencing media the default
        format specified by this argument will be used.

        The list of supported medium formats may be obtained by the
        <link  to="#mediaFormats"/> call. Note that the default medium
        format must have a capability to create differencing media;
        otherwise operations that create media implicitly may fail
        unexpectedly.

        The initial value of this property is <tt>"VDI"</tt> in the current
        version of the VirtualBox product, but may change in the future.

        <note>
          Setting this property to @c null or empty string will restore the
          initial value.
        </note>

        <see>
          <link to="#mediaFormats"/>,
          <link to="IMediumFormat::id"/>,
          <link to="IVirtualBox::createHardDisk"/>
        </see>
      </desc>
    </attribute>

    <attribute name="freeDiskSpaceWarning" type="unsigned long long">
      <desc>Issue a warning if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given size in
      Megabytes.</desc>
    </attribute>

    <attribute name="freeDiskSpacePercentWarning" type="unsigned long">
      <desc>Issue a warning if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given percentage.</desc>
    </attribute>

    <attribute name="freeDiskSpaceError" type="unsigned long long">
      <desc>Issue an error if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given size in
      Megabytes.</desc>
    </attribute>

    <attribute name="freeDiskSpacePercentError" type="unsigned long">
      <desc>Issue an error if the free disk space is below (or in some disk
      intensive operation is expected to go below) the given percentage.</desc>
    </attribute>

    <attribute name="remoteDisplayAuthLibrary" type="wstring">
      <desc>
        Library that provides authentication for VRDP clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration.

        The system library extension (".DLL" or ".so") must be omitted.
        A full path can be specified; if not, then the library must reside on the
        system's default library path.

        The default value of this property is <tt>"VRDPAuth"</tt>. There is a library
        of that name in one of the default VirtualBox library directories.

        For details about VirtualBox authentication libraries and how to implement
        them, please refer to the VirtualBox manual.

        <note>
          Setting this property to @c null or empty string will restore the
          initial value.
        </note>
      </desc>
    </attribute>

    <attribute name="webServiceAuthLibrary" type="wstring">
      <desc>
        Library that provides authentication for webservice clients. The library
        is used if a virtual machine's authentication type is set to "external"
        in the VM RemoteDisplay configuration and will be called from
        within the <link to="IWebsessionManager::logon" /> implementation.

        As opposed to <link to="ISystemProperties::remoteDisplayAuthLibrary" />,
        there is no per-VM setting for this, as the webservice is a global
        resource (if it is running). Only for this setting (for the webservice),
        setting this value to a literal <tt>"null"</tt> string disables authentication,
        meaning that <link to="IWebsessionManager::logon" /> will always succeed,
        no matter what user name and password are supplied.

        The initial value of this property is <tt>"VRDPAuth"</tt>,
        meaning that the webservice will use the same authentication
        library that is used by default for VBoxVRDP (again, see
        <link to="ISystemProperties::remoteDisplayAuthLibrary" />).
        The format and calling convention of authentication libraries
        is the same for the webservice as it is for VBoxVRDP.

        <note>
          Setting this property to @c null or empty string will restore the
          initial value.
        </note>
      </desc>
    </attribute>

    <attribute name="LogHistoryCount" type="unsigned long">
      <desc>
        This value specifies how many old release log files are kept.
       </desc>
    </attribute>

    <attribute name="defaultAudioDriver" type="AudioDriverType" readonly="yes">
      <desc>This value hold the default audio driver for the current
      system.</desc>
    </attribute>

    <method name="getMaxDevicesPerPortForStorageBus">
      <desc>Returns the maximum number of devices which can be attached to a port
      for the given storage bus.</desc>

      <param name="bus" type="StorageBus" dir="in">
        <desc>The storage bus type to get the value for.</desc>
      </param>

      <param name="maxDevicesPerPort" type="unsigned long" dir="return">
        <desc>The maximum number of devices which can eb attached to the port for the given
        storage bus.</desc>
      </param>
    </method>

    <method name="getMinPortCountForStorageBus">
      <desc>Returns the minimum number of ports the given storage bus supports.</desc>

      <param name="bus" type="StorageBus" dir="in">
        <desc>The storage bus type to get the value for.</desc>
      </param>

      <param name="minPortCount" type="unsigned long" dir="return">
        <desc>The minimum number of ports for the given storage bus.</desc>
      </param>
    </method>

    <method name="getMaxPortCountForStorageBus">
      <desc>Returns the maximum number of ports the given storage bus supports.</desc>

      <param name="bus" type="StorageBus" dir="in">
        <desc>The storage bus type to get the value for.</desc>
      </param>

      <param name="maxPortCount" type="unsigned long" dir="return">
        <desc>The maximum number of ports for the given storage bus.</desc>
      </param>
    </method>

    <method name="getMaxInstancesOfStorageBus">
      <desc>Returns the maximum number of storage bus instances which
        can be configured for each VM. This corresponds to the number of
        storage controllers one can have.</desc>

      <param name="bus" type="StorageBus" dir="in">
        <desc>The storage bus type to get the value for.</desc>
      </param>

      <param name="maxInstances" type="unsigned long" dir="return">
        <desc>The maximum number of instances for the given storage bus.</desc>
      </param>
    </method>

    <method name="getDeviceTypesForStorageBus">
      <desc>Returns list of all the supported device types
        (<link to="DeviceType"/>) for the given type of storage
        bus.</desc>

      <param name="bus" type="StorageBus" dir="in">
        <desc>The storage bus type to get the value for.</desc>
      </param>

      <param name="deviceTypes" type="DeviceType" safearray="yes" dir="return">
        <desc>The list of all supported device types for the given storage bus.</desc>
      </param>
    </method>
  </interface>

  <!--
  // IGuest
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IGuestOSType" extends="$unknown"
    uuid="e3f6727e-a09b-41ea-a824-864a176472f3"
    wsmap="struct"
  >
    <desc>
    </desc>

    <attribute name="familyId" type="wstring" readonly="yes">
      <desc>Guest OS family identifier string.</desc>
    </attribute>

    <attribute name="familyDescription" type="wstring" readonly="yes">
      <desc>Human readable description of the guest OS family.</desc>
    </attribute>

    <attribute name="id" type="wstring" readonly="yes">
      <desc>Guest OS identifier string.</desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>Human readable description of the guest OS.</desc>
    </attribute>

    <attribute name="is64Bit" type="boolean" readonly="yes">
      <desc>Returns @c true if the given OS is 64-bit</desc>
    </attribute>

    <attribute name="recommendedIOAPIC" type="boolean" readonly="yes">
      <desc>Returns @c true if IO APIC recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedVirtEx" type="boolean" readonly="yes">
      <desc>Returns @c true if VT-x or AMD-V recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedRAM" type="unsigned long" readonly="yes">
      <desc>Recommended RAM size in Megabytes.</desc>
    </attribute>

    <attribute name="recommendedVRAM" type="unsigned long" readonly="yes">
      <desc>Recommended video RAM size in Megabytes.</desc>
    </attribute>

    <attribute name="recommendedHDD" type="unsigned long" readonly="yes">
      <desc>Recommended hard disk size in Megabytes.</desc>
    </attribute>

    <attribute name="adapterType" type="NetworkAdapterType" readonly="yes">
      <desc>Returns recommended network adapter for this OS type.</desc>
    </attribute>

    <attribute name="recommendedPae" type="boolean" readonly="yes">
      <desc>Returns @c true if using PAE is recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedDvdStorageController" type="StorageControllerType" readonly="yes">
      <desc>Recommended storage controller type for DVD/CD drives.</desc>
    </attribute>

    <attribute name="recommendedDvdStorageBus" type="StorageBus" readonly="yes">
      <desc>Recommended storage bus type for DVD/CD drives.</desc>
    </attribute>

    <attribute name="recommendedHdStorageController" type="StorageControllerType" readonly="yes">
      <desc>Recommended storage controller type for HD drives.</desc>
    </attribute>

    <attribute name="recommendedHdStorageBus" type="StorageBus" readonly="yes">
      <desc>Recommended storage bus type for HD drives.</desc>
    </attribute>

    <attribute name="recommendedFirmware" type="FirmwareType" readonly="yes">
      <desc>Recommended firmware type.</desc>
    </attribute>

    <attribute name="recommendedUsbHid" type="boolean" readonly="yes">
      <desc>Returns @c true if using USB Human Interface Devices, such as keyboard and mouse recommended.</desc>
    </attribute>

     <attribute name="recommendedHpet" type="boolean" readonly="yes">
      <desc>Returns @c true if using HPET is recommended for this OS type.</desc>
    </attribute>

    <attribute name="recommendedUsbTablet" type="boolean" readonly="yes">
      <desc>Returns @c true if using a USB Tablet is recommended.</desc>
    </attribute>

    <attribute name="recommendedRtcUseUtc" type="boolean" readonly="yes">
      <desc>Returns @c true if the RTC of this VM should be set to UTC</desc>
    </attribute>

  </interface>

  <interface
     name="IGuest" extends="$unknown"
     uuid="d915dff1-ed38-495a-91f1-ab6c53932468"
     wsmap="managed"
     >
    <desc>
      The IGuest interface represents information about the operating system
      running inside the virtual machine. Used in
      <link to="IConsole::guest"/>.

      IGuest provides information about the guest operating system, whether
      Guest Additions are installed and other OS-specific virtual machine
      properties.
    </desc>

    <attribute name="OSTypeId" type="wstring" readonly="yes">
      <desc>
        Identifier of the Guest OS type as reported by the Guest
        Additions.
        You may use <link to="IVirtualBox::getGuestOSType"/> to obtain
        an IGuestOSType object representing details about the given
        Guest OS type.
        <note>
          If Guest Additions are not installed, this value will be
          the same as <link to="IMachine::OSTypeId"/>.
        </note>
      </desc>
    </attribute>

    <attribute name="additionsActive" type="boolean" readonly="yes">
      <desc>
        Flag whether the Guest Additions are installed and active
        in which case their version will be returned by the
        <link to="#additionsVersion"/> property.
      </desc>
    </attribute>

    <attribute name="additionsVersion" type="wstring" readonly="yes">
      <desc>
        Version of the Guest Additions (3 decimal numbers separated
        by dots) or empty when the Additions are not installed. The
        Additions may also report a version but yet not be active as
        the version might be refused by VirtualBox (incompatible) or
        other failures occurred.
      </desc>
    </attribute>

    <attribute name="supportsSeamless" type="boolean" readonly="yes">
      <desc>
        Flag whether seamless guest display rendering (seamless desktop
        integration) is supported.
      </desc>
    </attribute>

    <attribute name="supportsGraphics" type="boolean" readonly="yes">
      <desc>
        Flag whether the guest is in graphics mode.  If it is not, then
        seamless rendering will not work, resize hints are not immediately
        acted on and guest display resizes are probably not initiated by
        the guest additions.
      </desc>
    </attribute>

    <attribute name="memoryBalloonSize" type="unsigned long">
      <desc>Guest system memory balloon size in megabytes (transient property).</desc>
    </attribute>

    <attribute name="pageFusionEnabled" type="boolean">
      <desc>Flag whether page fusion is enabled or not.</desc>
    </attribute>

    <attribute name="statisticsUpdateInterval" type="unsigned long">
      <desc>Interval to update guest statistics in seconds.</desc>
    </attribute>

    <method name="internalGetStatistics">
      <desc>
         Internal method; do not use as it might change at any time
      </desc>
      <param name="cpuUser" type="unsigned long" dir="out">
         <desc>Percentage of processor time spent in user mode as seen by the guest</desc>
      </param>
      <param name="cpuKernel" type="unsigned long" dir="out">
         <desc>Percentage of processor time spent in kernel mode as seen by the guest</desc>
      </param>
      <param name="cpuIdle" type="unsigned long" dir="out">
         <desc>Percentage of processor time spent idling as seen by the guest</desc>
      </param>
      <param name="memTotal" type="unsigned long" dir="out">
         <desc>Total amount of physical guest RAM</desc>
      </param>
      <param name="memFree" type="unsigned long" dir="out">
         <desc>Free amount of physical guest RAM</desc>
      </param>
      <param name="memBalloon" type="unsigned long" dir="out">
         <desc>Amount of ballooned physical guest RAM</desc>
      </param>
      <param name="memShared" type="unsigned long" dir="out">
        <desc>Amount of shared physical guest RAM</desc>
      </param>
      <param name="memCache" type="unsigned long" dir="out">
         <desc>Total amount of guest (disk) cache memory</desc>
      </param>
      <param name="pagedTotal" type="unsigned long" dir="out">
         <desc>Total amount of space in the page file</desc>
      </param>
      <param name="memAllocTotal" type="unsigned long" dir="out">
         <desc>Total amount of memory allocated by the hypervisor</desc>
      </param>
      <param name="memFreeTotal" type="unsigned long" dir="out">
         <desc>Total amount of free memory available in the hypervisor</desc>
      </param>
      <param name="memBalloonTotal" type="unsigned long" dir="out">
         <desc>Total amount of memory ballooned by the hypervisor</desc>
      </param>
      <param name="memSharedTotal" type="unsigned long" dir="out">
        <desc>Total amount of shared memory in the hypervisor</desc>
      </param>
    </method>

    <method name="setCredentials">
      <desc>
        Store login credentials that can be queried by guest operating
        systems with Additions installed. The credentials are transient
        to the session and the guest may also choose to erase them. Note
        that the caller cannot determine whether the guest operating system
        has queried or made use of the credentials.

        <result name="VBOX_E_VM_ERROR">
          VMM device is not available.
        </result>

      </desc>
      <param name="userName" type="wstring" dir="in">
        <desc>User name string, can be empty</desc>
      </param>
      <param name="password" type="wstring" dir="in">
        <desc>Password string, can be empty</desc>
      </param>
      <param name="domain" type="wstring" dir="in">
        <desc>Domain name (guest logon scheme specific), can be empty</desc>
      </param>
      <param name="allowInteractiveLogon" type="boolean" dir="in">
        <desc>
          Flag whether the guest should alternatively allow the user to
          interactively specify different credentials. This flag might
          not be supported by all versions of the Additions.
        </desc>
      </param>
    </method>

    <method name="executeProcess">
      <desc>
        Executes an existing program inside the guest VM.

        <result name="VBOX_E_IPRT_ERROR">
          Could not execute process.
        </result>

      </desc>
      <param name="execName" type="wstring" dir="in">
        <desc>
          Full path name of the command to execute on the guest; the
          commands has to exists in the guest VM in order to be executed.
        </desc>
      </param>
      <param name="flags" type="unsigned long" dir="in">
        <desc>
          Execution flags - currently not supported and therefore
          has to be set to 0.
        </desc>
      </param>
      <param name="arguments" type="wstring" safearray="yes" dir="in">
        <desc>
          Array of arguments passed to the execution command.
        </desc>
      </param>
      <param name="environment" type="wstring" safearray="yes" dir="in">
        <desc>
          Environment variables that can be set while the command is being
          executed, in form of "NAME=VALUE"; one pair per entry. To unset a
          variable just set its name ("NAME") without a value.
        </desc>
      </param>
      <param name="userName" type="wstring" dir="in">
        <desc>
          User name under which the command will be executed; has to exist
          and have the appropriate rights to execute programs in the VM.
        </desc>
      </param>
      <param name="password" type="wstring" dir="in">
        <desc>
          Password of the user account specified.
        </desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          The maximum timeout value (in msec) to wait for finished program
          execution. Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="pid" type="unsigned long" dir="out">
        <desc>
          The PID (process ID) of the started command for later reference.
        </desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="getProcessOutput">
      <desc>
        Retrieves output of a formerly started process.

        <result name="VBOX_E_IPRT_ERROR">
          Could not retrieve output.
        </result>

      </desc>
      <param name="pid" type="unsigned long" dir="in">
        <desc>
          Process id returned by earlier executeProcess() call.
        </desc>
      </param>
      <param name="flags" type="unsigned long" dir="in">
        <desc>
          Flags describing which output to retrieve.
        </desc>
      </param>
      <param name="timeoutMS" type="unsigned long" dir="in">
        <desc>
          The maximum timeout value (in msec) to wait for output
          data. Pass 0 for an infinite timeout.
        </desc>
      </param>
      <param name="size" type="unsigned long long" dir="in">
        <desc>
          Size in bytes to read in the buffer.
        </desc>
      </param>
      <param name="data" type="octet" dir="return" safearray="yes">
        <desc>
          Buffer for retrieving the actual output. A data size of 0 means end of file
          if the requested size was not 0. This is the unprocessed
          output data, i.e. the line ending style depends on the platform of
          the system the server is running on.
        </desc>
      </param>
    </method>

    <method name="getProcessStatus">
      <desc>
        Retrieves status, exit code and the exit reason of a formerly started process.

        <result name="VBOX_E_IPRT_ERROR">
          Process with specified PID was not found.
        </result>

      </desc>
      <param name="pid" type="unsigned long" dir="in">
        <desc>
          Process id returned by earlier executeProcess() call.
        </desc>
      </param>
      <param name="exitcode" type="unsigned long" dir="out">
        <desc>
          The exit code (if available).
        </desc>
      </param>
      <param name="flags" type="unsigned long" dir="out">
        <desc>
          Additional flags of process status (not used at the moment).
        </desc>
      </param>
      <param name="reason" type="unsigned long" dir="return">
        <desc>
          The current process status.
        </desc>
      </param>
    </method>

  </interface>


  <!--
  // IProgress
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IProgress" extends="$unknown"
     uuid="856aa038-853f-42e2-acf7-6e7b02dbe294"
     wsmap="managed"
     >
    <desc>
        The IProgress interface is used to track and control
        asynchronous tasks within VirtualBox.

        An instance of this is returned every time VirtualBox starts
        an asynchronous task (in other words, a separate thread) which
        continues to run after a method call returns. For example,
        <link to="IConsole::saveState" />, which saves the state of
        a running virtual machine, can take a long time to complete.
        To be able to display a progress bar, a user interface such as
        the VirtualBox graphical user interface can use the IProgress
        object returned by that method.

        Note that IProgress is a "read-only" interface in the sense
        that only the VirtualBox internals behind the Main API can
        create and manipulate progress objects, whereas client code
        can only use the IProgress object to monitor a task's
        progress and, if <link to="#cancelable" /> is @c true,
        cancel the task by calling <link to="#cancel" />.

        A task represented by IProgress consists of either one or
        several sub-operations that run sequentially, one by one (see
        <link to="#operation" /> and <link to="#operationCount" />).
        Every operation is identified by a number (starting from 0)
        and has a separate description.

        You can find the individual percentage of completion of the current
        operation in <link to="#operationPercent" /> and the
        percentage of completion of the task as a whole
        in <link to="#percent" />.

        Similarly, you can wait for the completion of a particular
        operation via <link to="#waitForOperationCompletion" /> or
        for the completion of the whole task via
        <link to="#waitForCompletion" />.
    </desc>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>ID of the task.</desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>Description of the task.</desc>
    </attribute>

    <attribute name="initiator" type="$unknown" readonly="yes">
      <desc>Initiator of the task.</desc>
    </attribute>

    <attribute name="cancelable" type="boolean" readonly="yes">
      <desc>Whether the task can be interrupted.</desc>
    </attribute>

    <attribute name="percent" type="unsigned long" readonly="yes">
      <desc>
        Current progress value of the task as a whole, in percent.
        This value depends on how many operations are already complete.
        Returns 100 if <link to="#completed" /> is @c true.
      </desc>
    </attribute>

    <attribute name="timeRemaining" type="long" readonly="yes">
        <desc>
            Estimated remaining time until the task completes, in
            seconds. Returns 0 once the task has completed; returns -1
            if the remaining time cannot be computed, in particular if
            the current progress is 0.

            Even if a value is returned, the estimate will be unreliable
            for low progress values. It will become more reliable as the
            task progresses; it is not recommended to display an ETA
            before at least 20% of a task have completed.
        </desc>
    </attribute>

    <attribute name="completed" type="boolean" readonly="yes">
      <desc>Whether the task has been completed.</desc>
    </attribute>

    <attribute name="canceled" type="boolean" readonly="yes">
      <desc>Whether the task has been canceled.</desc>
    </attribute>

    <attribute name="resultCode" type="long" readonly="yes">
      <desc>
        Result code of the progress task.
        Valid only if <link to="#completed"/> is @c true.
      </desc>
    </attribute>

    <attribute name="errorInfo" type="IVirtualBoxErrorInfo" readonly="yes">
      <desc>
        Extended information about the unsuccessful result of the
        progress operation. May be @c null if no extended information
        is available.
        Valid only if <link to="#completed"/> is @c true and
        <link to="#resultCode"/> indicates a failure.
      </desc>
    </attribute>

    <attribute name="operationCount" type="unsigned long" readonly="yes">
      <desc>
          Number of sub-operations this task is divided into.
          Every task consists of at least one suboperation.
      </desc>
    </attribute>

    <attribute name="operation" type="unsigned long" readonly="yes">
        <desc>Number of the sub-operation being currently executed.</desc>
    </attribute>

    <attribute name="operationDescription" type="wstring" readonly="yes">
      <desc>
          Description of the sub-operation being currently executed.
      </desc>
    </attribute>

    <attribute name="operationPercent" type="unsigned long" readonly="yes">
        <desc>Progress value of the current sub-operation only, in percent.</desc>
    </attribute>

    <attribute name="timeout" type="unsigned long">
      <desc>
          When non-zero, this specifies the number of milliseconds after which
          the operation will automatically be canceled.  This can only be set on
          cancelable objects.
      </desc>
    </attribute>

    <method name="setCurrentOperationProgress">
      <desc>Internal method, not to be called externally.</desc>
      <param name="percent" type="unsigned long" dir="in" />
    </method>
    <method name="setNextOperation">
      <desc>Internal method, not to be called externally.</desc>
      <param name="nextOperationDescription" type="wstring" dir="in" />
      <param name="nextOperationsWeight" type="unsigned long" dir="in" />
    </method>

    <method name="waitForCompletion">
      <desc>
          Waits until the task is done (including all sub-operations)
          with a given timeout in milliseconds; specify -1 for an indefinite wait.

        <result name="VBOX_E_IPRT_ERROR">
          Failed to wait for task completion.
        </result>
      </desc>

      <param name="timeout" type="long" dir="in">
        <desc>
          Maximum time in milliseconds to wait or -1 to wait indefinitely.
        </desc>
      </param>
    </method>

    <method name="waitForOperationCompletion">
      <desc>
          Waits until the given operation is done with a given timeout in
          milliseconds; specify -1 for an indefinite wait.

        <result name="VBOX_E_IPRT_ERROR">
          Failed to wait for operation completion.
        </result>

      </desc>
      <param name="operation" type="unsigned long" dir="in">
        <desc>
          Number of the operation to wait for.
          Must be less than <link to="#operationCount"/>.
        </desc>
      </param>
      <param name="timeout" type="long" dir="in">
        <desc>
          Maximum time in milliseconds to wait or -1 to wait indefinitely.
        </desc>
      </param>
    </method>

    <method name="cancel">
      <desc>
        Cancels the task.
        <note>
          If <link to="#cancelable"/> is @c false, then this method will fail.
        </note>

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Operation cannot be canceled.
        </result>

      </desc>
    </method>

  </interface>


  <!--
  // ISnapshot
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="ISnapshot" extends="$unknown"
     uuid="1a2d0551-58a4-4107-857e-ef414fc42ffc"
     wsmap="managed"
     >
    <desc>
      The ISnapshot interface represents a snapshot of the virtual
      machine.

      Together with the differencing media that are created
      when a snapshot is taken, a machine can be brought back to
      the exact state it was in when the snapshot was taken.

      The ISnapshot interface has no methods, only attributes; snapshots
      are controlled through methods of the <link to="IConsole" /> interface
      which also manage the media associated with the snapshot.
      The following operations exist:

      <ul>
          <li><link to="IConsole::takeSnapshot"/>: creates a new snapshot
              by creating new, empty differencing images for the machine's
              media and saving the VM settings and (if the VM is running)
              the current VM state in the snapshot.

              The differencing images will then receive all data written to
              the machine's media, while their parent (base) images
              remain unmodified after the snapshot has been taken (see
              <link to="IMedium" /> for details about differencing images).
              This simplifies restoring a machine to the state of a snapshot:
              only the differencing images need to be deleted.

              The current machine state is not changed by taking a snapshot.
              If the machine is running, it will resume execution after the
              snapshot has been taken.
          </li>

          <li><link to="IConsole::restoreSnapshot"/>: this goes back to
              a previous snapshot. This resets the machine's state to that of
              the previous snapshot by deleting the differencing image of each
              of the machine's media and setting the machine's settings
              and state to the state that was saved in the snapshot (if any).

              This destroys the machine's current state.
          </li>

          <li><link to="IConsole::deleteSnapshot"/>: deletes a snapshot
              without affecting the current machine state.

              This does not change the machine, but instead frees the resources
              allocated when the snapshot was taken: the settings and machine state
              is deleted (if any), and the snapshot's differencing image for each
              of the machine's media gets merged with its parent image.

              Neither the current machine state nor other snapshots are affected
              by this operation, except that parent media will be modified
              to contain the disk data associated with the snapshot being deleted.
          </li>
      </ul>

      Each snapshot contains the settings of the virtual machine (hardware
      configuration etc.). In addition, if the machine was running when the
      snapshot was taken (<link to="IMachine::state"/> is <link to="MachineState_Running"/>),
      the current VM state is saved in the snapshot (similarly to what happens
      when a VM's state is saved). The snapshot is then said to
      be <i>online</i> because when restoring it, the VM will be running.

      If the machine is saved (<link to="MachineState_Saved"/>), the snapshot
      receives a copy of the execution state file (<link to="IMachine::stateFilePath"/>).

      Otherwise, if the machine was not running (<link to="MachineState_PoweredOff"/>
      or <link to="MachineState_Aborted"/>), the snapshot is <i>offline</i>;
      it then contains a so-called "zero execution state", representing a
      machine that is powered off.

      <h3>Snapshot branches and the "current" snapshot</h3>

      Snapshots can be chained, whereby every next snapshot is based on the
      previous one. This chaining is related to medium branching
      (see the <link to="IMedium"/> description) in that every time
      a new snapshot is created, a new differencing medium is implicitly
      created for all normal media attached to the machine.

      Each virtual machine has a "current snapshot", identified by
      <link to="IMachine::currentSnapshot"/>. Presently, this is always set
      to the last snapshot in the chain. In a future version of VirtualBox,
      it will be possible to reset a machine's current state to that of an
      earlier snapshot without deleting the current state so that it will be
      possible to create alternative snapshot paths in a snapshot tree.

      In the current implementation, multiple snapshot branches within one
      virtual machine are not allowed. Every machine has a single branch,
      and <link to="IConsole::takeSnapshot"/> operation adds a new
      snapshot to the top of that branch.
    </desc>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>UUID of the snapshot.</desc>
    </attribute>

    <attribute name="name" type="wstring">
      <desc>Short name of the snapshot.</desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>Optional description of the snapshot.</desc>
    </attribute>

    <attribute name="timeStamp" type="long long" readonly="yes">
      <desc>
        Time stamp of the snapshot, in milliseconds since 1970-01-01 UTC.
      </desc>
    </attribute>

    <attribute name="online" type="boolean" readonly="yes">
      <desc>
        @c true if this snapshot is an online snapshot and @c false otherwise.

          When this attribute is @c true, the
          <link to="IMachine::stateFilePath"/> attribute of the
          <link to="#machine"/> object associated with this snapshot
          will point to the saved state file. Otherwise, it will be
          an empty string.
      </desc>
    </attribute>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>
        Virtual machine this snapshot is taken on. This object
        stores all settings the machine had when taking this snapshot.
        <note>
          The returned machine object is immutable, i.e. no
          any settings can be changed.
        </note>
      </desc>
    </attribute>

    <attribute name="parent" type="ISnapshot" readonly="yes">
      <desc>
        Parent snapshot (a snapshot this one is based on), or
        @c null if the snapshot has no parent (i.e. is the first snapshot).
      </desc>
    </attribute>

    <attribute name="children" type="ISnapshot" readonly="yes" safearray="yes">
      <desc>
        Child snapshots (all snapshots having this one as a parent).
      </desc>
    </attribute>

  </interface>


  <!--
  // IMedium
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="MediumState"
    uuid="ef41e980-e012-43cd-9dea-479d4ef14d13"
  >
    <desc>
      Virtual medium state.
      <see>IMedium</see>
    </desc>

    <const name="NotCreated" value="0">
      <desc>
        Associated medium storage does not exist (either was not created yet or
        was deleted).
      </desc>
    </const>
    <const name="Created" value="1">
      <desc>
        Associated storage exists and accessible; this gets set if the
        accessibility check performed by <link to="IMedium::refreshState" />
        was successful.
      </desc>
    </const>
    <const name="LockedRead" value="2">
      <desc>
        Medium is locked for reading (see <link to="IMedium::lockRead"/>),
        no data modification is possible.
      </desc>
    </const>
    <const name="LockedWrite" value="3">
      <desc>
        Medium is locked for writing (see <link to="IMedium::lockWrite"/>),
        no concurrent data reading or modification is possible.
      </desc>
    </const>
    <const name="Inaccessible" value="4">
      <desc>
        Medium accessiblity check (see <link to="IMedium::refreshState" />) has
        not yet been performed, or else, associated medium storage is not
        accessible. In the first case, <link to="IMedium::lastAccessError"/>
        is empty, in the second case, it describes the error that occured.
      </desc>
    </const>
    <const name="Creating" value="5">
      <desc>
        Associated medium storage is being created.
      </desc>
    </const>
    <const name="Deleting" value="6">
      <desc>
        Associated medium storage is being deleted.
      </desc>
    </const>
  </enum>

  <enum
    name="MediumType"
    uuid="46bf1fd4-ad86-4ded-8c49-28bd2d148e5a"
   >
    <desc>
      Virtual medium type.
      <see>IMedium</see>
    </desc>

    <const name="Normal"            value="0">
      <desc>
        Normal medium (attached directly or indirectly, preserved
        when taking snapshots).
      </desc>
    </const>
    <const name="Immutable"         value="1">
      <desc>
        Immutable medium (attached indirectly, changes are wiped out
        the next time the virtual machine is started).
      </desc>
    </const>
    <const name="Writethrough"      value="2">
      <desc>
        Write through medium (attached directly, ignored when
        taking snapshots).
      </desc>
    </const>
    <const name="Shareable"         value="3">
      <desc>
        Allow using this medium concurrently by several machines.
        <note>This is a stub value. Not usable until this note is removed.</note>
      </desc>
    </const>
  </enum>

  <enum
    name="MediumVariant"
    uuid="584ea502-143b-4ab0-ad14-d1028fdf0316"
   >
    <desc>
      Virtual medium image variant. More than one flag may be set.
      <see>IMedium</see>
    </desc>

    <const name="Standard"          value="0">
      <desc>
        No particular variant requested, results in using the backend default.
      </desc>
    </const>
    <const name="VmdkSplit2G"       value="0x01">
      <desc>
        VMDK image split in chunks of less than 2GByte.
      </desc>
    </const>
    <const name="VmdkStreamOptimized" value="0x04">
      <desc>
        VMDK streamOptimized image. Special import/export format which is
        read-only/append-only.
      </desc>
    </const>
    <const name="VmdkESX" value="0x08">
      <desc>
        VMDK format variant used on ESX products.
      </desc>
    </const>
    <const name="Fixed" value="0x10000">
      <desc>
        Fixed image. Only allowed for base images.
      </desc>
    </const>
    <const name="Diff" value="0x20000">
      <desc>
        Fixed image. Only allowed for base images.
      </desc>
    </const>
  </enum>

  <interface
    name="IMediumAttachment" extends="$unknown"
    uuid="e58eb3eb-8627-428b-bdf8-34487c848de5"
    wsmap="struct"
  >
    <desc>
      The IMediumAttachment interface represents the attachment
      of a storage medium to a virtual machine. Each machine contains
      an array of its medium attachments in <link to="IMachine::mediumAttachments"/>.

      Each medium attachment specifies a storage controller as well as a port
      and device number. Fixed media (hard disks) will always also specify
      an instance of IMedium in <link to="#medium" />, referring to the hard disk
      medium. For removeable media, the IMedia instance is optional; it can be
      @c null if no media is mounted (see <link to="IMachine::mountMedium" />).
    </desc>

    <attribute name="medium" type="IMedium" readonly="yes">
      <desc>Medium object associated with this attachment; it
        can be @c null for removable devices.</desc>
    </attribute>

    <attribute name="controller" type="wstring" readonly="yes">
      <desc>Name of the storage controller of this attachment; this
        refers to one of the controllers in <link to="IMachine::storageControllers" />
        by name.</desc>
    </attribute>

    <attribute name="port" type="long" readonly="yes">
      <desc>Port number of this attachment.
        See <link to="IMachine::attachDevice" /> for the meaning of this value for the different controller types.
      </desc>
    </attribute>

    <attribute name="device" type="long" readonly="yes">
      <desc>Device slot number of this attachment.
        See <link to="IMachine::attachDevice" /> for the meaning of this value for the different controller types.
      </desc>
    </attribute>

    <attribute name="type" type="DeviceType" readonly="yes">
      <desc>Device type of this attachment.</desc>
    </attribute>

    <attribute name="passthrough" type="boolean" readonly="yes">
      <desc>Pass I/O requests through to a device on the host.</desc>
    </attribute>

  </interface>

  <interface
    name="IMedium" extends="$unknown"
    uuid="1d578f43-5ef1-4415-b556-7592d3ccdc8f"
    wsmap="managed"
  >
    <desc>
      The IMedium interface represents virtual storage for a machine's
      hard disks, CD/DVD or floppy drives. It will typically represent
      a disk image on the host, for example a VDI or VMDK file representing
      a virtual hard disk, or an ISO or RAW file representing virtual
      removable media, but can also point to a network location (e.g.
      for iSCSI targets).

      Instances of IMedium are connected to virtual machines by way of
      medium attachments (see <link to="IMediumAttachment" />), which link
      the storage medium to a particular device slot of a storage controller
      of the virtual machine.
      In the VirtualBox API, virtual storage is therefore always represented
      by the following chain of object links:

      <ul>
        <li><link to="IMachine::storageControllers"/> contains an array of
          storage controllers (IDE, SATA, SCSI, SAS or a floppy controller;
          these are instances of <link to="IStorageController"/>).</li>
        <li><link to="IMachine::mediumAttachments"/> contains an array of
          medium attachments (instances of <link to="IMediumAttachment"/>),
          each containing a storage controller from the above array, a
          port/device specification, and an instance of IMedium representing
          the medium storage (image file).

          For removable media, the storage medium is optional; a medium
          attachment with no medium represents a CD/DVD or floppy drive
          with no medium inserted. By contrast, hard disk attachments
          will always have an IMedium object attached.</li>
        <li>Each IMedium in turn points to a storage unit (such as a file
          on the host computer or a network resource) that holds actual
          data. This location is represented by the <link to="#location"/>
          attribute.</li>
      </ul>

      Existing media are opened using the following methods, depending on the
      media type:
      <ul>
        <li><link to="IVirtualBox::openHardDisk"/></li>
        <li><link to="IVirtualBox::openDVDImage"/></li>
        <li><link to="IVirtualBox::openFloppyImage"/></li>
      </ul>

      New hard disk media can be created with the VirtualBox API using the
      <link to="IVirtualBox::createHardDisk"/> method.

      CD/DVD and floppy images (ISO and RAW files) are usually created outside
      VirtualBox, e.g. by storing a copy of the real medium of the corresponding
      type in a regular file.

      Only for CD/DVDs and floppies, an IMedium instance can also represent a host
      drive; in that case the <link to="#id" /> attribute contains the UUID of
      one of the drives in <link to="IHost::DVDDrives" /> or <link to="IHost::floppyDrives" />.

      <h3>Known media</h3>

      When an existing medium is opened for the first time, it is automatically
      remembered by the given VirtualBox installation or, in other words, becomes
      a <i>known medium</i>. Known media are stored in the media
      registry transparently maintained by VirtualBox and stored in settings
      files so that this registry is preserved when VirtualBox is not running.

      Newly created virtual media are remembered only when the associated
      storage unit is actually created.

      All known media can be enumerated using
      <link to="IVirtualBox::hardDisks"/>,
      <link to="IVirtualBox::DVDImages"/> and
      <link to="IVirtualBox::floppyImages"/> attributes. Individual media can be
      quickly found by UUID using <link to="IVirtualBox::getHardDisk"/>
      and similar methods or by location using
      <link to="IVirtualBox::findHardDisk"/> and similar methods.

      Only known media can be attached to virtual machines.

      Removing known media from the media registry is performed when the given
      medium is closed using the <link to="#close"/> method or when its
      associated storage unit is deleted.

      <h3>Accessibility checks</h3>

      VirtualBox defers media accessibility checks until the <link to="#refreshState" />
      method is called explicitly on a medium. This is done to make the VirtualBox object
      ready for serving requests as fast as possible and let the end-user
      application decide if it needs to check media accessibility right away or not.

      As a result, when VirtualBox starts up (e.g. the VirtualBox
      object gets created for the first time), all known media are in the
      "Inaccessible" state, but the value of the <link to="#lastAccessError"/>
      attribute is an empty string because no actual accessibility check has
      been made yet.

      After calling <link to="#refreshState" />, a medium is considered
      <i>accessible</i> if its storage unit can be read. In that case, the
      <link to="#state"/> attribute has a value of "Created". If the storage
      unit cannot be read (for example, because it is located on a disconnected
      network resource, or was accidentally deleted outside VirtualBox),
      the medium is considered <i>inaccessible</i>, which is indicated by the
      "Inaccessible" state. The exact reason why the medium is inaccessible can be
      obtained by reading the <link to="#lastAccessError"/> attribute.

      <h3>Medium types</h3>

      There are three types of medium behavior (see <link to="MediumType" />):
      "normal", "immutable" and "writethrough", represented by the
      <link to="#type"/> attribute. The type of the medium defines how the
      medium is attached to a virtual machine and what happens when a
      <link to="ISnapshot">snapshot</link> of the virtual machine with the
      attached medium is taken. At the moment DVD and floppy media are always
      of type "writethrough".

      All media can be also divided in two groups: <i>base</i> media and
      <i>differencing</i> media. A base medium contains all sectors of the
      medium data in its own storage and therefore can be used independently.
      In contrast, a differencing mediun is a "delta" to some other medium and
      contains only those sectors which differ from that other medium, which is
      then called a <i>parent</i>. The differencing medium is said to be
      <i>linked to</i> that parent. The parent may be itself a differencing
      medium, thus forming a chain of linked media. The last element in that
      chain must always be a base medium. Note that several differencing
      media may be linked to the same parent medium.

      Differencing media can be distinguished from base media by querying the
      <link to="#parent"/> attribute: base media do not have parents they would
      depend on, so the value of this attribute is always @c null for them.
      Using this attribute, it is possible to walk up the medium tree (from the
      child medium to its parent). It is also possible to walk down the tree
      using the <link to="#children"/> attribute.

      Note that the type of all differencing media is "Normal"; all other
      values are meaningless for them. Base media may be of any type.

      <h3>Creating hard disks</h3>

      New base hard disks are created using
      <link to="IVirtualBox::createHardDisk"/>. Existing hard disks are
      opened using <link to="IVirtualBox::openHardDisk"/>. Differencing hard
      disks are usually implicitly created by VirtualBox when needed but may
      also be created explicitly using <link to="#createDiffStorage"/>.

      After the hard disk is successfully created (including the storage unit)
      or opened, it becomes a known hard disk (remembered in the internal media
      registry). Known hard disks can be attached to a virtual machine, accessed
      through <link to="IVirtualBox::getHardDisk"/> and
      <link to="IVirtualBox::findHardDisk"/> methods or enumerated using the
      <link to="IVirtualBox::hardDisks"/> array (only for base hard disks).

      The following methods, besides <link to="IMedium::close"/>,
      automatically remove the hard disk from the media registry:
      <ul>
        <li><link to="#deleteStorage"/></li>
        <li><link to="#mergeTo"/></li>
      </ul>

      If the storage unit of the hard disk is a regular file in the host's
      file system then the rules stated in the description of the
      <link to="IMedium::location"/> attribute apply when setting its value. In
      addition, a plain file name without any path may be given, in which case
      the <link to="ISystemProperties::defaultHardDiskFolder"> default hard disk
      folder</link> will be prepended to it.

      <h4>Automatic composition of the file name part</h4>

      Another extension to the <link to="IMedium::location"/> attribute is that
      there is a possibility to cause VirtualBox to compose a unique value for
      the file name part of the location using the UUID of the hard disk. This
      applies only to hard disks in <link to="MediumState_NotCreated"/> state,
      e.g. before the storage unit is created, and works as follows. You set the
      value of the <link to="IMedium::location"/> attribute to a location
      specification which only contains the path specification but not the file
      name part and ends with either a forward slash or a backslash character.
      In response, VirtualBox will generate a new UUID for the hard disk and
      compose the file name using the following pattern:
      <pre>
        &lt;path&gt;/{&lt;uuid&gt;}.&lt;ext&gt;
      </pre>
      where <tt>&lt;path&gt;</tt> is the supplied path specification,
      <tt>&lt;uuid&gt;</tt> is the newly generated UUID and <tt>&lt;ext&gt;</tt>
      is the default extension for the storage format of this hard disk. After
      that, you may call any of the methods that create a new hard disk storage
      unit and they will use the generated UUID and file name.

      <h3>Attaching Hard Disks</h3>

      Hard disks are attached to virtual machines using the
      <link to="IMachine::attachDevice"/> method and detached using the
      <link to="IMachine::detachDevice"/> method. Depending on their
      <link to="#type"/>, hard disks are attached either
      <i>directly</i> or <i>indirectly</i>.

      When a hard disk is being attached directly, it is associated with the
      virtual machine and used for hard disk operations when the machine is
      running. When a hard disk is being attached indirectly, a new differencing
      hard disk linked to it is implicitly created and this differencing hard
      disk is associated with the machine and used for hard disk operations.
      This also means that if <link to="IMachine::attachDevice"/> performs
      a direct attachment then the same hard disk will be returned in response
      to the subsequent  <link to="IMachine::getMedium"/> call; however if
      an indirect attachment is performed then
      <link to="IMachine::getMedium"/> will return the implicitly created
      differencing hard disk, not the original one passed to <link
      to="IMachine::attachDevice"/>. In detail:

      <ul>
        <li><b>Normal base</b> hard disks that do not have children (i.e.
            differencing hard disks linked to them) and that are not already
            attached to virtual machines in snapshots are attached <b>directly</b>.
            Otherwise, they are attached <b>indirectly</b> because having
            dependent children or being part of the snapshot makes it impossible
            to modify hard disk contents without breaking the integrity of the
            dependent party. The <link to="#readOnly"/> attribute allows to
            quickly determine the kind of the attachment for the given hard
            disk. Note that if a normal base hard disk is to be indirectly
            attached to a virtual machine with snapshots then a special
            procedure called <i>smart attachment</i> is performed (see below).</li>
        <li><b>Normal differencing</b> hard disks are like normal base hard disks:
            they are attached <b>directly</b> if they do not have children and are
            not attached to virtual machines in snapshots, and <b>indirectly</b>
            otherwise. Note that the smart attachment procedure is never performed
            for differencing hard disks.</li>
        <li><b>Immutable</b> hard disks are always attached <b>indirectly</b> because
            they are designed to be non-writable. If an immutable hard disk is
            attached to a virtual machine with snapshots then a special
            procedure called smart attachment is performed (see below).</li>
        <li><b>Writethrough</b> hard disks are always attached <b>directly</b>,
            also as designed. This also means that writethrough hard disks cannot
            have other hard disks linked to them at all.</li>
      </ul>

      Note that the same hard disk, regardless of its type, may be attached to
      more than one virtual machine at a time. In this case, the machine that is
      started first gains exclusive access to the hard disk and attempts to
      start other machines having this hard disk attached will fail until the
      first machine is powered down.

      Detaching hard disks is performed in a <i>deferred</i> fashion. This means
      that the given hard disk remains associated with the given machine after a
      successful <link to="IMachine::detachDevice"/> call until
      <link to="IMachine::saveSettings"/> is called to save all changes to
      machine settings to disk. This deferring is necessary to guarantee that
      the hard disk configuration may be restored at any time by a call to
      <link to="IMachine::discardSettings"/>  before the settings
      are saved (committed).

      Note that if <link to="IMachine::discardSettings"/> is called after
      indirectly attaching some hard disks to the machine but before a call to
      <link to="IMachine::saveSettings"/> is made, it will implicitly delete
      all differencing hard disks implicitly created by
      <link to="IMachine::attachDevice"/> for these indirect attachments.
      Such implicitly created hard disks will also be immediately deleted when
      detached explicitly using the <link to="IMachine::detachDevice"/>
      call if it is made before <link to="IMachine::saveSettings"/>. This
      implicit deletion is safe because newly created differencing hard
      disks do not contain any user data.

      However, keep in mind that detaching differencing hard disks that were
      implicitly created by <link to="IMachine::attachDevice"/>
      before the last <link to="IMachine::saveSettings"/> call will
      <b>not</b> implicitly delete them as they may already contain some data
      (for example, as a result of virtual machine execution). If these hard
      disks are no more necessary, the caller can always delete them explicitly
      using <link to="#deleteStorage"/> after they are actually de-associated
      from this machine by the <link to="IMachine::saveSettings"/> call.

      <h3>Smart Attachment</h3>

      When normal base or immutable hard disks are indirectly attached to a
      virtual machine then some additional steps are performed to make sure the
      virtual machine will have the most recent "view" of the hard disk being
      attached. These steps include walking through the machine's snapshots
      starting from the current one and going through ancestors up to the first
      snapshot. Hard disks attached to the virtual machine in all
      of the encountered snapshots are checked whether they are descendants of
      the given normal base or immutable hard disk. The first found child (which
      is the differencing hard disk) will be used instead of the normal base or
      immutable hard disk as a parent for creating a new differencing hard disk
      that will be actually attached to the machine. And only if no descendants
      are found or if the virtual machine does not have any snapshots then the
      normal base or immutable hard disk will be used itself as a parent for
      this differencing hard disk.

      It is easier to explain what smart attachment does using the
      following example:
      <pre>
BEFORE attaching B.vdi:       AFTER attaching B.vdi:

Snapshot 1 (B.vdi)            Snapshot 1 (B.vdi)
 Snapshot 2 (D1->B.vdi)        Snapshot 2 (D1->B.vdi)
  Snapshot 3 (D2->D1.vdi)       Snapshot 3 (D2->D1.vdi)
   Snapshot 4 (none)             Snapshot 4 (none)
    CurState   (none)             CurState   (D3->D2.vdi)

                              NOT
                                 ...
                                  CurState   (D3->B.vdi)
      </pre>
      The first column is the virtual machine configuration before the base hard
      disk <tt>B.vdi</tt> is attached, the second column shows the machine after
      this hard disk is attached. Constructs like <tt>D1->B.vdi</tt> and similar
      mean that the hard disk that is actually attached to the machine is a
      differencing hard disk, <tt>D1.vdi</tt>, which is linked to (based on)
      another hard disk, <tt>B.vdi</tt>.

      As we can see from the example, the hard disk <tt>B.vdi</tt> was detached
      from the machine before taking Snapshot 4. Later, after Snapshot 4 was
      taken, the user decides to attach <tt>B.vdi</tt> again. <tt>B.vdi</tt> has
      dependent child hard disks (<tt>D1.vdi</tt>, <tt>D2.vdi</tt>), therefore
      it cannot be attached directly and needs an indirect attachment (i.e.
      implicit creation of a new differencing hard disk). Due to the smart
      attachment procedure, the new differencing hard disk
      (<tt>D3.vdi</tt>) will be based on <tt>D2.vdi</tt>, not on
      <tt>B.vdi</tt> itself, since <tt>D2.vdi</tt> is the most recent view of
      <tt>B.vdi</tt> existing for this snapshot branch of the given virtual
      machine.

      Note that if there is more than one descendant hard disk of the given base
      hard disk found in a snapshot, and there is an exact device, channel and
      bus match, then this exact match will be used. Otherwise, the youngest
      descendant will be picked up.

      There is one more important aspect of the smart attachment procedure which
      is not related to snapshots at all. Before walking through the snapshots
      as described above, the backup copy of the current list of hard disk
      attachment is searched for descendants. This backup copy is created when
      the hard disk configuration is changed for the first time after the last
      <link to="IMachine::saveSettings"/> call and used by
      <link to="IMachine::discardSettings"/> to undo the recent hard disk
      changes. When such a descendant is found in this backup copy, it will be
      simply re-attached back, without creating a new differencing hard disk for
      it. This optimization is necessary to make it possible to re-attach the
      base or immutable hard disk to a different bus, channel or device slot
      without losing the contents of the differencing hard disk actually
      attached to the machine in place of it.
    </desc>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>
        UUID of the medium. For a newly created medium, this value is a randomly
        generated UUID.

        <note>
          For media in one of MediumState_NotCreated, MediumState_Creating or
          MediumState_Deleting states, the value of this property is undefined
          and will most likely be an empty UUID.
        </note>
      </desc>
    </attribute>

    <attribute name="description" type="wstring">
      <desc>
        Optional description of the medium. For a newly created medium the value
        of this attribute is an empty string.

        Medium types that don't support this attribute will return E_NOTIMPL in
        attempt to get or set this attribute's value.

        <note>
          For some storage types, reading this attribute may return an outdated
          (last known) value when <link to="#state"/> is <link
          to="MediumState_Inaccessible"/> or <link
          to="MediumState_LockedWrite"/> because the value of this attribute is
          stored within the storage unit itself. Also note that changing the
          attribute value is not possible in such case, as well as when the
          medium is the <link to="MediumState_LockedRead"/> state.
        </note>
      </desc>
    </attribute>

    <attribute name="state" type="MediumState" readonly="yes">
      <desc>
        Returns the current medium state, which is the last state set by
        the accessibility check performed by <link to="#refreshState"/>.
        If that method has not yet been called on the medium, the state
        is "Inaccessible"; as opposed to truly inaccessible media, the
        value of <link to="#lastAccessError"/> will be an empty string in
        that case.

        <note>As of version 3.1, this no longer performs an accessibility check
          automatically; call <link to="#refreshState"/> for that.
        </note>
      </desc>
    </attribute>

    <attribute name="location" type="wstring">
      <desc>
        Location of the storage unit holding medium data.

        The format of the location string is medium type specific. For medium
        types using regular files in a host's file system, the location
        string is the full file name.

        Some medium types may support changing the storage unit location by
        simply changing the value of this property. If this operation is not
        supported, the implementation will return E_NOTIMPL in attempt to set
        this attribute's value.

        When setting a value of the location attribute which is a regular file
        in the host's file system, the given file name may be either relative to
        the <link to="IVirtualBox::homeFolder">VirtualBox home folder</link> or
        absolute. Note that if the given location specification does not contain
        the file extension part then a proper default extension will be
        automatically appended by the implementation depending on the medium type.
      </desc>
    </attribute>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Name of the storage unit holding medium data.

        The returned string is a short version of the <link to="#location"/>
        attribute that is suitable for representing the medium in situations
        where the full location specification is too long (such as lists
        and comboboxes in GUI frontends). This string is also used by frontends
        to sort the media list alphabetically when needed.

        For example, for locations that are regular files in the host's file
        system, the value of this attribute is just the file name (+ extension),
        without the path specification.

        Note that as opposed to the <link to="#location"/> attribute, the name
        attribute will not necessary be unique for a list of media of the
        given type and format.
      </desc>
    </attribute>

    <attribute name="deviceType" type="DeviceType" readonly="yes">
      <desc>Kind of device (DVD/Floppy/HardDisk) which is applicable to this
        medium.</desc>
    </attribute>

    <attribute name="hostDrive" type="boolean" readonly="yes">
      <desc>True if this corresponds to a drive on the host.</desc>
    </attribute>

    <attribute name="size" type="unsigned long long" readonly="yes">
      <desc>
        Physical size of the storage unit used to hold medium data (in bytes).

        <note>
          For media whose <link to="#state"/> is <link
          to="MediumState_Inaccessible"/>, the value of this property is the
          last known size. For <link to="MediumState_NotCreated"/> media,
          the returned value is zero.
        </note>
      </desc>
    </attribute>

    <attribute name="format" type="wstring" readonly="yes">
      <desc>
        Storage format of this medium.

        The value of this attribute is a string that specifies a backend used
        to store medium data. The storage format is defined when you create a
        new medium or automatically detected when you open an existing medium,
        and cannot be changed later.

        The list of all storage formats supported by this VirtualBox
        installation can be obtained using
        <link to="ISystemProperties::mediumFormats"/>.
      </desc>
    </attribute>

    <attribute name="mediumFormat" type="IMediumFormat" readonly="yes">
      <desc>
        Storage medium format object corresponding to this medium.

        The value of this attribute is a reference to the medium format object
        that specifies the backend properties used to store medium data. The
        storage format is defined when you create a new medium or automatically
        detected when you open an existing medium, and cannot be changed later.

        <note>@c null is returned if there is no associated medium format
        object. This can e.g. happen for medium objects representing host
        drives and other special medium objects.</note>
      </desc>
    </attribute>

    <attribute name="type" type="MediumType">
      <desc>
        Type (role) of this medium.

        The following constraints apply when changing the value of this
        attribute:
        <ul>
          <li>If a medium is attached to a virtual machine (either in the
              current state or in one of the snapshots), its type cannot be
              changed.
          </li>
          <li>As long as the medium has children, its type cannot be set
              to <link to="MediumType_Writethrough"/>.
          </li>
          <li>The type of all differencing media is
              <link to="MediumType_Normal"/> and cannot be changed.
          </li>
        </ul>

        The type of a newly created or opened medium is set to
        <link to="MediumType_Normal"/>, except for DVD and floppy media,
        which have a type of <link to="MediumType_Writethrough"/>.
      </desc>
    </attribute>

    <attribute name="parent" type="IMedium" readonly="yes">
      <desc>
        Parent of this medium (the medium this medium is directly based
        on).

        Only differencing media have parents. For base (non-differencing)
        media, @c null is returned.
      </desc>
    </attribute>

    <attribute name="children" type="IMedium" safearray="yes" readonly="yes">
      <desc>
        Children of this medium (all differencing media directly based
        on this medium). A @c null array is returned if this medium
        does not have any children.
      </desc>
    </attribute>

    <attribute name="base" type="IMedium" readonly="yes">
      <desc>
        Base medium of this medium.

        If this is a differencing medium, its base medium is the medium
        the given medium branch starts from. For all other types of media, this
        property returns the medium object itself (i.e. the same object this
        property is read on).
      </desc>
    </attribute>

    <attribute name="readOnly" type="boolean" readonly="yes">
      <desc>
        Returns @c true if this medium is read-only and @c false otherwise.

        A medium is considered to be read-only when its contents cannot be
        modified without breaking the integrity of other parties that depend on
        this medium such as its child media or snapshots of virtual machines
        where this medium is attached to these machines. If there are no
        children and no such snapshots then there is no dependency and the
        medium is not read-only.

        The value of this attribute can be used to determine the kind of the
        attachment that will take place when attaching this medium to a
        virtual machine. If the value is @c false then the medium will
        be attached directly. If the value is @c true then the medium
        will be attached indirectly by creating a new differencing child
        medium for that. See the interface description for more information.

        Note that all <link to="MediumType_Immutable">Immutable</link> media
        are always read-only while all
        <link to="MediumType_Writethrough">Writethrough</link> media are
        always not.

        <note>
          The read-only condition represented by this attribute is related to
          the medium type and usage, not to the current
          <link to="IMedium::state">medium state</link> and not to the read-only
          state of the storage unit.
        </note>
      </desc>
    </attribute>

    <attribute name="logicalSize" type="unsigned long long" readonly="yes">
      <desc>
        Logical size of this medium (in megabytes), as reported to the
        guest OS running inside the virtual machine this medium is
        attached to. The logical size is defined when the medium is created
        and cannot be changed later.

        <note>
          Reading this property on a differencing medium will return the size
          of its <link to="#base"/> medium.
        </note>
        <note>
          For media whose state is <link to="#state"/> is <link
          to="MediumState_Inaccessible"/>, the value of this property is the
          last known logical size. For <link to="MediumaState_NotCreated"/>
          media, the returned value is zero.
        </note>
      </desc>
    </attribute>

    <attribute name="autoReset" type="boolean">
      <desc>
        Whether this differencing medium will be automatically reset each
        time a virtual machine it is attached to is powered up. This
        attribute is automatically set to @c true for the last
        differencing image of an "immutable" medium (see
        <link to="MediumType" />).

        See <link to="#reset"/> for more information about resetting
        differencing media.

        <note>
          Reading this property on a base (non-differencing) medium will
          always @c false. Changing the value of this property in this
          case is not supported.
        </note>

        <result name="VBOX_E_NOT_SUPPORTED">
          This is not a differencing medium (when changing the attribute
          value).
        </result>
      </desc>
    </attribute>

    <attribute name="lastAccessError" type="wstring" readonly="yes">
      <desc>
        Text message that represents the result of the last accessibility
        check performed by <link to="#refreshState"/>.

        An empty string is returned if the last accessibility check
        was successful or has not yet been called. As a result, if
        <link to="#state" /> is "Inaccessible" and this attribute is empty,
        then <link to="#refreshState"/> has yet to be called; this is the
        default value of media after VirtualBox initialization.
        A non-empty string indicates a failure and should normally describe
        a reason of the failure (for example, a file read error).
      </desc>
    </attribute>

    <attribute name="machineIds" type="uuid" mod="string" safearray="yes" readonly="yes">
      <desc>
        Array of UUIDs of all machines this medium is attached to.

        A @c null array is returned if this medium is not attached to any
        machine or to any machine's snapshot.

        <note>
          The returned array will include a machine even if this medium is not
          attached to that machine in the current state but attached to it in
          one of the machine's snapshots. See <link to="#getSnapshotIds"/> for
          details.
        </note>
      </desc>
    </attribute>

    <method name="refreshState">
      <desc>
        If the current medium state (see <link to="MediumState"/>) is one of
        "Created", "Inaccessible" or "LockedRead", then this performs an
        accessibility check on the medium and sets the value of the <link to="#state"/>
        attribute accordingly; that value is also returned for convenience.

        For all other state values, this does not perform a refresh but returns
        the state only.

        The refresh, if performed, may take a long time (several seconds or even
        minutes, depending on the storage unit location and format) because it performs an
        accessibility check of the storage unit. This check may cause a significant
        delay if the storage unit of the given medium is, for example, a file located
        on a network share which is not currently accessible due to connectivity
        problems. In that case, the call will not return until a timeout
        interval defined by the host OS for this operation expires. For this reason,
        it is recommended to never read this attribute on the main UI thread to avoid
        making the UI unresponsive.

        If the last known state of the medium is "Created" and the accessibility
        check fails, then the state would be set to "Inaccessible", and
        <link to="#lastAccessError"/> may be used to get more details about the
        failure. If the state of the medium is "LockedRead", then it remains the
        same, and a non-empty value of <link to="#lastAccessError"/> will
        indicate a failed accessibility check in this case.

        Note that not all medium states are applicable to all medium types.
      </desc>
      <param name="state" type="MediumState" dir="return">
        <desc>
          New medium state.
        </desc>
      </param>
    </method>

    <method name="getSnapshotIds">
      <desc>
        Returns an array of UUIDs of all snapshots of the given machine where
        this medium is attached to.

        If the medium is attached to the machine in the current state, then the
        first element in the array will always be the ID of the queried machine
        (i.e. the value equal to the @c machineId argument), followed by
        snapshot IDs (if any).

        If the medium is not attached to the machine in the current state, then
        the array will contain only snapshot IDs.

        The returned array may be @c null if this medium is not attached
        to the given machine at all, neither in the current state nor in one of
        the snapshots.
      </desc>
      <param name="machineId" type="uuid" mod="string" dir="in">
        <desc>
          UUID of the machine to query.
        </desc>
      </param>
      <param name="snapshotIds" type="uuid" mod="string" safearray="yes" dir="return">
        <desc>
          Array of snapshot UUIDs of the given machine using this medium.
        </desc>
      </param>
    </method>

    <method name="lockRead">
      <desc>
        Locks this medium for reading.

        A read lock is shared: many clients can simultaneously lock the
        same medium for reading unless it is already locked for writing (see
        <link to="#lockWrite"/>) in which case an error is returned.

        When the medium is locked for reading, it cannot be modified
        from within VirtualBox. This means that any method that changes
        the properties of this medium or contents of the storage unit
        will return an error (unless explicitly stated otherwise). That
        includes an attempt to start a virtual machine that wants to
        write to the the medium.

        When the virtual machine is started up, it locks for reading all
        media it uses in read-only mode. If some medium cannot be locked
        for reading, the startup procedure will fail.
        A medium is typically locked for reading while it is used by a running
        virtual machine but has a depending differencing image that receives
        the actual write operations. This way one base medium can have
        multiple child differencing images which can be written to
        simultaneously. Read-only media such as DVD and floppy images are
        also locked for reading only (so they can be in use by multiple
        machines simultaneously).

        A medium is also locked for reading when it is the source of a
        write operation such as <link to="#cloneTo"/> or <link to="#mergeTo"/>.

        The medium locked for reading must be unlocked using the <link
        to="#unlockRead"/> method. Calls to <link to="#lockRead"/>
        can be nested and must be followed by the same number of paired
        <link to="#unlockRead"/> calls.

        This method sets the medium state (see <link to="#state"/>) to
        "LockedRead" on success. The medium's previous state must be
        one of "Created", "Inaccessible" or "LockedRead".

        Locking an inaccessible medium is not an error; this method performs
        a logical lock that prevents modifications of this medium through
        the VirtualBox API, not a physical file-system lock of the underlying
        storage unit.

        This method returns the current state of the medium
        <i>before</i> the operation.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid medium state (e.g. not created, locked, inaccessible,
          creating, deleting).
        </result>

      </desc>
      <param name="state" type="MediumState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="unlockRead">
      <desc>
        Cancels the read lock previously set by <link to="#lockRead"/>.

        For both success and failure, this method returns the current state
        of the medium <i>after</i> the operation.

        See <link to="#lockRead"/> for more details.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Medium not locked for reading.
        </result>

      </desc>
      <param name="state" type="MediumState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="lockWrite">
      <desc>
        Locks this medium for writing.

        A write lock, as opposed to <link to="#lockRead"/>, is
        exclusive: there may be only one client holding a write lock,
        and there may be no read locks while the write lock is held.
        As a result, read-locking fails if a write lock is held, and
        write-locking fails if either a read or another write lock is held.

        When a medium is locked for writing, it cannot be modified
        from within VirtualBox, and it is not guaranteed that the values
        of its properties are up-to-date. Any method that changes the
        properties of this medium or contents of the storage unit will
        return an error (unless explicitly stated otherwise).

        When a virtual machine is started up, it locks for writing all
        media it uses to write data to. If any medium could not be locked
        for writing, the startup procedure will fail. If a medium has
        differencing images, then while the machine is running, only
        the last ("leaf") differencing image is locked for writing,
        whereas its parents are locked for reading only.

        A medium is also locked for writing when it is the target of a
        write operation such as <link to="#cloneTo"/> or <link to="#mergeTo"/>.

        The medium locked for writing must be unlocked using the <link
        to="#unlockWrite"/> method. Write locks <i>cannot</i> be nested.

        This method sets the medium state (see <link to="#state"/>) to
        "LockedWrite" on success. The medium's previous state must be
        either "Created" or "Inaccessible".

        Locking an inaccessible medium is not an error; this method performs
        a logical lock that prevents modifications of this medium through
        the VirtualBox API, not a physical file-system lock of the underlying
        storage unit.

        For both, success and failure, this method returns the current
        state of the medium <i>before</i> the operation.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid medium state (e.g. not created, locked, inaccessible,
          creating, deleting).
        </result>

      </desc>
      <param name="state" type="MediumState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="unlockWrite">
      <desc>
        Cancels the write lock previously set by <link to="#lockWrite"/>.

        For both success and failure, this method returns the current
        state of the medium <i>after</i> the operation.

        See <link to="#lockWrite"/> for more details.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Medium not locked for writing.
        </result>

      </desc>
      <param name="state" type="MediumState" dir="return">
        <desc>
          State of the medium after the operation.
        </desc>
      </param>
    </method>

    <method name="close">
      <desc>
        Closes this medium.

        The medium must not be attached to any known virtual machine
        and must not have any known child media, otherwise the
        operation will fail.

        When the medium is successfully closed, it gets removed from
        the list of remembered media, but its storage unit is not
        deleted. In particular, this means that this medium can be
        later opened again using the <link
        to="IVirtualBox::openHardDisk"/> call.

        Note that after this method successfully returns, the given medium
        object becomes uninitialized. This means that any attempt
        to call any of its methods or attributes will fail with the
        <tt>"Object not ready" (E_ACCESSDENIED)</tt> error.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Invalid medium state (other than not created, created or
          inaccessible).
        </result>
        <result name="VBOX_E_OBJECT_IN_USE">
          Medium attached to virtual machine.
        </result>
        <result name="VBOX_E_FILE_ERROR">
          Settings file not accessible.
        </result>
        <result name="VBOX_E_XML_ERROR">
          Could not parse the settings file.
        </result>

      </desc>
    </method>

    <!-- storage methods -->

    <method name="getProperty">
      <desc>
        Returns the value of the custom medium property with the given name.

        The list of all properties supported by the given medium format can
        be obtained with <link to="IMediumFormat::describeProperties"/>.

        Note that if this method returns an empty string in @a value, the
        requested property is supported but currently not assigned any value.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Requested property does not exist (not supported by the format).
        </result>
        <result name="E_INVALIDARG">@a name is @c null or empty.</result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the property to get.</desc>
      </param>
      <param name="value" type="wstring" dir="return">
        <desc>Current property value.</desc>
      </param>
    </method>

    <method name="setProperty">
      <desc>
        Sets the value of the custom medium property with the given name.

        The list of all properties supported by the given medium format can
        be obtained with <link to="IMediumFormat::describeProperties"/>.

        Note that setting the property value to @c null or an empty string is
        equivalent to deleting the existing value. A default value (if it is
        defined for this property) will be used by the format backend in this
        case.

        <result name="VBOX_E_OBJECT_NOT_FOUND">
          Requested property does not exist (not supported by the format).
        </result>
        <result name="E_INVALIDARG">@a name is @c null or empty.</result>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>Name of the property to set.</desc>
      </param>
      <param name="value" type="wstring" dir="in">
        <desc>Property value to set.</desc>
      </param>
    </method>

    <method name="getProperties">
      <desc>
        Returns values for a group of properties in one call.

        The names of the properties to get are specified using the @a names
        argument which is a list of comma-separated property names or
        an empty string if all properties are to be returned. Note that currently
        the value of this argument is ignored and the method always returns all
        existing properties.

        The list of all properties supported by the given medium format can
        be obtained with <link to="IMediumFormat::describeProperties"/>.

        The method returns two arrays, the array of property names corresponding
        to the @a names argument and the current values of these properties.
        Both arrays have the same number of elements with each elemend at the
        given index in the first array corresponds to an element at the same
        index in the second array.

        Note that for properties that do not have assigned values,
        an empty string is returned at the appropriate index in the
        @a returnValues array.

      </desc>
      <param name="names" type="wstring" dir="in">
        <desc>
          Names of properties to get.
        </desc>
      </param>
      <param name="returnNames" type="wstring" safearray="yes" dir="out">
        <desc>Names of returned properties.</desc>
      </param>
      <param name="returnValues" type="wstring" safearray="yes" dir="return">
        <desc>Values of returned properties.</desc>
      </param>
    </method>

    <method name="setProperties">
      <desc>
        Sets values for a group of properties in one call.

        The names of the properties to set are passed in the @a names
        array along with the new values for them in the @a values array. Both
        arrays have the same number of elements with each elemend at the given
        index in the first array corresponding to an element at the same index
        in the second array.

        If there is at least one property name in @a names that is not valid,
        the method will fail before changing the values of any other properties
        from the @a names array.

        Using this method over <link to="#setProperty"/> is preferred if you
        need to set several properties at once since it will result into less
        IPC calls.

        The list of all properties supported by the given medium format can
        be obtained with <link to="IMediumFormat::describeProperties"/>.

        Note that setting the property value to @c null or an empty string is
        equivalent to deleting the existing value. A default value (if it is
        defined for this property) will be used by the format backend in this
        case.
      </desc>
      <param name="names" type="wstring" safearray="yes" dir="in">
        <desc>Names of properties to set.</desc>
      </param>
      <param name="values" type="wstring" safearray="yes" dir="in">
        <desc>Values of properties to set.</desc>
      </param>
    </method>

    <!-- storage methods -->

    <method name="createBaseStorage">
      <desc>
        Starts creating a hard disk storage unit (fixed/dynamic, according
        to the variant flags) in in the background. The previous storage unit
        created for this object, if any, must first be deleted using
        <link to="#deleteStorage"/>, otherwise the operation will fail.

        Before the operation starts, the medium is placed in
        <link to="MediumState_Creating"/> state. If the create operation
        fails, the medium will be placed back in <link to="MediumState_NotCreated"/>
        state.

        After the returned progress object reports that the operation has
        successfully completed, the medium state will be set to <link
        to="MediumState_Created"/>, the medium will be remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <result name="VBOX_E_NOT_SUPPORTED">
          The variant of storage creation operation is not supported. See <link
          to="IMediumFormat::capabilities"/>.
        </result>
      </desc>
      <param name="logicalSize" type="unsigned long long" dir="in">
        <desc>Maximum logical size of the medium in megabytes.</desc>
      </param>
      <param name="variant" type="MediumVariant" dir="in">
        <desc>Exact image variant which should be created.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="deleteStorage">
      <desc>
        Starts deleting the storage unit of this medium.

        The medium must not be attached to any known virtual machine and must
        not have any known child media, otherwise the operation will fail.
        It will also fail if there is no storage unit to delete or if deletion
        is already in progress, or if the medium is being in use (locked for
        read or for write) or inaccessible. Therefore, the only valid state for
        this operation to succeed is <link to="MediumState_Created"/>.

        Before the operation starts, the medium is placed in
        <link to="MediumState_Deleting"/> state and gets removed from the list
        of remembered hard disks (media registry). If the delete operation
        fails, the medium will be remembered again and placed back to
        <link to="MediumState_Created"/> state.

        After the returned progress object reports that the operation is
        complete, the medium state will be set to
        <link to="MediumState_NotCreated"/> and you will be able to use one of
        the storage creation methods to create it again.

        <see>#close()</see>

        <result name="VBOX_E_OBJECT_IN_USE">
          Medium is attached to a virtual machine.
        </result>
        <result name="VBOX_E_NOT_SUPPORTED">
          Storage deletion is not allowed because neither of storage creation
          operations are supported. See
          <link to="IMediumFormat::capabilities"/>.
        </result>

        <note>
          If the deletion operation fails, it is not guaranteed that the storage
          unit still exists. You may check the <link to="IMedium::state"/> value
          to answer this question.
        </note>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <!-- diff methods -->

    <method name="createDiffStorage">
      <desc>
        Starts creating an empty differencing storage unit based on this
        medium in the format and at the location defined by the @a target
        argument.

        The target medium must be in <link to="MediumState_NotCreated"/>
        state (i.e. must not have an existing storage unit). Upon successful
        completion, this operation will set the type of the target medium to
        <link to="MediumType_Normal"/> and create a storage unit necessary to
        represent the differencing medium data in the given format (according
        to the storage format of the target object).

        After the returned progress object reports that the operation is
        successfully complete, the target medium gets remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <note>
          The medium will be set to <link to="MediumState_LockedRead"/>
          state for the duration of this operation.
        </note>
        <result name="VBOX_E_OBJECT_IN_USE">
          Medium not in @c NotCreated state.
        </result>
      </desc>
      <param name="target" type="IMedium" dir="in">
        <desc>Target medium.</desc>
      </param>
      <param name="variant" type="MediumVariant" dir="in">
        <desc>Exact image variant which should be created.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="mergeTo">
      <desc>
        Starts merging the contents of this medium and all intermediate
        differencing media in the chain to the given target medium.

        The target medium must be either a descendant of this medium or
        its ancestor (otherwise this method will immediately return a failure).
        It follows that there are two logical directions of the merge operation:
        from ancestor to descendant (<i>forward merge</i>) and from descendant to
        ancestor (<i>backward merge</i>). Let us consider the following medium
        chain:

        <pre>Base &lt;- Diff_1 &lt;- Diff_2</pre>

        Here, calling this method on the <tt>Base</tt> medium object with
        <tt>Diff_2</tt> as an argument will be a forward merge; calling it on
        <tt>Diff_2</tt> with <tt>Base</tt> as an argument will be a backward
        merge. Note that in both cases the contents of the resulting medium
        will be the same, the only difference is the medium object that takes
        the result of the merge operation. In case of the forward merge in the
        above example, the result will be written to <tt>Diff_2</tt>; in case of
        the backward merge, the result will be written to <tt>Base</tt>. In
        other words, the result of the operation is always stored in the target
        medium.

        Upon successful operation completion, the storage units of all media in
        the chain between this (source) medium and the target medium, including
        the source medium itself, will be automatically deleted and the
        relevant medium objects (including this medium) will become
        uninitialized. This means that any attempt to call any of
        their methods or attributes will fail with the
        <tt>"Object not ready" (E_ACCESSDENIED)</tt> error. Applied to the above
        example, the forward merge of <tt>Base</tt> to <tt>Diff_2</tt> will
        delete and uninitialize both <tt>Base</tt> and <tt>Diff_1</tt> media.
        Note that <tt>Diff_2</tt> in this case will become a base medium
        itself since it will no longer be based on any other medium.

        Considering the above, all of the following conditions must be met in
        order for the merge operation to succeed:
        <ul>
          <li>
            Neither this (source) medium nor any intermediate
            differencing medium in the chain between it and the target
            medium is attached to any virtual machine.
          </li>
          <li>
            Neither the source medium nor the target medium is an
            <link to="MediumType_Immutable"/> medium.
          </li>
          <li>
            The part of the medium tree from the source medium to the
            target medium is a linear chain, i.e. all medium in this
            chain have exactly one child which is the next medium in this
            chain. The only exception from this rule is the target medium in
            the forward merge operation; it is allowed to have any number of
            child media because the merge operation will not change its
            logical contents (as it is seen by the guest OS or by children).
          </li>
          <li>
            None of the involved media are in
            <link to="MediumState_LockedRead"/> or
            <link to="MediumState_LockedWrite"/> state.
          </li>
        </ul>

        <note>
          This (source) medium and all intermediates will be placed to <link
          to="MediumState_Deleting"/> state and the target medium will be
          placed to <link to="MediumState_LockedWrite"/> state and for the
          duration of this operation.
        </note>
      </desc>
      <param name="target" type="IMedium" dir="in">
        <desc>Target medium.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <!-- clone method -->

    <method name="cloneTo">
      <desc>
        Starts creating a clone of this medium in the format and at the
        location defined by the @a target argument.

        The target medium must be either in <link to="MediumState_NotCreated"/>
        state (i.e. must not have an existing storage unit) or in
        <link to="MediumState_Created"/> state (i.e. created and not locked, and
        big enough to hold the data or else the copy will be partial). Upon
        successful completion, the cloned medium will contain exactly the
        same sector data as the medium being cloned, except that in the
        first case a new UUID for the clone will be randomly generated, and in
        the second case the UUID will remain unchanged.

        The @a parent argument defines which medium will be the parent
        of the clone. Passing a @c null reference indicates that the clone will
        be a base image, i.e. completely independent. It is possible to specify
        an arbitrary medium for this parameter, including the parent of the
        medium which is being cloned. Even cloning to a child of the source
        medium is possible. Note that when cloning to an existing image, the
        @a parent irgument is ignored.

        After the returned progress object reports that the operation is
        successfully complete, the target medium gets remembered by this
        VirtualBox installation and may be attached to virtual machines.

        <note>
          This medium will be placed to <link to="MediumState_LockedRead"/>
          state for the duration of this operation.
        </note>
        <result name="E_NOTIMPL">
          The specified cloning variant is not supported at the moment.
        </result>
      </desc>
      <param name="target" type="IMedium" dir="in">
        <desc>Target medium.</desc>
      </param>
      <param name="variant" type="MediumVariant" dir="in">
        <desc>Exact image variant which should be created.</desc>
      </param>
      <param name="parent" type="IMedium" dir="in">
        <desc>Parent of the cloned medium.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <!-- other methods -->

    <method name="compact">
      <desc>
        Starts compacting of this medium. This means that the medium is
        transformed into a possibly more compact storage representation.
        This potentially creates temporary images, which can require a
        substantial amount of additional disk space.

        This medium will be placed to <link to="MediumState_LockedWrite"/>
        state and all its parent media (if any) will be placed to
        <link to="MediumState_LockedRead"/> state for the duration of this
        operation.

        Please note that the results can be either returned straight away,
        or later as the result of the background operation via the object
        returned via the @a progress parameter.

        <result name="VBOX_E_NOT_SUPPORTED">
          Medium format does not support compacting (but potentially
          needs it).
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="resize">
      <desc>
        Starts resizing this medium. This means that the nominal size of the
        medium is set to the new value. Both increasing and decreasing the
        size is possible, and there are no safety checks, since VirtualBox
        does not make any assumptions about the medium contents.

        Resizing usually needs additional disk space, and possibly also
        some temporary disk space. Note that resize does not create a full
        temporary copy of the medium, so the additional disk space requirement
        is usually much lower than using the clone operation.

        This medium will be placed to <link to="MediumState_LockedWrite"/>
        state for the duration of this operation.

        Please note that the results can be either returned straight away,
        or later as the result of the background operation via the object
        returned via the @a progress parameter.

        <result name="VBOX_E_NOT_SUPPORTED">
          Medium format does not support resizing.
        </result>
      </desc>
      <param name="logicalSize" type="unsigned long long" dir="in">
        <desc>New nominal capacity of the medium in megabytes.</desc>
      </param>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

    <method name="reset">
      <desc>
        Starts erasing the contents of this differencing medium.

        This operation will reset the differencing medium to its initial
        state when it does not contain any sector data and any read operation is
        redirected to its parent medium. This automatically gets called
        during VM power-up for every medium whose <link to="#autoReset" />
        attribute is @c true.

        The medium will be write-locked for the duration of this operation (see
        <link to="#lockWrite" />).

        <result name="VBOX_E_NOT_SUPPORTED">
          This is not a differencing medium.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Medium is not in <link to="MediumState_Created"/> or
          <link to="MediumState_Inaccessible"/> state.
        </result>
      </desc>
      <param name="progress" type="IProgress" dir="return">
        <desc>Progress object to track the operation completion.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IMediumFormat
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="DataType"
    uuid="d90ea51e-a3f1-4a01-beb1-c1723c0d3ba7"
  >
    <const name="Int32" value="0"/>
    <const name="Int8" value="1"/>
    <const name="String" value="2"/>
  </enum>

  <enum
    name="DataFlags"
    uuid="86884dcf-1d6b-4f1b-b4bf-f5aa44959d60"
  >
    <const name="None" value="0x00"/>
    <const name="Mandatory" value="0x01"/>
    <const name="Expert" value="0x02"/>
    <const name="Array" value="0x04"/>
    <const name="FlagMask" value="0x07"/>
  </enum>

  <enum
    name="MediumFormatCapabilities"
    uuid="70fcf810-99e8-4edc-aee4-7f51d489e657"
  >
    <desc>
       Medium format capability flags.
    </desc>

    <const name="Uuid" value="0x01">
      <desc>
        Supports UUIDs as expected by VirtualBox code.
      </desc>
    </const>

    <const name="CreateFixed" value="0x02">
      <desc>
        Supports creating fixed size images, allocating all space instantly.
      </desc>
    </const>

    <const name="CreateDynamic" value="0x04">
      <desc>
        Supports creating dynamically growing images, allocating space on
        demand.
      </desc>
    </const>

    <const name="CreateSplit2G" value="0x08">
      <desc>
        Supports creating images split in chunks of a bit less than 2 GBytes.
      </desc>
    </const>

    <const name="Differencing" value="0x10">
      <desc>
        Supports being used as a format for differencing media (see <link
        to="IMedium::createDiffStorage"/>).
      </desc>
    </const>

    <const name="Asynchronous" value="0x20">
      <desc>
        Supports asynchronous I/O operations for at least some configurations.
      </desc>
    </const>

    <const name="File" value="0x40">
      <desc>
        The format backend operates on files (the <link to="IMedium::location"/>
        attribute of the medium specifies a file used to store medium
        data; for a list of supported file extensions see
        <link to="IMediumFormat::fileExtensions"/>).
      </desc>
    </const>

    <const name="Properties" value="0x80">
      <desc>
        The format backend uses the property interface to configure the storage
        location and properties (the <link to="IMediumFormat::describeProperties"/>
        method is used to get access to properties supported by the given medium format).
      </desc>
    </const>

    <const name="CapabilityMask" value="0xFF"/>
  </enum>

  <interface
     name="IMediumFormat" extends="$unknown"
     uuid="89f52554-d469-4799-9fad-1705e86a08b1"
     wsmap="managed"
     >
    <desc>
        The IMediumFormat interface represents a medium format.

        Each medium format has an associated backend which is used to handle
        media stored in this format. This interface provides information
        about the properties of the associated backend.

        Each medium format is identified by a string represented by the
        <link to="#id"/> attribute. This string is used in calls like
        <link to="IVirtualBox::createHardDisk"/> to specify the desired
        format.

        The list of all supported medium formats can be obtained using
        <link to="ISystemProperties::mediaFormats"/>.

        <see>IMedium</see>
    </desc>

    <attribute name="id" type="wstring" readonly="yes">
      <desc>
        Identifier of this format.

        The format identifier is a non-@c null non-empty ASCII string. Note that
        this string is case-insensitive. This means that, for example, all of
        the following strings:
        <pre>
          "VDI"
          "vdi"
          "VdI"</pre>
        refer to the same medium format.

        This string is used in methods of other interfaces where it is necessary
        to specify a medium format, such as
        <link to="IVirtualBox::createHardDisk"/>.
      </desc>
    </attribute>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>
        Human readable description of this format.

        Mainly for use in file open dialogs.
      </desc>
    </attribute>

    <attribute name="fileExtensions" type="wstring" safearray="yes" readonly="yes">
      <desc>
        Array of strings containing the supported file extensions.

        The first extension in the array is the extension preferred by the
        backend. It is recommended to use this extension when specifying a
        location of the storage unit for a new medium.

        Note that some backends do not work on files, so this array may be
        empty.

        <see>IMediumFormat::capabilities</see>
      </desc>
    </attribute>

    <attribute name="capabilities" type="unsigned long" readonly="yes">
      <desc>
        Capabilities of the format as a set of bit flags.

        For the meaning of individual capability flags see
        <link to="MediumFormatCapabilities"/>.
      </desc>
    </attribute>

    <method name="describeProperties">
      <desc>
        Returns several arrays describing the properties supported by this
        format.

        An element with the given index in each array describes one
        property. Thus, the number of elements in each returned array is the
        same and corresponds to the number of supported properties.

        The returned arrays are filled in only if the
        <link to="MediumFormatCapabilities_Properties"/> flag is set.
        All arguments must be non-@c null.

        <see>DataType</see>
        <see>DataFlags</see>
      </desc>

      <param name="names" type="wstring" safearray="yes" dir="out">
        <desc>Array of property names.</desc>
      </param>
      <param name="description" type="wstring" safearray="yes" dir="out">
        <desc>Array of property descriptions.</desc>
      </param>
      <param name="types" type="DataType" safearray="yes" dir="out">
        <desc>Array of property types.</desc>
      </param>
      <param name="flags" type="unsigned long" safearray="yes" dir="out">
        <desc>Array of property flags.</desc>
      </param>
      <param name="defaults" type="wstring" safearray="yes" dir="out">
        <desc>Array of default property values.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IKeyboard
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IKeyboard" extends="$unknown"
     uuid="2d1a531b-4c6e-49cc-8af6-5c857b78b5d7"
     wsmap="managed"
     >
    <desc>
      The IKeyboard interface represents the virtual machine's keyboard. Used
      in <link to="IConsole::keyboard"/>.

      Use this interface to send keystrokes or the Ctrl-Alt-Del sequence
      to the virtual machine.

    </desc>
    <method name="putScancode">
      <desc>Sends a scancode to the keyboard.

        <result name="VBOX_E_IPRT_ERROR">
          Could not send scan code to virtual keyboard.
        </result>

      </desc>
      <param name="scancode" type="long" dir="in"/>
    </method>

    <method name="putScancodes">
      <desc>Sends an array of scancodes to the keyboard.

        <result name="VBOX_E_IPRT_ERROR">
          Could not send all scan codes to virtual keyboard.
        </result>

      </desc>
      <param name="scancodes" type="long" dir="in" safearray="yes"/>
      <param name="codesStored" type="unsigned long" dir="return"/>
    </method>

    <method name="putCAD">
      <desc>Sends the Ctrl-Alt-Del sequence to the keyboard. This
      function is nothing special, it is just a convenience function
      calling <link to="IKeyboard::putScancodes"/> with the proper scancodes.

        <result name="VBOX_E_IPRT_ERROR">
          Could not send all scan codes to virtual keyboard.
        </result>

      </desc>
    </method>

  </interface>


  <!--
  // IMouse
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="MouseButtonState"
    uuid="9ee094b8-b28a-4d56-a166-973cb588d7f8"
  >
    <desc>
      Mouse button state.
    </desc>

    <const name="LeftButton"        value="0x01"/>
    <const name="RightButton"       value="0x02"/>
    <const name="MiddleButton"      value="0x04"/>
    <const name="WheelUp"           value="0x08"/>
    <const name="WheelDown"         value="0x10"/>
    <const name="XButton1"          value="0x20"/>
    <const name="XButton2"          value="0x40"/>
    <const name="MouseStateMask"    value="0x7F"/>
  </enum>

  <interface
     name="IMouse" extends="$unknown"
     uuid="7c0f2eae-f92d-498c-b802-e1a3763774dc"
     wsmap="managed"
     >
    <desc>
      The IMouse interface represents the virtual machine's mouse. Used in
      <link to="IConsole::mouse"/>.

      Through this interface, the virtual machine's virtual mouse can be
      controlled.
    </desc>

    <attribute name="absoluteSupported" type="boolean" readonly="yes">
      <desc>
        Whether the guest OS supports absolute mouse pointer positioning
        or not.
        <note>
          You can use the <link to="IConsoleCallback::onMouseCapabilityChange"/>
          callback to be instantly informed about changes of this attribute
          during virtual machine execution.
        </note>
        <see><link to="#putMouseEventAbsolute"/></see>
      </desc>
    </attribute>

    <attribute name="relativeSupported" type="boolean" readonly="yes">
      <desc>
        Whether the guest OS supports relative mouse pointer positioning
        or not.
        <note>
          You can use the <link to="IConsoleCallback::onMouseCapabilityChange"/>
          callback to be instantly informed about changes of this attribute
          during virtual machine execution.
        </note>
        <see><link to="#putMouseEvent"/></see>
      </desc>
    </attribute>

    <attribute name="needsHostCursor" type="boolean" readonly="yes">
      <desc>
        Whether the guest OS can currently switch to drawing it's own mouse
        cursor on demand.
        <note>
          You can use the <link to="IConsoleCallback::onMouseCapabilityChange"/>
          callback to be instantly informed about changes of this attribute
          during virtual machine execution.
        </note>
        <see><link to="#putMouseEvent"/></see>
      </desc>
    </attribute>

    <method name="putMouseEvent">
      <desc>
        Initiates a mouse event using relative pointer movements
        along x and y axis.

        <result name="E_ACCESSDENIED">
          Console not powered up.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not send mouse event to virtual mouse.
        </result>

      </desc>

      <param name="dx" type="long" dir="in">
        <desc>
          Amount of pixels the mouse should move to the right.
          Negative values move the mouse to the left.
        </desc>
      </param>
      <param name="dy" type="long" dir="in">
        <desc>
          Amount of pixels the mouse should move downwards.
          Negative values move the mouse upwards.
        </desc>
      </param>
      <param name="dz" type="long" dir="in">
        <desc>
          Amount of mouse wheel moves.
          Positive values describe clockwise wheel rotations,
          negative values describe counterclockwise rotations.
        </desc>
      </param>
      <param name="dw" type="long" dir="in">
        <desc>
          Amount of horizontal mouse wheel moves.
          Positive values describe a movement to the left,
          negative values describe a movement to the right.
        </desc>
      </param>
      <param name="buttonState" type="long" dir="in">
        <desc>
          The current state of mouse buttons. Every bit represents
          a mouse button as follows:
          <table>
            <tr><td>Bit 0 (<tt>0x01</tt>)</td><td>left mouse button</td></tr>
            <tr><td>Bit 1 (<tt>0x02</tt>)</td><td>right mouse button</td></tr>
            <tr><td>Bit 2 (<tt>0x04</tt>)</td><td>middle mouse button</td></tr>
          </table>
          A value of <tt>1</tt> means the corresponding button is pressed.
          otherwise it is released.
        </desc>
      </param>
    </method>

    <method name="putMouseEventAbsolute">
      <desc>
        Positions the mouse pointer using absolute x and y coordinates.
        These coordinates are expressed in pixels and
        start from <tt>[1,1]</tt> which corresponds to the top left
        corner of the virtual display.

        <result name="E_ACCESSDENIED">
          Console not powered up.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not send mouse event to virtual mouse.
        </result>

        <note>
          This method will have effect only if absolute mouse
          positioning is supported by the guest OS.
        </note>

        <see><link to="#absoluteSupported"/></see>
      </desc>

      <param name="x" type="long" dir="in">
        <desc>
          X coordinate of the pointer in pixels, starting from @c 1.
        </desc>
      </param>
      <param name="y" type="long" dir="in">
        <desc>
          Y coordinate of the pointer in pixels, starting from @c 1.
        </desc>
      </param>
      <param name="dz" type="long" dir="in">
        <desc>
          Amount of mouse wheel moves.
          Positive values describe clockwise wheel rotations,
          negative values describe counterclockwise rotations.
        </desc>
      </param>
      <param name="dw" type="long" dir="in">
        <desc>
          Amount of horizontal mouse wheel moves.
          Positive values describe a movement to the left,
          negative values describe a movement to the right.
        </desc>
      </param>
      <param name="buttonState" type="long" dir="in">
        <desc>
          The current state of mouse buttons. Every bit represents
          a mouse button as follows:
          <table>
            <tr><td>Bit 0 (<tt>0x01</tt>)</td><td>left mouse button</td></tr>
            <tr><td>Bit 1 (<tt>0x02</tt>)</td><td>right mouse button</td></tr>
            <tr><td>Bit 2 (<tt>0x04</tt>)</td><td>middle mouse button</td></tr>
          </table>
          A value of @c 1 means the corresponding button is pressed.
          otherwise it is released.
        </desc>
      </param>
    </method>

  </interface>

  <!--
  // IDisplay
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="FramebufferPixelFormat"
    uuid="7acfd5ed-29e3-45e3-8136-73c9224f3d2d"
  >
    <desc>
      Format of the video memory buffer. Constants represented by this enum can
      be used to test for particular values of <link
      to="IFramebuffer::pixelFormat"/>. See also <link
      to="IFramebuffer::requestResize"/>.

      See also www.fourcc.org for more information about FOURCC pixel formats.
    </desc>

    <const name="Opaque"                  value="0">
      <desc>
        Unknown buffer format (the user may not assume any particular format of
        the buffer).
      </desc>
    </const>
    <const name="FOURCC_RGB"              value="0x32424752">
      <desc>
        Basic RGB format (<link to="IFramebuffer::bitsPerPixel"/> determines the
        bit layout).
      </desc>
    </const>
  </enum>

  <interface
     name="IFramebuffer" extends="$unknown"
     uuid="b7ed347a-5765-40a0-ae1c-f543eb4ddeaf"
     wsmap="suppress"
     >
    <attribute name="address" type="octet" mod="ptr" readonly="yes">
      <desc>Address of the start byte of the frame buffer.</desc>
    </attribute>

    <attribute name="width" type="unsigned long" readonly="yes">
      <desc>Frame buffer width, in pixels.</desc>
    </attribute>

    <attribute name="height" type="unsigned long" readonly="yes">
      <desc>Frame buffer height, in pixels.</desc>
    </attribute>

    <attribute name="bitsPerPixel" type="unsigned long" readonly="yes">
      <desc>
        Color depth, in bits per pixel. When <link to="#pixelFormat"/> is <link
        to="FramebufferPixelFormat_FOURCC_RGB">FOURCC_RGB</link>, valid values
        are: 8, 15, 16, 24 and 32.
      </desc>
    </attribute>

    <attribute name="bytesPerLine" type="unsigned long" readonly="yes">
      <desc>
        Scan line size, in bytes. When <link to="#pixelFormat"/> is <link
        to="FramebufferPixelFormat_FOURCC_RGB">FOURCC_RGB</link>, the
        size of the scan line must be aligned to 32 bits.
      </desc>
    </attribute>

    <attribute name="pixelFormat" type="unsigned long" readonly="yes">
      <desc>
        Frame buffer pixel format. It's either one of the values defined by <link
        to="FramebufferPixelFormat"/> or a raw FOURCC code.
        <note>
          This attribute must never return <link
          to="FramebufferPixelFormat_Opaque"/> -- the format of the buffer
          <link to="#address"/> points to must be always known.
        </note>
      </desc>
    </attribute>

    <attribute name="usesGuestVRAM" type="boolean" readonly="yes">
      <desc>
        Defines whether this frame buffer uses the virtual video card's memory
        buffer (guest VRAM) directly or not. See <link
        to="IFramebuffer::requestResize"/> for more information.
      </desc>
    </attribute>

    <attribute name="heightReduction" type="unsigned long" readonly="yes">
      <desc>
        Hint from the frame buffer about how much of the standard
        screen height it wants to use for itself. This information is
        exposed to the guest through the VESA BIOS and VMMDev interface
        so that it can use it for determining its video mode table. It
        is not guaranteed that the guest respects the value.
      </desc>
    </attribute>

    <attribute name="overlay" type="IFramebufferOverlay" readonly="yes">
      <desc>
        An alpha-blended overlay which is superposed over the frame buffer.
        The initial purpose is to allow the display of icons providing
        information about the VM state, including disk activity, in front
        ends which do not have other means of doing that.  The overlay is
        designed to controlled exclusively by IDisplay.  It has no locking
        of its own, and any changes made to it are not guaranteed to be
        visible until the affected portion of IFramebuffer is updated.  The
        overlay can be created lazily the first time it is requested.  This
        attribute can also return @c null to signal that the overlay is not
        implemented.
      </desc>
    </attribute>

    <attribute name="winId" type="unsigned long long" readonly="yes">
      <desc>
        Platform-dependent identifier of the window where context of this
        frame buffer is drawn, or zero if there's no such window.
      </desc>
    </attribute>

    <method name="lock">
      <desc>
        Locks the frame buffer.
        Gets called by the IDisplay object where this frame buffer is
        bound to.
      </desc>
    </method>

    <method name="unlock">
      <desc>
        Unlocks the frame buffer.
        Gets called by the IDisplay object where this frame buffer is
        bound to.
      </desc>
    </method>

    <method name="notifyUpdate">
      <desc>
        Informs about an update.
        Gets called by the display object where this buffer is
        registered.
      </desc>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
    </method>

    <method name="requestResize">
      <desc>
        Requests a size and pixel format change.

        There are two modes of working with the video buffer of the virtual
        machine. The <i>indirect</i> mode implies that the IFramebuffer
        implementation allocates a memory buffer for the requested display mode
        and provides it to the virtual machine. In <i>direct</i> mode, the
        IFramebuffer implementation uses the memory buffer allocated and owned
        by the virtual machine. This buffer represents the video memory of the
        emulated video adapter (so called <i>guest VRAM</i>). The direct mode is
        usually faster because the implementation gets a raw pointer to the
        guest VRAM buffer which it can directly use for visualizing the contents
        of the virtual display, as opposed to the indirect mode where the
        contents of guest VRAM are copied to the memory buffer provided by
        the implementation every time a display update occurs.

        It is important to note that the direct mode is really fast only when
        the implementation uses the given guest VRAM buffer directly, for
        example, by blitting it to the window representing the virtual machine's
        display, which saves at least one copy operation comparing to the
        indirect mode. However, using the guest VRAM buffer directly is not
        always possible: the format and the color depth of this buffer may be
        not supported by the target window, or it may be unknown (opaque) as in
        case of text or non-linear multi-plane VGA video modes. In this case,
        the indirect mode (that is always available) should be used as a
        fallback: when the guest VRAM contents are copied to the
        implementation-provided memory buffer, color and format conversion is
        done automatically by the underlying code.

        The @a pixelFormat parameter defines whether the direct mode is
        available or not. If @a pixelFormat is <link
        to="FramebufferPixelFormat_Opaque"/> then direct access to the guest
        VRAM buffer is not available -- the @a VRAM, @a bitsPerPixel and
        @a bytesPerLine parameters must be ignored and the implementation must use
        the indirect mode (where it provides its own buffer in one of the
        supported formats). In all other cases, @a pixelFormat together with
        @a bitsPerPixel and @a bytesPerLine define the format of the video memory
        buffer pointed to by the @a VRAM parameter and the implementation is
        free to choose which mode to use. To indicate that this frame buffer uses
        the direct mode, the implementation of the <link to="#usesGuestVRAM"/>
        attribute must return @c true and <link to="#address"/> must
        return exactly the same address that is passed in the @a VRAM parameter
        of this method; otherwise it is assumed that the indirect strategy is
        chosen.

        The @a width and @a height parameters represent the size of the
        requested display mode in both modes. In case of indirect mode, the
        provided memory buffer should be big enough to store data of the given
        display mode. In case of direct mode, it is guaranteed that the given
        @a VRAM buffer contains enough space to represent the display mode of the
        given size. Note that this frame buffer's <link to="#width"/> and <link
        to="#height"/> attributes must return exactly the same values as
        passed to this method after the resize is completed (see below).

        The @a finished output parameter determines if the implementation has
        finished resizing the frame buffer or not. If, for some reason, the
        resize cannot be finished immediately during this call, @a finished
        must be set to @c false, and the implementation must call
        <link to="IDisplay::resizeCompleted"/> after it has returned from
        this method as soon as possible. If @a finished is @c false, the
        machine will not call any frame buffer methods until
        <link to="IDisplay::resizeCompleted"/> is called.

        Note that if the direct mode is chosen, the <link to="#bitsPerPixel"/>,
        <link to="#bytesPerLine"/> and <link to="#pixelFormat"/> attributes of
        this frame buffer must return exactly the same values as specified in the
        parameters of this method, after the resize is completed. If the
        indirect mode is chosen, these attributes must return values describing
        the format of the implementation's own memory buffer <link
        to="#address"/> points to. Note also that the <link to="#bitsPerPixel"/>
        value must always correlate with <link to="#pixelFormat"/>. Note that
        the <link to="#pixelFormat"/> attribute must never return <link
        to="FramebufferPixelFormat_Opaque"/> regardless of the selected mode.

        <note>
          This method is called by the IDisplay object under the
          <link to="#lock"/> provided by this IFramebuffer
          implementation. If this method returns @c false in @a finished, then
          this lock is not released until
          <link to="IDisplay::resizeCompleted"/> is called.
        </note>
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Logical screen number. Must be used in the corresponding call to
          <link to="IDisplay::resizeCompleted"/> if this call is made.
        </desc>
      </param>
      <param name="pixelFormat" type="unsigned long" dir="in">
        <desc>
          Pixel format of the memory buffer pointed to by @a VRAM.
          See also <link to="FramebufferPixelFormat"/>.
        </desc>
      </param>
      <param name="VRAM" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the virtual video card's VRAM (may be @c null).</desc>
      </param>
      <param name="bitsPerPixel" type="unsigned long" dir="in">
        <desc>Color depth, bits per pixel.</desc>
      </param>
      <param name="bytesPerLine" type="unsigned long" dir="in">
        <desc>Size of one scan line, in bytes.</desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>Width of the guest display, in pixels.</desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>Height of the guest display, in pixels.</desc>
      </param>
      <param name="finished" type="boolean" dir="return">
        <desc>
          Can the VM start using the new frame buffer immediately
          after this method returns or it should wait for
          <link to="IDisplay::resizeCompleted"/>.
        </desc>
      </param>
    </method>

    <method name="videoModeSupported">
      <desc>
        Returns whether the frame buffer implementation is willing to
        support a given video mode. In case it is not able to render
        the video mode (or for some reason not willing), it should
        return @c false. Usually this method is called when the guest
        asks the VMM device whether a given video mode is supported
        so the information returned is directly exposed to the guest.
        It is important that this method returns very quickly.
      </desc>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="bpp" type="unsigned long" dir="in"/>
      <param name="supported" type="boolean" dir="return"/>
    </method>

    <method name="getVisibleRegion">
      <desc>
        Returns the visible region of this frame buffer.

        If the @a rectangles parameter is @c null then the value of the
        @a count parameter is ignored and the number of elements necessary to
        describe the current visible region is returned in @a countCopied.

        If @a rectangles is not @c null but @a count is less
        than the required number of elements to store region data, the method
        will report a failure. If @a count is equal or greater than the
        required number of elements, then the actual number of elements copied
        to the provided array will be returned in @a countCopied.

        <note>
          The address of the provided array must be in the process space of
          this IFramebuffer object.
        </note>
        <note>
          Method not yet implemented.
        </note>
      </desc>
      <param name="rectangles" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the @c RTRECT array to receive region data.</desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>Number of @c RTRECT elements in the @a rectangles array.</desc>
      </param>
      <param name="countCopied" type="unsigned long" dir="return">
        <desc>Number of elements copied to the @a rectangles array.</desc>
      </param>
    </method>

    <method name="setVisibleRegion">
      <desc>
        Suggests a new visible region to this frame buffer.  This region
        represents the area of the VM display which is a union of regions of
        all top-level windows of the guest operating system running inside the
        VM (if the Guest Additions for this system support this
        functionality). This information may be used by the frontends to
        implement the seamless desktop integration feature.

        <note>
          The address of the provided array must be in the process space of
          this IFramebuffer object.
        </note>
        <note>
          The IFramebuffer implementation must make a copy of the provided
          array of rectangles.
        </note>
        <note>
          Method not yet implemented.
        </note>
      </desc>
      <param name="rectangles" type="octet" mod="ptr" dir="in">
        <desc>Pointer to the @c RTRECT array.</desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>Number of @c RTRECT elements in the @a rectangles array.</desc>
      </param>
    </method>

    <method name="processVHWACommand">
      <desc>
        Posts a Video HW Acceleration Command to the frame buffer for processing.
        The commands used for 2D video acceleration (DDraw surface creation/destroying, blitting, scaling, color covnersion, overlaying, etc.)
        are posted from quest to the host to be processed by the host hardware.

        <note>
          The address of the provided command must be in the process space of
          this IFramebuffer object.
        </note>
      </desc>

      <param name="command" type="octet" mod="ptr" dir="in">
        <desc>Pointer to VBOXVHWACMD containing the command to execute.</desc>
      </param>
    </method>

  </interface>

  <interface
     name="IFramebufferOverlay" extends="IFramebuffer"
     uuid="0bcc1c7e-e415-47d2-bfdb-e4c705fb0f47"
     wsmap="suppress"
     >
    <desc>
      The IFramebufferOverlay interface represents an alpha blended overlay
      for displaying status icons above an IFramebuffer.  It is always created
      not visible, so that it must be explicitly shown.  It only covers a
      portion of the IFramebuffer, determined by its width, height and
      co-ordinates.  It is always in packed pixel little-endian 32bit ARGB (in
      that order) format, and may be written to directly.  Do re-read the
      width though, after setting it, as it may be adjusted (increased) to
      make it more suitable for the front end.
    </desc>
    <attribute name="x" type="unsigned long" readonly="yes">
      <desc>X position of the overlay, relative to the frame buffer.</desc>
    </attribute>

    <attribute name="y" type="unsigned long" readonly="yes">
      <desc>Y position of the overlay, relative to the frame buffer.</desc>
    </attribute>

    <attribute name="visible" type="boolean" readonly="no">
      <desc>
        Whether the overlay is currently visible.
      </desc>
    </attribute>

    <attribute name="alpha" type="unsigned long" readonly="no">
      <desc>
        The global alpha value for the overlay.  This may or may not be
        supported by a given front end.
      </desc>
    </attribute>

    <method name="move">
      <desc>
        Changes the overlay's position relative to the IFramebuffer.
      </desc>
      <param name="x" type="unsigned long" dir="in"/>
      <param name="y" type="unsigned long" dir="in"/>
    </method>

  </interface>

  <interface
     name="IDisplay" extends="$unknown"
     uuid="1fa79e39-0cc9-4ab3-9df3-ed3e96b42496"
     wsmap="managed"
     >
    <desc>
      The IDisplay interface represents the virtual machine's display.

      The object implementing this interface is contained in each
      <link to="IConsole::display"/> attribute and represents the visual
      output of the virtual machine.

      The virtual display supports pluggable output targets represented by the
      IFramebuffer interface. Examples of the output target are a window on
      the host computer or an RDP session's display on a remote computer.
    </desc>
    <method name="getScreenResolution">
      <desc>Queries display width, height and color depth for given screen.</desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="width" type="unsigned long" dir="out"/>
      <param name="height" type="unsigned long" dir="out"/>
      <param name="bitsPerPixel" type="unsigned long" dir="out"/>
    </method>

    <method name="setFramebuffer">
      <desc>
        Sets the framebuffer for given screen.
      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="framebuffer" type="IFramebuffer" dir="in"/>
    </method>

    <method name="getFramebuffer">
      <desc>
        Queries the framebuffer for given screen.
      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="framebuffer" type="IFramebuffer" dir="out"/>
      <param name="xOrigin" type="long" dir="out"/>
      <param name="yOrigin" type="long" dir="out"/>
    </method>

    <method name="setVideoModeHint">
      <desc>
        Asks VirtualBox to request the given video mode from
        the guest. This is just a hint and it cannot be guaranteed
        that the requested resolution will be used. Guest Additions
        are required for the request to be seen by guests. The caller
        should issue the request and wait for a resolution change and
        after a timeout retry.

        Specifying @c 0 for either @a width, @a height or @a bitsPerPixel
        parameters means that the corresponding values should be taken from the
        current video mode (i.e. left unchanged).

        If the guest OS supports multi-monitor configuration then the @a display
        parameter specifies the number of the guest display to send the hint to:
        @c 0 is the primary display, @c 1 is the first secondary and
        so on. If the multi-monitor configuration is not supported, @a display
        must be @c 0.

        <result name="E_INVALIDARG">
          The @a display is not associated with any monitor.
        </result>

      </desc>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
      <param name="bitsPerPixel" type="unsigned long" dir="in"/>
      <param name="display" type="unsigned long" dir="in"/>
    </method>

    <method name="setSeamlessMode">
      <desc>
        Enables or disables seamless guest display rendering (seamless desktop
        integration) mode.
        <note>
          Calling this method has no effect if <link
          to="IGuest::supportsSeamless"/> returns @c false.
        </note>
      </desc>
      <param name="enabled" type="boolean" dir="in"/>
    </method>

    <method name="takeScreenShot">
      <desc>
        Takes a screen shot of the requested size and copies it to the
        32-bpp buffer allocated by the caller and pointed to by @a address.
        A pixel consists of 4 bytes in order: B, G, R, 0.

        <note>This API can be used only by the COM/XPCOM C++ API as it
            requires pointer support. Use <link to="#takeScreenShotToArray" />
            with other language bindings.
        </note>

        <result name="E_NOTIMPL">
          Feature not implemented.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not take a screenshot.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="address" type="octet" mod="ptr" dir="in"/>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
    </method>

    <method name="takeScreenShotToArray">
      <desc>
        Takes a guest screen shot of the requested size and returns it as
        an array of bytes in uncompressed 32-bit RGBA format.
        A pixel consists of 4 bytes in order: R, G, B, 0xFF.

        This API is slow, but could be the only option to get guest screenshot
        for scriptable languages not allowed to manipulate with addresses
        directly.

        <result name="E_NOTIMPL">
          Feature not implemented.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not take a screenshot.
        </result>
      </desc>
      <param name="screenId" type="unsigned long" dir="in">
        <desc>
          Monitor to take screenshot from.
        </desc>
      </param>
      <param name="width" type="unsigned long" dir="in">
        <desc>
          Desired image width.
        </desc>
      </param>
      <param name="height" type="unsigned long" dir="in">
        <desc>
          Desired image height.
        </desc>
      </param>
      <param name="screenData" type="octet" dir="return" safearray="yes">
        <desc>
          Array with resulting screen data.
        </desc>
      </param>
    </method>

    <method name="drawToScreen">
      <desc>
        Draws a 32-bpp image of the specified size from the given buffer
        to the given point on the VM display.

        <result name="E_NOTIMPL">
          Feature not implemented.
        </result>
        <result name="VBOX_E_IPRT_ERROR">
          Could not draw to screen.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
      <param name="address" type="octet" mod="ptr" dir="in"/>
      <param name="x" type="unsigned long" dir="in">
        <desc>Relative to the screen top left corner.</desc>
      </param>
      <param name="y" type="unsigned long" dir="in">
        <desc>Relative to the screen top left corner.</desc>
      </param>
      <param name="width" type="unsigned long" dir="in"/>
      <param name="height" type="unsigned long" dir="in"/>
    </method>

    <method name="invalidateAndUpdate">
      <desc>
        Does a full invalidation of the VM display and instructs the VM
        to update it.

        <result name="VBOX_E_IPRT_ERROR">
          Could not invalidate and update screen.
        </result>

      </desc>
    </method>

    <method name="resizeCompleted">
      <desc>
        Signals that a framebuffer has completed the resize operation.

        <result name="VBOX_E_NOT_SUPPORTED">
          Operation only valid for external frame buffers.
        </result>

      </desc>
      <param name="screenId" type="unsigned long" dir="in"/>
    </method>

    <method name="completeVHWACommand">
      <desc>
        Signals that the Video HW Acceleration command has completed.
      </desc>

      <param name="command" type="octet" mod="ptr" dir="in">
        <desc>Pointer to VBOXVHWACMD containing the completed command.</desc>
      </param>
    </method>

  </interface>

  <!--
  // INetworkAdapter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="NetworkAttachmentType"
    uuid="44bce1ee-99f7-4e8e-89fc-80597fd9eeaf"
  >
    <desc>
      Network attachment type.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value, also means "not attached".</desc>
    </const>
    <const name="NAT"                   value="1"/>
    <const name="Bridged"               value="2"/>
    <const name="Internal"              value="3"/>
    <const name="HostOnly"              value="4"/>
    <const name="VDE"                   value="5"/>
  </enum>

  <enum
    name="NetworkAdapterType"
    uuid="3c2281e4-d952-4e87-8c7d-24379cb6a81c"
  >
    <desc>
      Network adapter type.
    </desc>

    <const name="Null"                  value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Am79C970A"             value="1">
        <desc>AMD PCNet-PCI II network card (Am79C970A).</desc>
    </const>
    <const name="Am79C973"              value="2">
        <desc>AMD PCNet-FAST III network card (Am79C973).</desc>
    </const>
    <const name="I82540EM"              value="3">
        <desc>Intel PRO/1000 MT Desktop network card (82540EM).</desc>
    </const>
    <const name="I82543GC"              value="4">
        <desc>Intel PRO/1000 T Server network card (82543GC).</desc>
    </const>
    <const name="I82545EM"              value="5">
        <desc>Intel PRO/1000 MT Server network card (82545EM).</desc>
    </const>
    <const name="Virtio"                value="6">
        <desc>Virtio network device.</desc>
    </const>
  </enum>

  <interface
     name="INetworkAdapter" extends="$unknown"
     uuid="5bdb9df8-a5e1-4322-a139-b7a4a734c790"
     wsmap="managed"
     >
    <desc>
        Represents a virtual network adapter that is attached to a virtual machine.
        Each virtual machine has a fixed number of network adapter slots with one
        instance of this attached to each of them. Call
        <link to="IMachine::getNetworkAdapter" /> to get the network adapter that
        is attached to a given slot in a given machine.

        Each network adapter can be in one of five attachment modes, which are
        represented by the <link to="NetworkAttachmentType" /> enumeration;
        see the <link to="#attachmentType" /> attribute.
    </desc>

    <attribute name="adapterType" type="NetworkAdapterType">
      <desc>
        Type of the virtual network adapter. Depending on this value,
        VirtualBox will provide a different virtual network hardware
        to the guest.
      </desc>
    </attribute>

    <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this adapter is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getNetworkAdapter"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the network adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain this network adapter. Can only be changed when
        the VM is not running.
      </desc>
    </attribute>

    <attribute name="MACAddress" type="wstring">
      <desc>
        Ethernet MAC address of the adapter, 12 hexadecimal characters. When setting
        it to @c null or an empty string, VirtualBox will generate a unique MAC address.
      </desc>
    </attribute>

    <attribute name="attachmentType" type="NetworkAttachmentType" readonly="yes"/>

    <attribute name="hostInterface" type="wstring">
      <desc>
        Name of the host network interface the VM is attached to.
      </desc>
    </attribute>

    <attribute name="internalNetwork" type="wstring">
      <desc>
        Name of the internal network the VM is attached to.
      </desc>
    </attribute>

    <attribute name="NATNetwork" type="wstring">
      <desc>
        Name of the NAT network the VM is attached to.
      </desc>
    </attribute>

    <attribute name="VDENetwork" type="wstring">
      <desc>
        Name of the VDE switch the VM is attached to.
      </desc>
    </attribute>

    <attribute name="cableConnected" type="boolean">
      <desc>
        Flag whether the adapter reports the cable as connected or not.
        It can be used to report offline situations to a VM.
      </desc>
    </attribute>

    <attribute name="lineSpeed" type="unsigned long">
      <desc>
        Line speed reported by custom drivers, in units of 1 kbps.
      </desc>
    </attribute>

    <attribute name="traceEnabled" type="boolean">
      <desc>
        Flag whether network traffic from/to the network card should be traced.
        Can only be toggled when the VM is turned off.
      </desc>
    </attribute>

    <attribute name="traceFile" type="wstring">
      <desc>
        Filename where a network trace will be stored. If not set, VBox-pid.pcap
        will be used.
      </desc>
    </attribute>

    <attribute name="natDriver" type="INATEngine" readonly="yes">
      <desc>
        Points to the NAT engine which handles the network address translation
        for this interface. This is active only when the interface actually uses
        NAT (see <link to="#attachToNAT" />).
      </desc>
    </attribute>

    <attribute name="bootPriority" type="unsigned long">
      <desc>
        Network boot priority of the adapter. Priority 1 is highest. If not set,
        the priority is considered to be at the lowest possible setting.
      </desc>
    </attribute>

    <method name="attachToNAT">
      <desc>
        Attach the network adapter to the Network Address Translation (NAT) interface.
      </desc>
    </method>

    <method name="attachToBridgedInterface">
      <desc>
        Attach the network adapter to a bridged host interface.
      </desc>
    </method>

    <method name="attachToInternalNetwork">
      <desc>
        Attach the network adapter to an internal network.
      </desc>
    </method>

    <method name="attachToHostOnlyInterface">
      <desc>
        Attach the network adapter to the host-only network.
      </desc>
    </method>

    <method name="attachToVDE">
      <desc>
        Attach the network adapter to a VDE network.
      </desc>
    </method>

    <method name="detach">
      <desc>
        Detach the network adapter
      </desc>
    </method>
  </interface>


  <!--
  // ISerialPort
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="PortMode"
    uuid="533b5fe3-0185-4197-86a7-17e37dd39d76"
  >
    <desc>
      The PortMode enumeration represents possible communication modes for
      the virtual serial port device.
    </desc>

    <const name="Disconnected"        value="0">
      <desc>Virtual device is not attached to any real host device.</desc>
    </const>
    <const name="HostPipe"            value="1">
      <desc>Virtual device is attached to a host pipe.</desc>
    </const>
    <const name="HostDevice"          value="2">
      <desc>Virtual device is attached to a host device.</desc>
    </const>
    <const name="RawFile"             value="3">
      <desc>Virtual device is attached to a raw file.</desc>
    </const>
  </enum>

  <interface
     name="ISerialPort" extends="$unknown"
     uuid="937f6970-5103-4745-b78e-d28dcf1479a8"
     wsmap="managed"
     >

    <desc>
      The ISerialPort interface represents the virtual serial port device.

      The virtual serial port device acts like an ordinary serial port
      inside the virtual machine. This device communicates to the real
      serial port hardware in one of two modes: host pipe or host device.

      In host pipe mode, the #path attribute specifies the path to the pipe on
      the host computer that represents a serial port. The #server attribute
      determines if this pipe is created by the virtual machine process at
      machine startup or it must already exist before starting machine
      execution.

      In host device mode, the #path attribute specifies the name of the
      serial port device on the host computer.

      There is also a third communication mode: the disconnected mode. In this
      mode, the guest OS running inside the virtual machine will be able to
      detect the serial port, but all port write operations will be discarded
      and all port read operations will return no data.

      <see>IMachine::getSerialPort</see>
    </desc>

     <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this serial port is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getSerialPort"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the serial port is enabled. If disabled,
        the serial port will not be reported to the guest OS.
      </desc>
    </attribute>

    <attribute name="IOBase" type="unsigned long">
      <desc>Base I/O address of the serial port.</desc>
    </attribute>

    <attribute name="IRQ" type="unsigned long">
      <desc>IRQ number of the serial port.</desc>
    </attribute>

    <attribute name="hostMode" type="PortMode">
      <desc>
        How is this port connected to the host.
        <note>
          Changing this attribute may fail if the conditions for
          <link to="#path"/> are not met.
        </note>
      </desc>
    </attribute>

    <attribute name="server" type="boolean">
      <desc>
        Flag whether this serial port acts as a server (creates a new pipe on
        the host) or as a client (uses the existing pipe). This attribute is
        used only when <link to="#hostMode"/> is PortMode_HostPipe.
      </desc>
    </attribute>

    <attribute name="path" type="wstring">
      <desc>
        Path to the serial port's pipe on the host when <link to="ISerialPort::hostMode"/> is
        PortMode_HostPipe, or the host serial device name when
        <link to="ISerialPort::hostMode"/> is PortMode_HostDevice. For both
        cases, setting a @c null or empty string as the attribute's value
        is an error. Otherwise, the value of this property is ignored.
      </desc>
    </attribute>

  </interface>

  <!--
  // IParallelPort
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IParallelPort" extends="$unknown"
     uuid="0c925f06-dd10-4b77-8de8-294d738c3214"
     wsmap="managed"
     >

    <desc>
      The IParallelPort interface represents the virtual parallel port device.

      The virtual parallel port device acts like an ordinary parallel port
      inside the virtual machine. This device communicates to the real
      parallel port hardware using the name of the parallel device on the host
      computer specified in the #path attribute.

      Each virtual parallel port device is assigned a base I/O address and an
      IRQ number that will be reported to the guest operating system and used
      to operate the given parallel port from within the virtual machine.

      <see>IMachine::getParallelPort</see>
    </desc>

     <attribute name="slot" type="unsigned long" readonly="yes">
      <desc>
        Slot number this parallel port is plugged into. Corresponds to
        the value you pass to <link to="IMachine::getParallelPort"/>
        to obtain this instance.
      </desc>
    </attribute>

    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the parallel port is enabled. If disabled,
        the parallel port will not be reported to the guest OS.
      </desc>
    </attribute>

    <attribute name="IOBase" type="unsigned long">
      <desc>Base I/O address of the parallel port.</desc>
    </attribute>

    <attribute name="IRQ" type="unsigned long">
      <desc>IRQ number of the parallel port.</desc>
    </attribute>

    <attribute name="path" type="wstring">
      <desc>
        Host parallel device name. If this parallel port is enabled, setting a
        @c null or an empty string as this attribute's value will result into
        an error.
      </desc>
    </attribute>

  </interface>


  <!--
  // IMachineDebugger
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IMachineDebugger" extends="$unknown"
     uuid="b0b2a2dd-0627-4502-91c2-ddc5e77609e0"
     wsmap="suppress"
     >
    <method name="resetStats">
      <desc>
        Reset VM statistics.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
    </method>

    <method name="dumpStats">
      <desc>
        Dumps VM statistics.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
    </method>

    <method name="getStats">
      <desc>
        Get the VM statistics in a XMLish format.
      </desc>
      <param name="pattern" type="wstring" dir="in">
        <desc>The selection pattern. A bit similar to filename globbing.</desc>
      </param>
      <param name="withDescriptions" type="boolean" dir="in">
        <desc>Whether to include the descriptions.</desc>
      </param>
      <param name="stats" type="wstring" dir="out">
        <desc>The XML document containing the statistics.</desc>
      </param>
    </method>

    <method name="injectNMI">
      <desc>
        Inject an NMI into a running VT-x/AMD-V VM.
      </desc>
    </method>

    <attribute name="singlestep" type="boolean">
      <desc>Switch for enabling singlestepping.</desc>
    </attribute>

    <attribute name="recompileUser" type="boolean">
      <desc>Switch for forcing code recompilation for user mode code.</desc>
    </attribute>

    <attribute name="recompileSupervisor" type="boolean">
      <desc>Switch for forcing code recompilation for supervisor mode code.</desc>
    </attribute>

    <attribute name="PATMEnabled" type="boolean">
      <desc>Switch for enabling and disabling the PATM component.</desc>
    </attribute>

    <attribute name="CSAMEnabled" type="boolean">
      <desc>Switch for enabling and disabling the CSAM component.</desc>
    </attribute>

    <attribute name="logEnabled" type="boolean">
      <desc>Switch for enabling and disabling logging.</desc>
    </attribute>

    <attribute name="HWVirtExEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of CPU hardware
        virtualization extensions.
      </desc>
    </attribute>

    <attribute name="HWVirtExNestedPagingEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of the nested paging
        CPU hardware virtualization extension.
      </desc>
    </attribute>

    <attribute name="HWVirtExVPIDEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of the VPID
        VT-x extension.
      </desc>
    </attribute>

    <attribute name="PAEEnabled" type="boolean" readonly="yes">
      <desc>
        Flag indicating whether the VM is currently making use of the Physical
        Address Extension CPU feature.
      </desc>
    </attribute>

    <attribute name="virtualTimeRate" type="unsigned long">
      <desc>
        The rate at which the virtual time runs expressed as a percentage.
        The accepted range is 2% to 20000%.
      </desc>
    </attribute>

    <!-- @todo method for setting log flags, groups and destination! -->

    <attribute name="VM" type="unsigned long long" readonly="yes">
      <desc>
        Gets the VM handle. This is only for internal use while
        we carve the details of this interface.
      </desc>
    </attribute>

  </interface>

  <!--
  // IUSBController
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IUSBController" extends="$unknown"
     uuid="6fdcccc5-abd3-4fec-9387-2ad3914fc4a8"
     wsmap="managed"
     >
    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the USB controller is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any USB controller. Can only be changed when
        the VM is powered off.
      </desc>
    </attribute>

    <attribute name="enabledEhci" type="boolean">
      <desc>
        Flag whether the USB EHCI controller is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain a USB EHCI controller. Can only be changed when
        the VM is powered off.
      </desc>
    </attribute>

    <attribute name="proxyAvailable" type="boolean" readonly="yes">
      <desc>
        Flag whether there is an USB proxy available.
      </desc>
    </attribute>

    <attribute name="USBStandard" type="unsigned short" readonly="yes">
      <desc>
        USB standard version which the controller implements.
        This is a BCD which means that the major version is in the
        high byte and minor version is in the low byte.
      </desc>
    </attribute>

    <attribute name="deviceFilters" type="IUSBDeviceFilter" readonly="yes" safearray="yes">
      <desc>
        List of USB device filters associated with the machine.

        If the machine is currently running, these filters are activated
        every time a new (supported) USB device is attached to the host
        computer that was not ignored by global filters
        (<link to="IHost::USBDeviceFilters"/>).

        These filters are also activated when the machine is powered up.
        They are run against a list of all currently available USB
        devices (in states
        <link to="USBDeviceState_Available"/>,
        <link to="USBDeviceState_Busy"/>,
        <link to="USBDeviceState_Held"/>) that were not previously
        ignored by global filters.

        If at least one filter matches the USB device in question, this
        device is automatically captured (attached to) the virtual USB
        controller of this machine.

        <see>IUSBDeviceFilter, ::IUSBController</see>
      </desc>
    </attribute>

    <method name="createDeviceFilter">
      <desc>
        Creates a new USB device filter. All attributes except
        the filter name are set to empty (any match),
        <i>active</i> is @c false (the filter is not active).

        The created filter can then be added to the list of filters using
        <link to="#insertDeviceFilter"/>.

        <result name="VBOX_E_INVALID_VM_STATE">
          The virtual machine is not mutable.
        </result>

        <see>#deviceFilters</see>
      </desc>
      <param name="name" type="wstring" dir="in">
        <desc>
          Filter name. See <link to="IUSBDeviceFilter::name"/>
          for more info.
        </desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="return">
        <desc>Created filter object.</desc>
      </param>
    </method>

    <method name="insertDeviceFilter">
      <desc>
        Inserts the given USB device to the specified position
        in the list of filters.

        Positions are numbered starting from <tt>0</tt>. If the specified
        position is equal to or greater than the number of elements in
        the list, the filter is added to the end of the collection.

        <note>
          Duplicates are not allowed, so an attempt to insert a
          filter that is already in the collection, will return an
          error.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>
        <result name="E_INVALIDARG">
          USB device filter not created within this VirtualBox instance.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          USB device filter already in list.
        </result>

        <see>#deviceFilters</see>
      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to insert the filter to.</desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="in">
        <desc>USB device filter to insert.</desc>
      </param>
    </method>

    <method name="removeDeviceFilter">
      <desc>
        Removes a USB device filter from the specified position in the
        list of filters.

        Positions are numbered starting from <tt>0</tt>. Specifying a
        position equal to or greater than the number of elements in
        the list will produce an error.

        <see>#deviceFilters</see>

        <result name="VBOX_E_INVALID_VM_STATE">
          Virtual machine is not mutable.
        </result>
        <result name="E_INVALIDARG">
          USB device filter list empty or invalid @a position.
        </result>

      </desc>
      <param name="position" type="unsigned long" dir="in">
        <desc>Position to remove the filter from.</desc>
      </param>
      <param name="filter" type="IUSBDeviceFilter" dir="return">
        <desc>Removed USB device filter.</desc>
      </param>
    </method>

  </interface>


  <!--
  // IUSBDevice
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IUSBDevice" extends="$unknown"
     uuid="f8967b0b-4483-400f-92b5-8b675d98a85b"
     wsmap="managed"
     >
    <desc>
      The IUSBDevice interface represents a virtual USB device attached to the
      virtual machine.

      A collection of objects implementing this interface is stored in the
      <link to="IConsole::USBDevices"/> attribute which lists all USB devices
      attached to a running virtual machine's USB controller.
    </desc>

    <attribute name="id" type="uuid" mod="string" readonly="yes">
      <desc>
        Unique USB device ID. This ID is built from #vendorId,
        #productId, #revision and #serialNumber.
      </desc>
    </attribute>

    <attribute name="vendorId" type="unsigned short" readonly="yes">
      <desc>Vendor ID.</desc>
    </attribute>

    <attribute name="productId" type="unsigned short" readonly="yes">
      <desc>Product ID.</desc>
    </attribute>

    <attribute name="revision" type="unsigned short" readonly="yes">
      <desc>
        Product revision number. This is a packed BCD represented as
        unsigned short. The high byte is the integer part and the low
        byte is the decimal.
      </desc>
    </attribute>

    <attribute name="manufacturer" type="wstring" readonly="yes">
      <desc>Manufacturer string.</desc>
    </attribute>

    <attribute name="product" type="wstring" readonly="yes">
      <desc>Product string.</desc>
    </attribute>

    <attribute name="serialNumber" type="wstring" readonly="yes">
      <desc>Serial number string.</desc>
    </attribute>

    <attribute name="address" type="wstring" readonly="yes">
      <desc>Host specific address of the device.</desc>
    </attribute>

    <attribute name="port" type="unsigned short" readonly="yes">
      <desc>
        Host USB port number the device is physically
        connected to.
      </desc>
    </attribute>

    <attribute name="version" type="unsigned short" readonly="yes">
      <desc>
        The major USB version of the device - 1 or 2.
      </desc>
    </attribute>

    <attribute name="portVersion" type="unsigned short" readonly="yes">
      <desc>
        The major USB version of the host USB port the device is
        physically connected to - 1 or 2. For devices not connected to
        anything this will have the same value as the version attribute.
      </desc>
    </attribute>

    <attribute name="remote" type="boolean" readonly="yes">
      <desc>
        Whether the device is physically connected to a remote VRDP
        client or to a local host machine.
      </desc>
    </attribute>

  </interface>


  <!--
  // IUSBDeviceFilter
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IUSBDeviceFilter" extends="$unknown"
     uuid="d6831fb4-1a94-4c2c-96ef-8d0d6192066d"
     wsmap="managed"
     >
    <desc>
      The IUSBDeviceFilter interface represents an USB device filter used
      to perform actions on a group of USB devices.

      This type of filters is used by running virtual machines to
      automatically capture selected USB devices once they are physically
      attached to the host computer.

      A USB device is matched to the given device filter if and only if all
      attributes of the device match the corresponding attributes of the
      filter (that is, attributes are joined together using the logical AND
      operation). On the other hand, all together, filters in the list of
      filters carry the semantics of the logical OR operation. So if it is
      desirable to create a match like "this vendor id OR this product id",
      one needs to create two filters and specify "any match" (see below)
      for unused attributes.

      All filter attributes used for matching are strings. Each string
      is an expression representing a set of values of the corresponding
      device attribute, that will match the given filter. Currently, the
      following filtering expressions are supported:

      <ul>
        <li><i>Interval filters</i>. Used to specify valid intervals for
          integer device attributes (Vendor ID, Product ID and Revision).
          The format of the string is:

          <tt>int:((m)|([m]-[n]))(,(m)|([m]-[n]))*</tt>

          where <tt>m</tt> and <tt>n</tt> are integer numbers, either in octal
          (starting from <tt>0</tt>), hexadecimal (starting from <tt>0x</tt>)
          or decimal (otherwise) form, so that <tt>m &lt; n</tt>. If <tt>m</tt>
          is omitted before a dash (<tt>-</tt>), the minimum possible integer
          is assumed; if <tt>n</tt> is omitted after a dash, the maximum
          possible integer is assumed.
        </li>
        <li><i>Boolean filters</i>. Used to specify acceptable values for
          boolean device attributes. The format of the string is:

          <tt>true|false|yes|no|0|1</tt>

        </li>
        <li><i>Exact match</i>. Used to specify a single value for the given
          device attribute. Any string that doesn't start with <tt>int:</tt>
          represents the exact match. String device attributes are compared to
          this string including case of symbols. Integer attributes are first
          converted to a string (see individual filter attributes) and then
          compared ignoring case.

        </li>
        <li><i>Any match</i>. Any value of the corresponding device attribute
          will match the given filter. An empty or @c null string is
          used to construct this type of filtering expressions.

        </li>
      </ul>

      <note>
        On the Windows host platform, interval filters are not currently
        available. Also all string filter attributes
        (<link to="#manufacturer"/>, <link to="#product"/>,
        <link to="#serialNumber"/>) are ignored, so they behave as
        <i>any match</i> no matter what string expression is specified.
      </note>

      <see>IUSBController::deviceFilters, IHostUSBDeviceFilter</see>
    </desc>

    <attribute name="name" type="wstring">
      <desc>
        Visible name for this filter.
        This name is used to visually distinguish one filter from another,
        so it can neither be @c null nor an empty string.
      </desc>
    </attribute>

    <attribute name="active" type="boolean">
      <desc>Whether this filter active or has been temporarily disabled.</desc>
    </attribute>

    <attribute name="vendorId" type="wstring">
      <desc>
        <link to="IUSBDevice::vendorId">Vendor ID</link> filter.
        The string representation for the <i>exact matching</i>
        has the form <tt>XXXX</tt>, where <tt>X</tt> is the hex digit
        (including leading zeroes).
      </desc>
    </attribute>

    <attribute name="productId" type="wstring">
      <desc>
        <link to="IUSBDevice::productId">Product ID</link> filter.
        The string representation for the <i>exact matching</i>
        has the form <tt>XXXX</tt>, where <tt>X</tt> is the hex digit
        (including leading zeroes).
      </desc>
    </attribute>

    <attribute name="revision" type="wstring">
      <desc>
        <link to="IUSBDevice::productId">Product revision number</link>
        filter. The string representation for the <i>exact matching</i>
        has the form <tt>IIFF</tt>, where <tt>I</tt> is the decimal digit
        of the integer part of the revision, and <tt>F</tt> is the
        decimal digit of its fractional part (including leading and
        trailing zeros).
        Note that for interval filters, it's best to use the hexadecimal
        form, because the revision is stored as a 16 bit packed BCD value;
        so the expression <tt>int:0x0100-0x0199</tt> will match any
        revision from <tt>1.0</tt> to <tt>1.99</tt>.
      </desc>
    </attribute>

    <attribute name="manufacturer" type="wstring">
      <desc>
        <link to="IUSBDevice::manufacturer">Manufacturer</link> filter.
      </desc>
    </attribute>

    <attribute name="product" type="wstring">
      <desc>
        <link to="IUSBDevice::product">Product</link> filter.
      </desc>
    </attribute>

    <attribute name="serialNumber" type="wstring">
      <desc>
        <link to="IUSBDevice::serialNumber">Serial number</link> filter.
      </desc>
    </attribute>

    <attribute name="port" type="wstring">
      <desc>
        <link to="IUSBDevice::port">Host USB port</link> filter.
      </desc>
    </attribute>

    <attribute name="remote" type="wstring">
      <desc>
        <link to="IUSBDevice::remote">Remote state</link> filter.
        <note>
          This filter makes sense only for machine USB filters,
          i.e. it is ignored by IHostUSBDeviceFilter objects.
        </note>
      </desc>
    </attribute>

    <attribute name="maskedInterfaces" type="unsigned long">
      <desc>
       This is an advanced option for hiding one or more USB interfaces
       from the guest. The value is a bit mask where the bits that are set
       means the corresponding USB interface should be hidden, masked off
       if you like.
       This feature only works on Linux hosts.
      </desc>
    </attribute>

  </interface>


  <!--
  // IHostUSBDevice
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
     name="USBDeviceState"
     uuid="b99a2e65-67fb-4882-82fd-f3e5e8193ab4"
     >
    <desc>
      USB device state. This enumeration represents all possible states
      of the USB device physically attached to the host computer regarding
      its state on the host computer and availability to guest computers
      (all currently running virtual machines).

      Once a supported USB device is attached to the host, global USB
      filters (<link to="IHost::USBDeviceFilters"/>) are activated. They can
      either ignore the device, or put it to USBDeviceState_Held state, or do
      nothing. Unless the device is ignored by global filters, filters of all
      currently running guests (<link to="IUSBController::deviceFilters"/>) are
      activated that can put it to USBDeviceState_Captured state.

      If the device was ignored by global filters, or didn't match
      any filters at all (including guest ones), it is handled by the host
      in a normal way. In this case, the device state is determined by
      the host and can be one of USBDeviceState_Unavailable, USBDeviceState_Busy
      or USBDeviceState_Available, depending on the current device usage.

      Besides auto-capturing based on filters, the device can be manually
      captured by guests (<link to="IConsole::attachUSBDevice"/>) if its
      state is USBDeviceState_Busy, USBDeviceState_Available or
      USBDeviceState_Held.

      <note>
        Due to differences in USB stack implementations in Linux and Win32,
        states USBDeviceState_Busy and USBDeviceState_vailable are applicable
        only to the Linux version of the product. This also means that (<link
        to="IConsole::attachUSBDevice"/>) can only succeed on Win32 if the
        device state is USBDeviceState_Held.
      </note>

      <see>IHostUSBDevice, IHostUSBDeviceFilter</see>
    </desc>

    <const name="NotSupported"          value="0">
      <desc>
        Not supported by the VirtualBox server, not available to guests.
      </desc>
    </const>
    <const name="Unavailable"           value="1">
      <desc>
        Being used by the host computer exclusively,
        not available to guests.
      </desc>
    </const>
    <const name="Busy"                  value="2">
      <desc>
        Being used by the host computer, potentially available to guests.
      </desc>
    </const>
    <const name="Available"             value="3">
      <desc>
        Not used by the host computer, available to guests (the host computer
        can also start using the device at any time).
      </desc>
    </const>
    <const name="Held"                  value="4">
      <desc>
        Held by the VirtualBox server (ignored by the host computer),
        available to guests.
      </desc>
    </const>
    <const name="Captured"              value="5">
      <desc>
        Captured by one of the guest computers, not available
        to anybody else.
      </desc>
    </const>
  </enum>

  <interface
     name="IHostUSBDevice" extends="IUSBDevice"
     uuid="173b4b44-d268-4334-a00d-b6521c9a740a"
     wsmap="managed"
     >
    <desc>
      The IHostUSBDevice interface represents a physical USB device attached
      to the host computer.

      Besides properties inherited from IUSBDevice, this interface adds the
      <link to="#state"/> property that holds the current state of the USB
      device.

      <see>IHost::USBDevices, IHost::USBDeviceFilters</see>
    </desc>

    <attribute name="state" type="USBDeviceState" readonly="yes">
      <desc>
        Current state of the device.
      </desc>
    </attribute>

    <!-- @todo add class, subclass, bandwidth, configs, interfaces endpoints and such later. -->

  </interface>


  <!--
  // IHostUSBDeviceFilter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="USBDeviceFilterAction"
    uuid="cbc30a49-2f4e-43b5-9da6-121320475933"
  >
    <desc>
      Actions for host USB device filters.
      <see>IHostUSBDeviceFilter, USBDeviceState</see>
    </desc>

    <const name="Null"          value="0">
      <desc>Null value (never used by the API).</desc>
    </const>
    <const name="Ignore"        value="1">
      <desc>Ignore the matched USB device.</desc>
    </const>
    <const name="Hold"          value="2">
      <desc>Hold the matched USB device.</desc>
    </const>
  </enum>

  <interface
     name="IHostUSBDeviceFilter" extends="IUSBDeviceFilter"
     uuid="4cc70246-d74a-400f-8222-3900489c0374"
     wsmap="managed"
     >
    <desc>
      The IHostUSBDeviceFilter interface represents a global filter for a
      physical USB device used by the host computer. Used indirectly in
      <link to="IHost::USBDeviceFilters"/>.

      Using filters of this type, the host computer determines the initial
      state of the USB device after it is physically attached to the
      host's USB controller.

      <note>
        The <link to="#remote"/> attribute is ignored by this type of
        filters, because it makes sense only for
        <link to="IUSBController::deviceFilters">machine USB filters</link>.
      </note>

      <see>IHost::USBDeviceFilters</see>
    </desc>

    <attribute name="action" type="USBDeviceFilterAction">
      <desc>
        Action performed by the host when an attached USB device
        matches this filter.
      </desc>
    </attribute>

  </interface>

  <!--
  // IAudioAdapter
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="AudioDriverType"
    uuid="4bcc3d73-c2fe-40db-b72f-0c2ca9d68496"
  >
    <desc>
      Host audio driver type.
    </desc>

    <const name="Null"          value="0">
      <desc>Null value, also means "dummy audio driver".</desc>
    </const>
    <const name="WinMM"         value="1">
        <desc>Windows multimedia (Windows hosts only).</desc>
    </const>
    <const name="OSS"           value="2">
        <desc>Open Sound System (Linux hosts only).</desc>
    </const>
    <const name="ALSA"          value="3">
        <desc>Advanced Linux Sound Architecture (Linux hosts only).</desc>
    </const>
    <const name="DirectSound"   value="4">
        <desc>DirectSound (Windows hosts only).</desc>
    </const>
    <const name="CoreAudio"     value="5">
        <desc>CoreAudio (Mac hosts only).</desc>
    </const>
    <const name="MMPM"          value="6">
        <desc>Reserved for historical reasons.</desc>
    </const>
    <const name="Pulse"         value="7">
        <desc>PulseAudio (Linux hosts only).</desc>
    </const>
    <const name="SolAudio"      value="8">
        <desc>Solaris audio (Solaris hosts only).</desc>
    </const>
  </enum>

  <enum
    name="AudioControllerType"
    uuid="7afd395c-42c3-444e-8788-3ce80292f36c"
  >
    <desc>
      Virtual audio controller type.
    </desc>

    <const name="AC97" value="0"/>
    <const name="SB16" value="1"/>
  </enum>

  <interface
     name="IAudioAdapter" extends="$unknown"
     uuid="921873db-5f3f-4b69-91f9-7be9e535a2cb"
     wsmap="managed"
     >
    <desc>
        The IAudioAdapter interface represents the virtual audio adapter of
        the virtual machine. Used in <link to="IMachine::audioAdapter"/>.
    </desc>
    <attribute name="enabled" type="boolean">
      <desc>
        Flag whether the audio adapter is present in the
        guest system. If disabled, the virtual guest hardware will
        not contain any audio adapter. Can only be changed when
        the VM is not running.
      </desc>
    </attribute>
    <attribute name="audioController" type="AudioControllerType">
      <desc>
        The audio hardware we emulate.
      </desc>
    </attribute>
    <attribute name="audioDriver" type="AudioDriverType">
      <desc>
        Audio driver the adapter is connected to. This setting
        can only be changed when the VM is not running.
      </desc>
    </attribute>
  </interface>

  <!--
  // IVRDPServer
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="VRDPAuthType"
    uuid="3d91887a-b67f-4b33-85bf-2da7ab1ea83a"
  >
    <desc>
      VRDP authentication type.
    </desc>

    <const name="Null"            value="0">
      <desc>Null value, also means "no authentication".</desc>
    </const>
    <const name="External"        value="1"/>
    <const name="Guest"           value="2"/>
  </enum>

  <interface
     name="IVRDPServer" extends="$unknown"
     uuid="7aeeb530-0b08-41fe-835d-9be9ec1dbe5c"
     wsmap="managed"
     >
    <attribute name="enabled" type="boolean">
      <desc>VRDP server status.</desc>
    </attribute>

    <attribute name="ports" type="wstring">
      <desc>
        VRDP server port numbers. The server will try to bind to one of free ports from the list.
        <note>
          This is a string of comma separated TCP port numbers or port number ranges.
          Example <tt>5000,5010-5012,5015</tt>
        </note>
      </desc>
    </attribute>

    <attribute name="netAddress" type="wstring">
      <desc>VRDP server address.</desc>
    </attribute>

    <attribute name="authType" type="VRDPAuthType">
      <desc>VRDP authentication method.</desc>
    </attribute>

    <attribute name="authTimeout" type="unsigned long">
      <desc>Timeout for guest authentication. Milliseconds.</desc>
    </attribute>

    <attribute name="allowMultiConnection" type="boolean">
      <desc>
        Flag whether multiple simultaneous connections to the VM are permitted.
        Note that this will be replaced by a more powerful mechanism in the future.
      </desc>
    </attribute>

    <attribute name="reuseSingleConnection" type="boolean">
      <desc>
        Flag whether the existing connection must be dropped and a new connection
        must be established by the VRDP server, when a new client connects in single
        connection mode.
      </desc>
    </attribute>

    <attribute name="videoChannel" type="boolean">
      <desc>
        Flag whether RDP video channel is supported.
      </desc>
    </attribute>

    <attribute name="videoChannelQuality" type="unsigned long">
      <desc>
        Image quality in percents.
      </desc>
    </attribute>

  </interface>


  <!--
  // ISharedFolder
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="ISharedFolder" extends="$unknown"
     uuid="64637bb2-9e17-471c-b8f3-f8968dd9884e"
     wsmap="struct"
     >
    <desc>
      The ISharedFolder interface represents a folder in the host computer's
      file system accessible from the guest OS running inside a virtual
      machine using an associated logical name.

      There are three types of shared folders:
      <ul>
        <li><i>Global</i> (<link to="IVirtualBox::sharedFolders"/>), shared
        folders available to all virtual machines.</li>
        <li><i>Permanent</i> (<link to="IMachine::sharedFolders"/>),
        VM-specific shared folders available to the given virtual machine at
        startup.</li>
        <li><i>Transient</i> (<link to="IConsole::sharedFolders"/>),
        VM-specific shared folders created in the session context (for
        example, when the virtual machine is running) and automatically
        discarded when the session is closed (the VM is powered off).</li>
      </ul>

      Logical names of shared folders must be unique within the given scope
      (global, permanent or transient). However, they do not need to be unique
      across scopes. In this case, the definition of the shared folder in a
      more specific scope takes precedence over definitions in all other
      scopes. The order of precedence is (more specific to more general):
      <ol>
        <li>Transient definitions</li>
        <li>Permanent definitions</li>
        <li>Global definitions</li>
      </ol>

      For example, if MyMachine has a shared folder named
      <tt>C_DRIVE</tt> (that points to <tt>C:\\</tt>), then creating a
      transient shared folder named <tt>C_DRIVE</tt> (that points
      to <tt>C:\\\\WINDOWS</tt>) will change the definition
      of <tt>C_DRIVE</tt> in the guest OS so
      that <tt>\\\\VBOXSVR\\C_DRIVE</tt> will give access
      to <tt>C:\\WINDOWS</tt> instead of <tt>C:\\</tt> on the host
      PC. Removing the transient shared folder <tt>C_DRIVE</tt> will restore
      the previous (permanent) definition of <tt>C_DRIVE</tt> that points
      to <tt>C:\\</tt> if it still exists.

      Note that permanent and transient shared folders of different machines
      are in different name spaces, so they don't overlap and don't need to
      have unique logical names.

      <note>
        Global shared folders are not implemented in the current version of the
        product.
      </note>
    </desc>

    <attribute name="name" type="wstring" readonly="yes">
      <desc>Logical name of the shared folder.</desc>
    </attribute>

    <attribute name="hostPath" type="wstring" readonly="yes">
      <desc>Full path to the shared folder in the host file system.</desc>
    </attribute>

    <attribute name="accessible" type="boolean" readonly="yes">
      <desc>
        Whether the folder defined by the host path is currently
        accessible or not.
        For example, the folder can be unaccessible if it is placed
        on the network share that is not available by the time
        this property is read.
      </desc>
    </attribute>

    <attribute name="writable" type="boolean" readonly="yes">
      <desc>
        Whether the folder defined by the host path is writable or
        not.
      </desc>
    </attribute>

    <attribute name="lastAccessError" type="wstring" readonly="yes">
      <desc>
        Text message that represents the result of the last accessibility
        check.

        Accessibility checks are performed each time the <link to="#accessible"/>
        attribute is read. An empty string is returned if the last
        accessibility check was successful. A non-empty string indicates a
        failure and should normally describe a reason of the failure (for
        example, a file read error).
      </desc>
    </attribute>

  </interface>

  <!--
  // ISession
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IInternalSessionControl" extends="$unknown"
     uuid="ab161f72-e4b3-44e6-a919-2256474bda66"
     internal="yes"
     wsmap="suppress"
     >
    <method name="getPID">
      <desc>PID of the process that has created this Session object.
      </desc>
      <param name="pid" type="unsigned long" dir="return"/>
    </method>

    <method name="getRemoteConsole">
      <desc>
        Returns the console object suitable for remote control.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="console" type="IConsole" dir="return"/>
    </method>

    <method name="assignMachine">
      <desc>
        Assigns the machine object associated with this direct-type
        session or informs the session that it will be a remote one
        (if @a machine == @c null).

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="machine" type="IMachine" dir="in"/>
    </method>

    <method name="assignRemoteMachine">
      <desc>
        Assigns the machine and the (remote) console object associated with
        this remote-type session.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>

      </desc>
      <param name="machine" type="IMachine" dir="in"/>
      <param name="console" type="IConsole" dir="in"/>
    </method>

    <method name="updateMachineState">
      <desc>
        Updates the machine state in the VM process.
        Must be called only in certain cases
        (see the method implementation).

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="aMachineState" type="MachineState" dir="in"/>
    </method>

    <method name="uninitialize">
      <desc>
        Uninitializes (closes) this session. Used by VirtualBox to close
        the corresponding remote session when the direct session dies
        or gets closed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>

      </desc>
    </method>

    <method name="onNetworkAdapterChange">
      <desc>
        Triggered when settings of a network adapter of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="networkAdapter" type="INetworkAdapter" dir="in"/>
      <param name="changeAdapter" type="boolean" dir="in"/>
    </method>

    <method name="onSerialPortChange">
      <desc>
        Triggered when settings of a serial port of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="serialPort" type="ISerialPort" dir="in"/>
    </method>

    <method name="onParallelPortChange">
      <desc>
        Triggered when settings of a parallel port of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="parallelPort" type="IParallelPort" dir="in"/>
    </method>

    <method name="onStorageControllerChange">
      <desc>
        Triggered when settings of a storage controller of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
    </method>

    <method name="onMediumChange">
      <desc>
        Triggered when attached media of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>

      <param name="mediumAttachment" type="IMediumAttachment" dir="in"/>
      <param name="force" type="boolean" dir="in"/>
    </method>

    <method name="onCPUChange">
      <desc>
        Notification when a CPU changes.
      </desc>
      <param name="cpu" type="unsigned long" dir="in">
        <desc>The CPU which changed</desc>
      </param>
      <param name="add" type="boolean" dir="in">
        <desc>Flag whether the CPU was added or removed</desc>
      </param>
    </method>

    <method name="onVRDPServerChange">
      <desc>
        Triggered when settings of the VRDP server object of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="restart" type="boolean" dir="in">
        <desc>Flag whether the server must be restarted</desc>
      </param>
    </method>

    <method name="onUSBControllerChange">
      <desc>
        Triggered when settings of the USB controller object of the
        associated virtual machine have changed.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
    </method>

    <method name="onSharedFolderChange">
      <desc>
        Triggered when a permanent (global or machine) shared folder has been
        created or removed.
        <note>
          We don't pass shared folder parameters in this notification because
          the order in which parallel notifications are delivered is not defined,
          therefore it could happen that these parameters were outdated by the
          time of processing this notification.
        </note>

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="global" type="boolean" dir="in"/>
    </method>

    <method name="onUSBDeviceAttach">
      <desc>
        Triggered when a request to capture a USB device (as a result
        of matched USB filters or direct call to
        <link to="IConsole::attachUSBDevice"/>) has completed.
        A @c null @a error object means success, otherwise it
        describes a failure.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="device" type="IUSBDevice" dir="in"/>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in"/>
      <param name="maskedInterfaces" type="unsigned long" dir="in"/>
    </method>

    <method name="onUSBDeviceDetach">
      <desc>
        Triggered when a request to release the USB device (as a result
        of machine termination or direct call to
        <link to="IConsole::detachUSBDevice"/>) has completed.
        A @c null @a error object means success, otherwise it
        describes a failure.

        <result name="VBOX_E_INVALID_VM_STATE">
          Session state prevents operation.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="id" type="uuid" mod="string" dir="in"/>
      <param name="error" type="IVirtualBoxErrorInfo" dir="in"/>
    </method>

    <method name="onShowWindow">
      <desc>
        Called by <link to="IMachine::canShowConsoleWindow"/> and by
        <link to="IMachine::showConsoleWindow"/> in order to notify
        console callbacks
        <link to="IConsoleCallback::onCanShowWindow"/>
        and <link to="IConsoleCallback::onShowWindow"/>.

        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type prevents operation.
        </result>

      </desc>
      <param name="check" type="boolean" dir="in"/>
      <param name="canShow" type="boolean" dir="out"/>
      <param name="winId" type="unsigned long long" dir="out"/>
    </method>

    <method name="accessGuestProperty">
      <desc>
        Called by <link to="IMachine::getGuestProperty"/> and by
        <link to="IMachine::setGuestProperty"/> in order to read and
        modify guest properties.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type is not direct.
        </result>

      </desc>
      <param name="name" type="wstring" dir="in"/>
      <param name="value" type="wstring" dir="in"/>
      <param name="flags" type="wstring" dir="in"/>
      <param name="isSetter" type="boolean" dir="in"/>
      <param name="retValue" type="wstring" dir="out"/>
      <param name="retTimestamp" type="unsigned long long" dir="out"/>
      <param name="retFlags" type="wstring" dir="out"/>
    </method>

    <method name="enumerateGuestProperties">
      <desc>
        Return a list of the guest properties matching a set of patterns along
        with their values, time stamps and flags.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type is not direct.
        </result>

      </desc>
      <param name="patterns" type="wstring" dir="in">
        <desc>
          The patterns to match the properties against as a comma-separated
          string.  If this is empty, all properties currently set will be
          returned.
        </desc>
      </param>
      <param name="key" type="wstring" dir="out" safearray="yes">
        <desc>
          The key names of the properties returned.
        </desc>
      </param>
      <param name="value" type="wstring" dir="out" safearray="yes">
        <desc>
          The values of the properties returned.  The array entries match the
          corresponding entries in the @a key array.
        </desc>
      </param>
      <param name="timestamp" type="unsigned long long" dir="out" safearray="yes">
        <desc>
          The time stamps of the properties returned.  The array entries match
          the corresponding entries in the @a key array.
        </desc>
      </param>
      <param name="flags" type="wstring" dir="out" safearray="yes">
        <desc>
          The flags of the properties returned.  The array entries match the
          corresponding entries in the @a key array.
        </desc>
      </param>
    </method>

    <method name="onlineMergeMedium">
      <desc>
        Triggers online merging of a hard disk. Used internally when deleting
        a snapshot while a VM referring to the same hard disk chain is running.

        <result name="VBOX_E_INVALID_VM_STATE">
          Machine session is not open.
        </result>
        <result name="VBOX_E_INVALID_OBJECT_STATE">
          Session type is not direct.
        </result>

      </desc>
      <param name="mediumAttachment" type="IMediumAttachment" dir="in">
        <desc>The medium attachment to identify the medium chain.</desc>
      </param>
      <param name="sourceIdx" type="unsigned long" dir="in">
        <desc>The index of the source image in the chain.
        Redundant, but drastically reduces IPC.</desc>
      </param>
      <param name="targetIdx" type="unsigned long" dir="in">
        <desc>The index of the target image in the chain.
        Redundant, but drastically reduces IPC.</desc>
      </param>
      <param name="source" type="IMedium" dir="in">
        <desc>Merge source medium.</desc>
      </param>
      <param name="target" type="IMedium" dir="in">
        <desc>Merge target medium.</desc>
      </param>
      <param name="mergeForward" type="boolean" dir="in">
        <desc>Merge direction.</desc>
      </param>
      <param name="parentForTarget" type="IMedium" dir="in">
        <desc>For forward merges: new parent for target medium.</desc>
      </param>
      <param name="childrenToReparent" type="IMedium" safearray="yes" dir="in">
        <desc>For backward merges: list of media which need their parent UUID
        updated.</desc>
      </param>
      <param name="progress" type="IProgress" dir="in">
        <desc>
          Progress object for this operation.
        </desc>
      </param>
    </method>

  </interface>

  <interface
     name="ISession" extends="$unknown"
     uuid="12F4DCDB-12B2-4EC1-B7CD-DDD9F6C5BF4D"
     wsmap="managed"
     >
    <desc>
      The ISession interface represents a serialization primitive for virtual
      machines.

      With VirtualBox, every time one wishes to manipulate a virtual machine
      (e.g. change its settings or start execution), a session object is
      required. Such an object must be passed to one of the session methods
      that open the given session, which then initiates the machine manipulation.

      A session serves several purposes: it identifies to the inter-process VirtualBox
      code which process is currently working with the virtual machine, and it ensures
      that there are no incompatible requests from several processes for the
      same virtual machine. Session objects can therefore be thought of as mutex
      semaphores that lock virtual machines to prevent conflicting accesses from
      several processes.

      How sessions objects are used depends on whether you use the Main API
      via COM or via the webservice:

      <ul>
      <li>When using the COM API directly, an object of the Session class from the
      VirtualBox type library needs to be created. In regular COM C++ client code,
      this can be done by calling <tt>createLocalObject()</tt>, a standard COM API.
      This object will  then act as a local session object in further calls to open
      a session.
      </li>

      <li>In the webservice, the session manager (IWebsessionManager) instead creates
      one session object automatically when <link to="IWebsessionManager::logon" />
      is called. A managed object reference to that session object can be retrieved by
      calling <link to="IWebsessionManager::getSessionObject" />. This session object
      reference can then be used to open sessions.
      </li>
      </ul>

      Sessions are mainly used in two variations:

      <ul>
      <li>
      To start a virtual machine in a separate process, one would call
      <link to="IVirtualBox::openRemoteSession"/>, which requires a session
      object as its first parameter. This session then identifies the caller
      and lets him control the started machine (for example, pause machine
      execution or power it down) as well as be notified about machine
      execution state changes.
      </li>

      <li>To alter machine settings, or to start machine execution within the
      current process, one needs to open a direct session for the machine first by
      calling <link to="IVirtualBox::openSession"/>. While a direct session
      is open within one process, no any other process may open another direct
      session for the same machine. This prevents the machine from being changed
      by other processes while it is running or while the machine is being configured.
      </li>
      </ul>

      One also can attach to an existing direct session already opened by
      another process (for example, in order to send a control request to the
      virtual machine such as the pause or the reset request). This is done by
      calling <link to="IVirtualBox::openExistingSession"/>.

      <note>
        Unless you are trying to write a new VirtualBox front-end that
        performs direct machine execution (like the VirtualBox or VBoxSDL
        front-ends), don't call <link to="IConsole::powerUp"/> in a direct
        session opened by <link to="IVirtualBox::openSession"/> and use this
        session only to change virtual machine settings. If you simply want to
        start virtual machine execution using one of the existing front-ends
        (for example the VirtualBox GUI or headless server), simply use
        <link to="IVirtualBox::openRemoteSession"/>; these front-ends
        will power up the machine automatically for you.
      </note>
    </desc>

    <attribute name="state" type="SessionState" readonly="yes">
      <desc>Current state of this session.</desc>
    </attribute>

    <attribute name="type" type="SessionType" readonly="yes">
      <desc>
        Type of this session. The value of this attribute is valid only
        if the session is currently open (i.e. its #state is
        SessionType_SessionOpen), otherwise an error will be returned.
      </desc>
    </attribute>

    <attribute name="machine" type="IMachine" readonly="yes">
      <desc>Machine object associated with this session.</desc>
    </attribute>

    <attribute name="console" type="IConsole" readonly="yes">
      <desc>Console object associated with this session.</desc>
    </attribute>

    <method name="close">
      <desc>
        Closes a session that was previously opened.

        It is recommended that every time an "open session" method (such as
        <link to="IVirtualBox::openRemoteSession" /> or
        <link to="IVirtualBox::openSession" />) has been called to
        manipulate a virtual machine, the caller invoke
        ISession::close() when it's done doing so. Since sessions are
        serialization primitives much like ordinary mutexes, they are
        best used the same way: for each "open" call, there should be
        a matching "close" call, even when errors occur.

        Otherwise, if a direct session for a machine opened with
        <link to="IVirtualBox::openSession"/> is not explicitly closed
        when the application terminates, the state of the machine will
        be set to <link to="MachineState_Aborted" /> on the server.

        Generally, it is recommended to close all open sessions explicitly
        before terminating the application (regardless of the reason for
        the termination).

        <note>
          Do not expect the session state (<link to="ISession::state" />
          to return to "Closed" immediately after you invoke
          ISession::close(), particularly if you have started a remote
          session to execute the VM in a new process. The session state will
          automatically return to "Closed" once the VM is no longer executing,
          which can of course take a very long time.
        </note>

        <result name="E_UNEXPECTED">
          Session is not open.
        </result>

      </desc>
    </method>

  </interface>

  <!--
  // IStorageController
  /////////////////////////////////////////////////////////////////////////
  -->

  <enum
    name="StorageBus"
    uuid="eee67ab3-668d-4ef5-91e0-7025fe4a0d7a"
  >
    <desc>
      The bus type of the storage controller (IDE, SATA, SCSI, SAS or Floppy);
      see <link to="IStorageController::bus" />.
    </desc>
    <const name="Null"         value="0">
      <desc>@c null value. Never used by the API.</desc>
    </const>
    <const name="IDE"       value="1"/>
    <const name="SATA"      value="2"/>
    <const name="SCSI"      value="3"/>
    <const name="Floppy"    value="4"/>
    <const name="SAS"       value="5"/>
  </enum>

  <enum
    name="StorageControllerType"
    uuid="8a412b8a-f43e-4456-bd37-b474f0879a58"
  >
    <desc>
      The exact variant of storage controller hardware presented
      to the guest; see <link to="IStorageController::controllerType" />.
    </desc>

    <const name="Null"         value="0">
      <desc>@c null value. Never used by the API.</desc>
    </const>
    <const name="LsiLogic"  value="1">
      <desc>A SCSI controller of the LsiLogic variant.</desc>
    </const>
    <const name="BusLogic"  value="2">
      <desc>A SCSI controller of the BusLogic variant.</desc>
    </const>
    <const name="IntelAhci" value="3">
      <desc>An Intel AHCI SATA controller; this is the only variant for SATA.</desc>
    </const>
    <const name="PIIX3"     value="4">
      <desc>An IDE controller of the PIIX3 variant.</desc>
    </const>
    <const name="PIIX4"     value="5">
      <desc>An IDE controller of the PIIX4 variant.</desc>
    </const>
    <const name="ICH6"      value="6">
      <desc>An IDE controller of the ICH6 variant.</desc>
    </const>
    <const name="I82078"    value="7">
      <desc>A floppy disk controller; this is the only variant for floppy drives.</desc>
    </const>
    <const name="LsiLogicSas"  value="8">
      <desc>A variant of the LsiLogic controller using SAS.</desc>
    </const>
  </enum>

  <interface
    name="IStorageController" extends="$unknown"
    uuid="fd93adc0-bbaa-4256-9e6e-00e29f9151c9"
    wsmap="managed"
  >
    <desc>
        Represents a storage controller that is attached to a virtual machine
        (<link to="IMachine" />). Just as drives (hard disks, DVDs, FDs) are
        attached to storage controllers in a real computer, virtual drives
        (represented by <link to="IMediumAttachment" />) are attached to virtual
        storage controllers, represented by this interface.

        As opposed to physical hardware, VirtualBox has a very generic concept
        of a storage controller, and for purposes of the Main API, all virtual
        storage is attached to virtual machines via instances of this interface.
        There are five types of such virtual storage controllers: IDE, SCSI, SATA,
        SAS and Floppy (see <link to="#bus" />). Depending on which of these four
        is used, certain sub-types may be available and can be selected in
        <link to="#controllerType" />.

        Depending on these settings, the guest operating system might see
        significantly different virtual hardware.
    </desc>

    <attribute name="name" type="wstring" readonly="yes">
     <desc>
        Name of the storage controller, as originally specified with
        <link to="IMachine::addStorageController" />. This then uniquely
        identifies this controller with other method calls such as
        <link to="IMachine::attachDevice" /> and  <link to="IMachine::mountMedium" />.
      </desc>
    </attribute>

    <attribute name="maxDevicesPerPortCount" type="unsigned long" readonly="yes">
      <desc>
        Maximum number of devices which can be attached to one port.
      </desc>
    </attribute>

    <attribute name="minPortCount" type="unsigned long" readonly="yes">
      <desc>
        Minimum number of ports that <link to="IStorageController::portCount"/> can be set to.
      </desc>
    </attribute>

    <attribute name="maxPortCount" type="unsigned long" readonly="yes">
      <desc>
        Maximum number of ports that <link to="IStorageController::portCount"/> can be set to.
      </desc>
    </attribute>

    <attribute name="instance" type="unsigned long">
      <desc>
        The instance number of the device in the running VM.
      </desc>
    </attribute>

    <attribute name="portCount" type="unsigned long">
      <desc>
        The number of currently usable ports on the controller.
        The minimum and maximum number of ports for one controller are
        stored in <link to="IStorageController::minPortCount"/>
        and <link to="IStorageController::maxPortCount"/>.
      </desc>
    </attribute>

    <attribute name="bus" type="StorageBus" readonly="yes">
      <desc>
        The bus type of the storage controller (IDE, SATA, SCSI, SAS or Floppy).
      </desc>
    </attribute>

    <attribute name="controllerType" type="StorageControllerType">
      <desc>
        The exact variant of storage controller hardware presented
        to the guest.
        Depending on this value, VirtualBox will provide a different
        virtual storage controller hardware to the guest.
        For SATA, SAS and floppy controllers, only one variant is
        available, but for IDE and SCSI, there are several.

        For SCSI controllers, the default type is LsiLogic.
      </desc>
    </attribute>

    <attribute name="useHostIOCache" type="boolean">
      <desc>
        If true, the storage controller emulation will use a dedicated I/O thread, enable the host I/O
        caches and use synchronous file APIs on the host. This was the only option in the API before
        VirtualBox 3.2 and is still the default for IDE controllers.

        If false, the host I/O cache will be disabled for image files attached to this storage controller.
        Instead, the storage controller emulation will use asynchronous I/O APIs on the host. This makes
        it possible to turn off the host I/O caches because the emulation can handle unaligned access to
        the file. This should be used on OS X and Linux hosts if a high I/O load is expected or many
        virtual machines are running at the same time to prevent I/O cache related hangs.
        This option new with the API of VirtualBox 3.2 and is now the default for non-IDE storage controllers.
      </desc>
    </attribute>

    <method name="getIDEEmulationPort">
      <desc>
        Gets the corresponding port number which is emulated as an IDE device.
        Works only with SATA controllers.

        <result name="E_INVALIDARG">
          The @a devicePosition is not in the range 0 to 3.
        </result>
        <result name="E_NOTIMPL">
          The storage controller type is not SATAIntelAhci.
        </result>

      </desc>
      <param name="devicePosition" type="long" dir="in"/>
      <param name="portNumber" type="long" dir="return"/>
    </method>

    <method name="setIDEEmulationPort">
      <desc>
        Sets the port number which is emulated as an IDE device.
        Works only with SATA controllers.

        <result name="E_INVALIDARG">
          The @a devicePosition is not in the range 0 to 3 or the
          @a portNumber is not in the range 0 to 29.
        </result>
        <result name="E_NOTIMPL">
          The storage controller type is not SATAIntelAhci.
        </result>

      </desc>
      <param name="devicePosition" type="long" dir="in"/>
      <param name="portNumber" type="long" dir="in"/>
    </method>

  </interface>

<if target="wsdl">

  <!--
  // IManagedObjectRef
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IManagedObjectRef" extends="$unknown"
     uuid="9474d09d-2313-46de-b568-a42b8718e8ed"
     internal="yes"
     wsmap="managed"
     wscpp="hardcoded"
     >
    <desc>
      Managed object reference.

      Only within the webservice, a managed object reference (which is really
      an opaque number) allows a webservice client to address an object
      that lives in the address space of the webservice server.

      Behind each managed object reference, there is a COM object that lives
      in the webservice server's address space. The COM object is not freed
      until the managed object reference is released, either by an explicit
      call to  <link to="IManagedObjectRef::release" /> or by logging off from
      the webservice (<link to="IWebsessionManager::logoff" />), which releases
      all objects created during the webservice session.

      Whenever a method call of the VirtualBox API returns a COM object, the
      webservice representation of that method will instead return a
      managed object reference, which can then be used to invoke methods
      on that object.
    </desc>

    <method name="getInterfaceName">
      <desc>
        Returns the name of the interface that this managed object represents,
        for example, "IMachine", as a string.
      </desc>
      <param name="return" type="wstring" dir="return"/>
    </method>

    <method name="release">
      <desc>
        Releases this managed object reference and frees the resources that
        were allocated for it in the webservice server process. After calling
        this method, the identifier of the reference can no longer be used.
      </desc>
    </method>

  </interface>

  <!--
  // IWebsessionManager
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
     name="IWebsessionManager" extends="$unknown"
     uuid="dea1b4c7-2de3-418a-850d-7868617f7733"
     internal="yes"
     wsmap="global"
     wscpp="hardcoded"
     >
    <desc>
      Websession manager. This provides essential services
      to webservice clients.
    </desc>
    <method name="logon">
      <desc>
        Logs a new client onto the webservice and returns a managed object reference to
        the IVirtualBox instance, which the client can then use as a basis to further
        queries, since all calls to the VirtualBox API are based on the IVirtualBox
        interface, in one way or the other.
      </desc>
      <param name="username" type="wstring" dir="in"/>
      <param name="password" type="wstring" dir="in"/>
      <param name="return" type="IVirtualBox" dir="return"/>
    </method>

    <method name="getSessionObject">
      <desc>
        Returns a managed object reference to the internal ISession object that was created
        for this web service session when the client logged on.

        <see>ISession</see>
      </desc>
      <param name="refIVirtualBox" type="IVirtualBox" dir="in"/>
      <param name="return" type="ISession" dir="return"/>
    </method>

    <method name="logoff">
      <desc>
        Logs off the client who has previously logged on with <link to="IWebsessionManager::logoff" />
        and destroys all resources associated with the session (most importantly, all
        managed objects created in the server while the session was active).
      </desc>
      <param name="refIVirtualBox" type="IVirtualBox" dir="in"/>
    </method>

  </interface>

</if>

  <!--
  // IPerformanceCollector & friends
  /////////////////////////////////////////////////////////////////////////
  -->

  <interface
    name="IPerformanceMetric" extends="$unknown"
    uuid="2a1a60ae-9345-4019-ad53-d34ba41cbfe9" wsmap="managed"
  >
    <desc>
      The IPerformanceMetric interface represents parameters of the given
      performance metric.
    </desc>

    <attribute name="metricName" type="wstring" readonly="yes">
      <desc>
        Name of the metric.
      </desc>
    </attribute>

    <attribute name="object" type="$unknown" readonly="yes">
      <desc>
        Object this metric belongs to.
      </desc>
    </attribute>

    <attribute name="description" type="wstring" readonly="yes">
      <desc>
        Textual description of the metric.
      </desc>
    </attribute>

    <attribute name="period" type="unsigned long" readonly="yes">
      <desc>
        Time interval between samples, measured in seconds.
      </desc>
    </attribute>

    <attribute name="count" type="unsigned long" readonly="yes">
      <desc>
        Number of recent samples retained by the performance collector for this
        metric.

        When the collected sample count exceeds this number, older samples
        are discarded.
      </desc>
    </attribute>

    <attribute name="unit" type="wstring" readonly="yes">
      <desc>
        Unit of measurement.
      </desc>
    </attribute>

    <attribute name="minimumValue" type="long" readonly="yes">
      <desc>
        Minimum possible value of this metric.
      </desc>
    </attribute>

    <attribute name="maximumValue" type="long" readonly="yes">
      <desc>
        Maximum possible value of this metric.
      </desc>
    </attribute>
  </interface>

  <interface
    name="IPerformanceCollector" extends="$unknown"
    uuid="e22e1acb-ac4a-43bb-a31c-17321659b0c6"
    wsmap="managed"
  >
    <desc>
      The IPerformanceCollector interface represents a service that collects
      and stores performance metrics data.

      Performance metrics are associated with objects of interfaces like IHost
      and IMachine. Each object has a distinct set of performance metrics.  The
      set can be obtained with <link to="IPerformanceCollector::getMetrics"/>.

      Metric data is collected at the specified intervals and is retained
      internally. The interval and the number of retained samples can be set
      with <link to="IPerformanceCollector::setupMetrics" />. Both metric data
      and collection settings are not persistent, they are discarded as soon as
      VBoxSVC process terminates. Moreover, metric settings and data associated
      with a particular VM only exist while VM is running. They disappear as
      soon as VM shuts down. It is not possible to set up metrics for machines
      that are powered off. One needs to start VM first, then set up metric
      collection parameters.

      Metrics are organized hierarchically, with each level separated by a
      slash (/) character. Generally, the scheme for metric names is like this:

      <tt>Category/Metric[/SubMetric][:aggregation]</tt>

      "Category/Metric" together form the base metric name. A base metric is
      the smallest unit for which a sampling interval and the number of
      retained samples can be set. Only base metrics can be enabled and
      disabled. All sub-metrics are collected when their base metric is
      collected.  Collected values for any set of sub-metrics can be queried
      with <link to="IPerformanceCollector::queryMetricsData" />.

      For example "CPU/Load/User:avg" metric name stands for the "CPU"
      category, "Load" metric, "User" submetric, "average" aggregate. An
      aggregate function is computed over all retained data. Valid aggregate
      functions are:

      <ul>
          <li>avg -- average</li>
          <li>min -- minimum</li>
          <li>max -- maximum</li>
      </ul>

      When setting up metric parameters, querying metric data, enabling or
      disabling metrics wildcards can be used in metric names to specify a
      subset of metrics. For example, to select all CPU-related metrics
      use <tt>CPU/*</tt>, all averages can be queried using <tt>*:avg</tt> and
      so on. To query metric values without aggregates <tt>*:</tt> can be used.

      The valid names for base metrics are:

      <ul>
      <li>CPU/Load</li>
      <li>CPU/MHz</li>
      <li>RAM/Usage</li>
      </ul>

      The general sequence for collecting and retrieving the metrics is:
      <ul>
        <li>
          Obtain an instance of IPerformanceCollector with
          <link to="IVirtualBox::performanceCollector" />
        </li>
        <li>
          Allocate and populate an array with references to objects the metrics
          will be collected for. Use references to IHost and IMachine objects.
        </li>
        <li>
          Allocate and populate an array with base metric names the data will
          be collected for.
        </li>
        <li>
          Call <link to="IPerformanceCollector::setupMetrics" />. From now on
          the metric data will be collected and stored.
        </li>
        <li>
          Wait for the data to get collected.
        </li>
        <li>
          Allocate and populate an array with references to objects the metric
          values will be queried for. You can re-use the object array used for
          setting base metrics.
        </li>
        <li>
          Allocate and populate an array with metric names the data will be
          collected for. Note that metric names differ from base metric names.
        </li>
        <li>
          Call <link to="IPerformanceCollector::queryMetricsData" />. The data
          that have been collected so far are returned. Note that the values
          are still retained internally and data collection continues.
        </li>
      </ul>

      For an example of usage refer to the following files in VirtualBox SDK:
      <ul>
        <li>
          Java: <tt>bindings/webservice/java/jax-ws/samples/metrictest.java</tt>
        </li>
        <li>
          Python: <tt>bindings/xpcom/python/sample/shellcommon.py</tt>
        </li>
      </ul>
    </desc>

    <attribute name="metricNames" type="wstring" readonly="yes" safearray="yes">
      <desc>
        Array of unique names of metrics.

        This array represents all metrics supported by the performance
        collector. Individual objects do not necessarily support all of them.
        <link to="IPerformanceCollector::getMetrics"/> can be used to get the
        list of supported metrics for a particular object.
      </desc>
    </attribute>

    <method name="getMetrics">
      <desc>
        Returns parameters of specified metrics for a set of objects.
        <note>
          @c Null metrics array means all metrics. @c Null object array means
          all existing objects.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Currently, only a comma-separated list of metrics
          is supported.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to return metric parameters for.
        </desc>
      </param>
      <param name="metrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of returned metric parameters.
        </desc>
      </param>
    </method>

    <method name="setupMetrics">
      <desc>
        Sets parameters of specified base metrics for a set of objects. Returns
        an array of <link to="IPerformanceMetric" /> describing the metrics
        have been affected.
        <note>
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to setup metric parameters for.
        </desc>
      </param>
      <param name="period" type="unsigned long" dir="in">
        <desc>
          Time interval in seconds between two consecutive samples of
          performance data.
        </desc>
      </param>
      <param name="count" type="unsigned long" dir="in">
        <desc>
          Number of samples to retain in performance data history. Older
          samples get discarded.
        </desc>
      </param>
      <param name="affectedMetrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of metrics that have been modified by the call to this method.
        </desc>
      </param>
    </method>

    <method name="enableMetrics">
      <desc>
        Turns on collecting specified base metrics. Returns an array of
        <link to="IPerformanceMetric" /> describing the metrics have been
        affected.
        <note>
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to enable metrics for.
        </desc>
      </param>
      <param name="affectedMetrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of metrics that have been modified by the call to this method.
        </desc>
      </param>
    </method>

    <method name="disableMetrics">
      <desc>
        Turns off collecting specified base metrics. Returns an array of
        <link to="IPerformanceMetric" /> describing the metrics have been
        affected.
        <note>
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to disable metrics for.
        </desc>
      </param>
      <param name="affectedMetrics" type="IPerformanceMetric" dir="return" safearray="yes">
        <desc>
          Array of metrics that have been modified by the call to this method.
        </desc>
      </param>
    </method>

    <method name="queryMetricsData">
      <desc>
        Queries collected metrics data for a set of objects.

        The data itself and related metric information are returned in seven
        parallel and one flattened array of arrays. Elements of
        <tt>returnMetricNames, returnObjects, returnUnits, returnScales,
        returnSequenceNumbers, returnDataIndices and returnDataLengths</tt> with
        the same index describe one set of values corresponding to a single
        metric.

        The <tt>returnData</tt> parameter is a flattened array of arrays. Each
        start and length of a sub-array is indicated by
        <tt>returnDataIndices</tt> and <tt>returnDataLengths</tt>. The first
        value for metric <tt>metricNames[i]</tt> is at
        <tt>returnData[returnIndices[i]]</tt>.

        <note>
          @c Null or empty metric name array means all metrics. @c Null or
          empty object array means all existing objects. If metric name array
          contains a single element and object array contains many, the single
          metric name array element is applied to each object array element to
          form metric/object pairs.
        </note>
        <note>
          Data collection continues behind the scenes after call to @c
          queryMetricsData. The return data can be seen as the snapshot of the
          current state at the time of @c queryMetricsData call. The internally
          kept metric values are not cleared by the call. This makes possible
          querying different subsets of metrics or aggregates with subsequent
          calls. If periodic querying is needed it is highly suggested to query
          the values with @c interval*count period to avoid confusion. This way
          a completely new set of data values will be provided by each query.
        </note>
      </desc>
      <param name="metricNames" type="wstring" dir="in" safearray="yes">
        <desc>
          Metric name filter. Comma-separated list of metrics with wildcard
          support.
        </desc>
      </param>
      <param name="objects" type="$unknown" dir="in" safearray="yes">
        <desc>
          Set of objects to query metrics for.
        </desc>
      </param>
      <param name="returnMetricNames" type="wstring" dir="out" safearray="yes">
        <desc>
          Names of metrics returned in @c returnData.
        </desc>
      </param>
      <param name="returnObjects" type="$unknown" dir="out" safearray="yes">
        <desc>
          Objects associated with metrics returned in @c returnData.
        </desc>
      </param>
      <param name="returnUnits" type="wstring" dir="out" safearray="yes">
         <desc>
           Units of measurement for each returned metric.
         </desc>
       </param>
       <param name="returnScales" type="unsigned long" dir="out" safearray="yes">
         <desc>
           Divisor that should be applied to return values in order to get
           floating point values. For example:
           <tt>(double)returnData[returnDataIndices[0]+i] / returnScales[0]</tt>
           will retrieve the floating point value of i-th sample of the first
           metric.
         </desc>
       </param>
       <param name="returnSequenceNumbers" type="unsigned long" dir="out" safearray="yes">
         <desc>
           Sequence numbers of the first elements of value sequences of
           particular metrics returned in @c returnData. For aggregate metrics
           it is the sequence number of the sample the aggregate started
           calculation from.
         </desc>
       </param>
      <param name="returnDataIndices" type="unsigned long" dir="out" safearray="yes">
        <desc>
          Indices of the first elements of value sequences of particular
          metrics returned in @c returnData.
        </desc>
      </param>
      <param name="returnDataLengths" type="unsigned long" dir="out" safearray="yes">
        <desc>
          Lengths of value sequences of particular metrics.
        </desc>
      </param>
      <param name="returnData" type="long" dir="return" safearray="yes">
        <desc>
          Flattened array of all metric data containing sequences of values for
          each metric.
        </desc>
      </param>
    </method>

  </interface>
 <enum
  name="NATAliasMode"
  uuid="67772168-50d9-11df-9669-7fb714ee4fa1">
  <desc></desc>
  <const name="AliasLog" value="0x1">
    <desc></desc>
  </const>
  <const name="AliasProxyOnly" value="0x02">
    <desc></desc>
  </const>
  <const name="AliasUseSamePorts" value="0x04">
    <desc></desc>
  </const>
 </enum>
  <enum
    name="NATProtocol"
    uuid="e90164be-eb03-11de-94af-fff9b1c1b19f"
  >
    <desc>Protocol definitions used with NAT port-forwarding rules.</desc>
    <const name="UDP" value="0">
        <desc>Port-forwarding uses UDP protocol.</desc>
    </const>
    <const name="TCP" value="1">
        <desc>Port-forwarding uses TCP protocol.</desc>
    </const>
  </enum>

  <interface
     name="INATEngine" extends="$unknown"
     uuid="4b286616-eb03-11de-b0fb-1701eca42246"
     wsmap="managed"
     >
     <desc>Interface for managing a NAT engine which is used with a virtual machine. This
       allows for changing NAT behavior such as port-forwarding rules. This interface is
       used in the <link to="INetworkAdapter::natDriver" /> attribute.</desc>
    <attribute name="network" type="wstring">
      <desc>The network attribute of the NAT engine (the same value is used with built-in
        DHCP server to fill corresponding fields of DHCP leases).</desc>
    </attribute>
    <attribute name="hostIP" type="wstring">
        <desc>IP of host interface to bind all opened sockets to.
          <note>Changing this does not change binding of port forwarding.</note>
      </desc>
    </attribute>
    <attribute name="tftpPrefix" type="wstring">
      <desc>TFTP prefix attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases.</desc>
    </attribute>
    <attribute name="tftpBootFile" type="wstring">
      <desc>TFTP boot file attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases.</desc>
    </attribute>
    <attribute name="tftpNextServer" type="wstring">
      <desc>TFTP server attribute which is used with the built-in DHCP server to fill
        the corresponding fields of DHCP leases.
        <note>The preferred form is IPv4 addresses.</note>
      </desc>
    </attribute>
    <attribute name="aliasMode" type="unsigned long">
      <desc></desc>
    </attribute>
    <attribute name="dnsPassDomain" type="boolean">
      <desc>Whether the DHCP server should pass the DNS domain used by the host.</desc>
    </attribute>
    <attribute name="dnsProxy" type="boolean">
      <desc>Whether the DHCP server (and the DNS traffic by NAT) should pass the address
        of the DNS proxy and process traffic using DNS servers registered on the host.</desc>
    </attribute>
    <attribute name="dnsUseHostResolver" type="boolean">
      <desc>Whether the DHCP server (and the DNS traffic by NAT) should pass the address
        of the DNS proxy and process traffic using the host resolver mechanism.</desc>
    </attribute>
    <attribute name="redirects" type="wstring" readonly="yes" safearray="yes">
      <desc>Array of NAT port-forwarding rules in string representation, in the following
        format: "name,protocol id,host ip,host port,guest ip,guest port".</desc>
    </attribute>
    <method name="setNetworkSettings">
      <desc>Sets network configuration of the NAT engine.</desc>
      <param name="mtu" type="unsigned long" dir="in">
        <desc>MTU (maximum transmission unit) of the NAT engine in bytes.</desc>
      </param>
      <param name="sockSnd" type="unsigned long" dir="in">
        <desc>Capacity of the socket send buffer in bytes when creating a new socket.</desc>
      </param>
      <param name="sockRcv" type="unsigned long" dir="in">
        <desc>Capacity of the socket receive buffer in bytes when creating a new socket.</desc>
      </param>
      <param name="TcpWndSnd" type="unsigned long" dir="in">
        <desc>Initial size of the NAT engine's sending TCP window in bytes when
          establishing a new TCP connection.</desc>
      </param>
      <param name="TcpWndRcv" type="unsigned long" dir="in">
        <desc>Initial size of the NAT engine's receiving TCP window in bytes when
          establishing a new TCP connection.</desc>
      </param>
    </method>
    <method name="getNetworkSettings">
      <desc>Returns network configuration of NAT engine. See <link to="#setNetworkSettings" />
        for parameter descriptions.</desc>
      <param name="mtu" type="unsigned long" dir="out" />
      <param name="sockSnd" type="unsigned long" dir="out" />
      <param name="sockRcv" type="unsigned long" dir="out" />
      <param name="TcpWndSnd" type="unsigned long" dir="out" />
      <param name="TcpWndRcv" type="unsigned long" dir="out" />
    </method>
    <method name="addRedirect">
        <desc>Adds a new NAT port-forwarding rule.</desc>
        <param name="name" type="wstring" dir="in">
          <desc>The name of the rule. An empty name is acceptable, in which case the NAT engine
            auto-generates one using the other parameters.</desc>
        </param>
        <param name="proto" type="NATProtocol" dir="in">
          <desc>Protocol handled with the rule.</desc>
        </param>
        <param name="hostIp" type="wstring" dir="in">
          <desc>IP of the host interface to which the rule should apply. An empty ip address is
            acceptable, in which case the NAT engine binds the handling socket to any interface.</desc>
        </param>
        <param name="hostPort" type="unsigned short" dir="in">
          <desc>The port number to listen on.</desc>
        </param>
        <param name="guestIp" type="wstring" dir="in">
          <desc>The IP address of the guest which the NAT engine will forward matching packets
            to. An empty IP address is acceptable, in which case the NAT engine will forward
            packets to the first DHCP lease (x.x.x.15).</desc>
        </param>
        <param name="guestPort" type="unsigned short" dir="in">
          <desc>The port number to forward.</desc>
        </param>
    </method>
    <method name="removeRedirect">
      <desc>Removes a port-forwarding rule that was previously registered.</desc>
      <param name="name" type="wstring" dir="in">
        <desc>The name of the rule to delete.</desc>
      </param>
    </method>
  </interface>

  <module name="VBoxSVC" context="LocalServer">
    <class name="VirtualBox" uuid="B1A7A4F2-47B9-4A1E-82B2-07CCD5323C3F"
           namespace="virtualbox.org">
      <interface name="IVirtualBox" default="yes"/>
      <eventsink name="IVirtualBoxCallback" default="yes"/>
    </class>
  </module>

  <module name="VBoxC" context="InprocServer" threadingModel="Free">
    <class name="Session" uuid="3C02F46D-C9D2-4F11-A384-53F0CF917214"
           namespace="virtualbox.org">
      <interface name="ISession" default="yes"/>
      <eventsink name="IConsoleCallback" default="yes"/>

    </class>
    <class name="CallbackWrapper" uuid="49EE8561-5563-4715-B18C-A4B1A490DAFE"
           namespace="virtualbox.org">
      <interface name="ILocalOwner" default="yes"/>
      <interface name="IVirtualBoxCallback"/>
      <interface name="IConsoleCallback"/>
    </class>
  </module>

</library>

</idl>

<!-- vim: set shiftwidth=2 tabstop=2 expandtab: -->
